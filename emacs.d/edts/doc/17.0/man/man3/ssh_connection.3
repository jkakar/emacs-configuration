.TH ssh_connection 3 "ssh 3.0.1" "Ericsson AB" "Erlang Module Definition"
.SH NAME
ssh_connection \- This module provides API functions to send  SSH Connection Protocol 
  events to the other side of an SSH channel.
  
.SH DESCRIPTION
.LP
The SSH Connection Protocol is used by clients and servers (i\&.e\&. SSH channels) to communicate over the SSH connection\&. The API functions in this module sends SSH Connection Protocol events that are received as messages by the remote channel\&. In the case that the receiving channel is an Erlang process the message will be on the following format \fI{ssh_cm, ssh_connection_ref(), ssh_event_msg()}\fR\&\&. If the \fBssh_channel\fR\& behavior is used to implement the channel process these will be handled by \fBhandle_ssh_msg/2 \fR\&\&.
.SH "DATA TYPES "

.LP
Type definitions that are used more than once in this module and/or abstractions to indicate the intended use of the data type:
.LP
\fIboolean() = true | false \fR\&
.LP
\fIstring() = list of ASCII characters\fR\&
.LP
\fItimeout() = infinity | integer() - in milliseconds\&.\fR\&
.LP
\fIssh_connection_ref() - opaque to the user returned by ssh:connect/3 or sent to an SSH channel processes\fR\&
.LP
\fIssh_channel_id() = integer() \fR\&
.LP
\fIssh_data_type_code() = 1 ("stderr") | 0 ("normal") are currently valid values see\fR\& RFC 4254  section 5\&.2\&.
.LP
\fIssh_request_status() = success | failure\fR\&
.LP
\fIevent() = {ssh_cm, ssh_connection_ref(), ssh_event_msg()} \fR\&
.LP
\fIssh_event_msg() = data_events() | status_events() | terminal_events() \fR\&
.RS 2
.TP 2
.B
\fBdata_events()\fR\& :

.RS 2
.TP 2
.B
\fI{data, ssh_channel_id(), ssh_data_type_code(), binary() = Data}\fR\&:
 Data has arrived on the channel\&. This event is sent as result of calling \fB ssh_connection:send/[3,4,5] \fR\&
.TP 2
.B
\fI{eof, ssh_channel_id()}\fR\&:
Indicates that the other side will not send any more data\&. This event is sent as result of calling \fB ssh_connection:send_eof/2\fR\&
.RE
.TP 2
.B
\fBstatus_events()\fR\& :

.RS 2
.TP 2
.B
\fI{signal, ssh_channel_id(), ssh_signal()}\fR\&:
A signal can be delivered to the remote process/service using the following message\&. Some systems will not support signals, in which case they should ignore this message\&. There is currently no funtion to generate this event as the signals refered to are on OS-level and not something generated by an Erlang program\&.
.TP 2
.B
\fI{exit_signal, ssh_channel_id(), string() = ExitSignal, string() = ErrorMsg, string() = LanguageString}\fR\&:
A remote execution may terminate violently due to a signal then this message may be received\&. For details on valid string values see RFC 4254 section 6\&.10\&. Special case of the signals mentioned above\&.
.TP 2
.B
\fI{exit_status, ssh_channel_id(), integer() = ExitStatus}\fR\&:
 When the command running at the other end terminates, the following message can be sent to return the exit status of the command\&. A zero \&'exit_status\&' usually means that the command terminated successfully\&. This event is sent as result of calling \fB ssh_connection:exit_status/3\fR\&
.TP 2
.B
\fI{closed, ssh_channel_id()}\fR\&:
 This event is sent as result of calling \fBssh_connection:close/2\fR\& Both the handling of this event and sending of it will be taken care of by the \fBssh_channel\fR\& behavior\&.
.RE
.TP 2
.B
\fBterminal_events()\fR\& :
Channels implementing a shell and command execution on the server side should handle the following messages that may be sent by client channel processes\&.
.LP

.RS -4
.B
Note:
.RE
Events that includes a \fI WantReply\fR\& expects the event handling process to call \fBssh_connection:reply_request/4\fR\& with the boolean value of \fI WantReply\fR\& as the second argument\&.

.RS 2
.TP 2
.B
\fI{env, ssh_channel_id(), boolean() = WantReply, string() = Var, string() = Value}\fR\&:
 Environment variables may be passed to the shell/command to be started later\&. This event is sent as result of calling \fB ssh_connection:setenv/5\fR\&
.TP 2
.B
\fI{pty, ssh_channel_id(), boolean() = WantReply, {string() = Terminal, integer() = CharWidth, integer() = RowHeight, integer() = PixelWidth, integer() = PixelHight, [{atom() | integer() = Opcode, integer() = Value}] = TerminalModes}}\fR\&:
A pseudo-terminal has been requested for the session\&. Terminal is the value of the TERM environment variable value (e\&.g\&., vt100)\&. Zero dimension parameters must be ignored\&. The character/row dimensions override the pixel dimensions (when nonzero)\&. Pixel dimensions refer to the drawable area of the window\&. The \fIOpcode\fR\& in the \fITerminalModes\fR\& list is the mnemonic name, represented as an lowercase erlang atom, defined in RFC 4254  section 8, or the opcode if the mnemonic name is not listed in the RFC\&. Example \fIOP code: 53, mnemonic name ECHO erlang atom: echo\fR\&\&. There is currently no API function to generate this event\&.
.TP 2
.B
\fI{shell, boolean() = WantReply}\fR\&:
 This message will request that the user\&'s default shell be started at the other end\&. This event is sent as result of calling \fB ssh_connection:shell/2\fR\&
.TP 2
.B
\fI{window_change, ssh_channel_id(), integer() = CharWidth, integer() = RowHeight, integer() = PixWidth, integer() = PixHeight}\fR\&:
 When the window (terminal) size changes on the client side, it MAY send a message to the server side to inform it of the new dimensions\&. There is currently no API function to generate this event\&.
.TP 2
.B
\fI{exec, ssh_channel_id(), boolean() = WantReply, string() = Cmd}\fR\&:
 This message will request that the server starts execution of the given command\&. This event is sent as result of calling \fBssh_connection:exec/4 \fR\&
.RE
.RE
.SH EXPORTS
.LP
.B
adjust_window(ConnectionRef, ChannelId, NumOfBytes) -> ok
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref() 
.br
 ChannelId = ssh_channel_id() 
.br
 NumOfBytes = integer()
.br
.RE
.RE
.RS
.LP
Adjusts the SSH flowcontrol window\&. This shall be done by both client and server side channel processes\&.
.LP

.RS -4
.B
Note:
.RE
Channels implemented with the \fB ssh_channel behavior\fR\& will normaly not need to call this function as flow control will be handled by the behavior\&. The behavior will adjust the window every time the callback \fB handle_ssh_msg/2 \fR\& has returned after processing channel data

.RE
.LP
.B
close(ConnectionRef, ChannelId) -> ok
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref() 
.br
 ChannelId = ssh_channel_id()
.br
.RE
.RE
.RS
.LP
A server or client channel process can choose to close their session by sending a close event\&.
.LP

.RS -4
.B
Note:
.RE
This function will be called by the ssh_channel behavior when the channel is terminated see \fB ssh_channel(3) \fR\& so channels implemented with the behavior should not call this function explicitly\&.

.RE
.LP
.B
exec(ConnectionRef, ChannelId, Command, TimeOut) -> ssh_request_status() 
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref() 
.br
 ChannelId = ssh_channel_id()
.br
 Command = string()
.br
Timeout = timeout() 
.br
.RE
.RE
.RS
.LP
Should be called by a client channel process to request that the server starts execution of the given command, the result will be several messages according to the following pattern\&. Note that the last message will be a channel close message, as the exec request is a one time execution that closes the channel when it is done\&.
.RS 2
.TP 2
.B
\fI N x {ssh_cm, ssh_connection_ref(), {data, ssh_channel_id(), ssh_data_type_code(), binary() = Data}} \fR\&:
The result of executing the command may be only one line or thousands of lines depending on the command\&.
.TP 2
.B
\fI0 or 1 x {ssh_cm, ssh_connection_ref(), {eof, ssh_channel_id()}}\fR\&:
Indicates that no more data will be sent\&.
.TP 2
.B
\fI0 or 1 x {ssh_cm, ssh_connection_ref(), {exit_signal, ssh_channel_id(), string() = ExitSignal, string() = ErrorMsg, string() = LanguageString}}\fR\&:
Not all systems send signals\&. For details on valid string values see RFC 4254 section 6\&.10 
.TP 2
.B
\fI0 or 1 x {ssh_cm, ssh_connection_ref(), {exit_status, ssh_channel_id(), integer() = ExitStatus}}\fR\&:
It is recommended by the \fIssh connection protocol\fR\& that this message shall be sent, but that may not always be the case\&.
.TP 2
.B
\fI 1 x {ssh_cm, ssh_connection_ref(), {closed, ssh_channel_id()}}\fR\&:
Indicates that the ssh channel started for the execution of the command has now been shutdown\&.
.RE
.RE
.LP
.B
exit_status(ConnectionRef, ChannelId, Status) -> ok
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref() 
.br
 ChannelId = ssh_channel_id()
.br
 Status = integer()
.br
.RE
.RE
.RS
.LP
Should be called by a server channel process to sends the exit status of a command to the client\&.
.RE
.LP
.B
reply_request(ConnectionRef, WantReply, Status, ChannelId) -> ok
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref() 
.br
 WantReply = boolean()
.br
 Status = ssh_request_status() 
.br
 ChannelId = ssh_channel_id()
.br
.RE
.RE
.RS
.LP
Sends status replies to requests where the requester has stated that they want a status report e\&.i \&.\fI WantReply = true\fR\&, if \fI WantReply\fR\& is false calling this function will be a "noop"\&. Should be called while handling an ssh connection protocol message containing a \fIWantReply\fR\& boolean value\&.
.RE
.LP
.B
send(ConnectionRef, ChannelId, Data) ->
.br
.B
send(ConnectionRef, ChannelId, Data, Timeout) ->
.br
.B
send(ConnectionRef, ChannelId, Type, Data) ->
.br
.B
send(ConnectionRef, ChannelId, Type, Data, TimeOut) -> ok | {error, timeout} | {error, closed}
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref() 
.br
 ChannelId = ssh_channel_id()
.br
 Data = binary()
.br
 Type = ssh_data_type_code()
.br
 Timeout = timeout()
.br
.RE
.RE
.RS
.LP
Should be called by client- and server channel processes to send data to each other\&.
.RE
.LP
.B
send_eof(ConnectionRef, ChannelId) -> ok | {error, closed}
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref() 
.br
 ChannelId = ssh_channel_id()
.br
.RE
.RE
.RS
.LP
Sends eof on the channel \fIChannelId\fR\&\&.
.RE
.LP
.B
session_channel(ConnectionRef, Timeout) -> 
.br
.B
session_channel(ConnectionRef, InitialWindowSize, MaxPacketSize, Timeout) -> {ok, ssh_channel_id()} | {error, Reason}
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref()
.br
 InitialWindowSize = integer() 
.br
 MaxPacketSize = integer() 
.br
 Timeout = timeout()
.br
 Reason = term() 
.br
.RE
.RE
.RS
.LP
Opens a channel for an SSH session\&. The channel id returned from this function is the id used as input to the other funtions in this module\&.
.RE
.LP
.B
setenv(ConnectionRef, ChannelId, Var, Value, TimeOut) -> ssh_request_status()
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref() 
.br
 ChannelId = ssh_channel_id()
.br
 Var = string()
.br
 Value = string()
.br
 Timeout = timeout()
.br
.RE
.RE
.RS
.LP
Environment variables may be passed before starting the shell/command\&. Should be called by a client channel processes\&.
.RE
.LP
.B
shell(ConnectionRef, ChannelId) -> ssh_request_status() 
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref() 
.br
 ChannelId = ssh_channel_id()
.br
.RE
.RE
.RS
.LP
Should be called by a client channel process to request that the user\&'s default shell (typically defined in /etc/passwd in UNIX systems) shall be executed at the server end\&.
.RE
.LP
.B
subsystem(ConnectionRef, ChannelId, Subsystem, Timeout) -> ssh_request_status()
.br
.RS
.LP
Types:

.RS 3
 ConnectionRef = ssh_connection_ref() 
.br
 ChannelId = ssh_channel_id()
.br
 Subsystem = string()
.br
 Timeout = timeout()
.br
.RE
.RE
.RS
.LP
Should be called by a client channel process for requesting to execute a predefined subsystem on the server\&.
.RE