.TH ets 3 "stdlib 2.0" "Ericsson AB" "Erlang Module Definition"
.SH NAME
ets \- Built-In Term Storage
.SH DESCRIPTION
.LP
This module is an interface to the Erlang built-in term storage BIFs\&. These provide the ability to store very large quantities of data in an Erlang runtime system, and to have constant access time to the data\&. (In the case of \fIordered_set\fR\&, see below, access time is proportional to the logarithm of the number of objects stored)\&.
.LP
Data is organized as a set of dynamic tables, which can store tuples\&. Each table is created by a process\&. When the process terminates, the table is automatically destroyed\&. Every table has access rights set at creation\&.
.LP
Tables are divided into four different types, \fIset\fR\&, \fIordered_set\fR\&, \fIbag\fR\& and \fIduplicate_bag\fR\&\&. A \fIset\fR\& or \fIordered_set\fR\& table can only have one object associated with each key\&. A \fIbag\fR\& or \fIduplicate_bag\fR\& can have many objects associated with each key\&.
.LP
The number of tables stored at one Erlang node is limited\&. The current default limit is approximately 1400 tables\&. The upper limit can be increased by setting the environment variable \fIERL_MAX_ETS_TABLES\fR\& before starting the Erlang runtime system (i\&.e\&. with the \fI-env\fR\& option to \fIerl\fR\&/\fIwerl\fR\&)\&. The actual limit may be slightly higher than the one specified, but never lower\&.
.LP
Note that there is no automatic garbage collection for tables\&. Even if there are no references to a table from any process, it will not automatically be destroyed unless the owner process terminates\&. It can be destroyed explicitly by using \fIdelete/1\fR\&\&. The default owner is the process that created the table\&. Table ownership can be transferred at process termination by using the \fBheir\fR\& option or explicitly by calling \fBgive_away/3\fR\&\&.
.LP
Some implementation details:
.RS 2
.TP 2
*
In the current implementation, every object insert and look-up operation results in a copy of the object\&.
.LP
.TP 2
*
\fI\&'$end_of_table\&'\fR\& should not be used as a key since this atom is used to mark the end of the table when using \fIfirst\fR\&/\fInext\fR\&\&.
.LP
.RE

.LP
Also worth noting is the subtle difference between \fImatching\fR\& and \fIcomparing equal\fR\&, which is demonstrated by the different table types \fIset\fR\& and \fIordered_set\fR\&\&. Two Erlang terms \fImatch\fR\& if they are of the same type and have the same value, so that \fI1\fR\& matches \fI1\fR\&, but not \fI1\&.0\fR\& (as \fI1\&.0\fR\& is a \fIfloat()\fR\& and not an \fIinteger()\fR\&)\&. Two Erlang terms \fIcompare equal\fR\& if they either are of the same type and value, or if both are numeric types and extend to the same value, so that \fI1\fR\& compares equal to both \fI1\fR\& and \fI1\&.0\fR\&\&. The \fIordered_set\fR\& works on the \fIErlang term order\fR\& and there is no defined order between an \fIinteger()\fR\& and a \fIfloat()\fR\& that extends to the same value, hence the key \fI1\fR\& and the key \fI1\&.0\fR\& are regarded as equal in an \fIordered_set\fR\& table\&.
.SH "FAILURE"

.LP
In general, the functions below will exit with reason \fIbadarg\fR\& if any argument is of the wrong format, if the table identifier is invalid or if the operation is denied due to table access rights (\fBprotected\fR\& or \fBprivate\fR\&)\&.
.SH "CONCURRENCY"

.LP
This module provides some limited support for concurrent access\&. All updates to single objects are guaranteed to be both \fIatomic\fR\& and \fIisolated\fR\&\&. This means that an updating operation towards a single object will either succeed or fail completely without any effect at all (atomicy)\&. Nor can any intermediate results of the update be seen by other processes (isolation)\&. Some functions that update several objects state that they even guarantee atomicy and isolation for the entire operation\&. In database terms the isolation level can be seen as "serializable", as if all isolated operations were carried out serially, one after the other in a strict order\&.
.LP
No other support is available within ETS that would guarantee consistency between objects\&. However, the \fIsafe_fixtable/2\fR\& function can be used to guarantee that a sequence of \fIfirst/1\fR\& and \fInext/2\fR\& calls will traverse the table without errors and that each existing object in the table is visited exactly once, even if another process (or the same process) simultaneously deletes or inserts objects into the table\&. Nothing more is guaranteed; in particular objects that are inserted or deleted during such a traversal may be visited once or not at all\&. Functions that internally traverse over a table, like \fIselect\fR\& and \fImatch\fR\&, will give the same guarantee as \fIsafe_fixtable\fR\&\&.
.SH "MATCH SPECIFICATIONS"

.LP
Some of the functions uses a \fImatch specification\fR\&, match_spec\&. A brief explanation is given in \fBselect/2\fR\&\&. For a detailed description, see the chapter "Match specifications in Erlang" in \fIERTS User\&'s Guide\fR\&\&.
.SH DATA TYPES
.nf

\fBaccess()\fR\& = public | protected | private
.br
.fi
.nf

.B
\fBcontinuation()\fR\&
.br
.fi
.RS
.LP
Opaque continuation used by \fB\fIselect/1,3\fR\&\fR\&, \fB\fIselect_reverse/1,3\fR\&\fR\&, \fB\fImatch/1,3\fR\&\fR\&, and \fB\fImatch_object/1,3\fR\&\fR\&\&.
.RE
.nf

\fBmatch_spec()\fR\& = [{\fBmatch_pattern()\fR\&, [term()], [term()]}]
.br
.fi
.RS
.LP
A match specification, see above\&.
.RE
.nf

\fBcomp_match_spec()\fR\&
.br
.fi
.RS
.LP
A compiled match specification\&.
.RE
.nf

\fBmatch_pattern()\fR\& = atom() | tuple()
.br
.fi
.nf

\fBtab()\fR\& = atom() | \fBtid()\fR\&
.br
.fi
.nf

\fBtid()\fR\&
.br
.fi
.RS
.LP
A table identifier, as returned by new/2\&.
.RE
.nf

\fBtype()\fR\& = set | ordered_set | bag | duplicate_bag
.br
.fi
.SH EXPORTS
.LP
.nf

.B
all() -> [Tab]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
.RE
.RE
.RS
.LP
Returns a list of all tables at the node\&. Named tables are given by their names, unnamed tables are given by their table identifiers\&.
.LP
There is no guarantee of consistency in the returned list\&. Tables created or deleted by other processes "during" the ets:all() call may or may not be included in the list\&. Only tables created/deleted \fIbefore\fR\& ets:all() is called are guaranteed to be included/excluded\&.
.RE
.LP
.nf

.B
delete(Tab) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
.RE
.RE
.RS
.LP
Deletes the entire table \fITab\fR\&\&.
.RE
.LP
.nf

.B
delete(Tab, Key) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Key = term()
.br
.RE
.RE
.RS
.LP
Deletes all objects with the key \fIKey\fR\& from the table \fITab\fR\&\&.
.RE
.LP
.nf

.B
delete_all_objects(Tab) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
.RE
.RE
.RS
.LP
Delete all objects in the ETS table \fITab\fR\&\&. The operation is guaranteed to be \fBatomic and isolated\fR\&\&.
.RE
.LP
.nf

.B
delete_object(Tab, Object) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Object = tuple()
.br
.RE
.RE
.RS
.LP
Delete the exact object \fIObject\fR\& from the ETS table, leaving objects with the same key but other differences (useful for type \fIbag\fR\&)\&. In a \fIduplicate_bag\fR\&, all instances of the object will be deleted\&.
.RE
.LP
.nf

.B
file2tab(Filename) -> {ok, Tab} | {error, Reason}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Filename = \fBfile:name()\fR\&
.br
Tab = \fBtab()\fR\&
.br
Reason = term()
.br
.RE
.RE
.RS
.LP
Reads a file produced by \fBtab2file/2\fR\& or \fBtab2file/3\fR\& and creates the corresponding table \fITab\fR\&\&.
.LP
Equivalent to \fIfile2tab(Filename, [])\fR\&\&.
.RE
.LP
.nf

.B
file2tab(Filename, Options) -> {ok, Tab} | {error, Reason}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Filename = \fBfile:name()\fR\&
.br
Tab = \fBtab()\fR\&
.br
Options = [Option]
.br
Option = {verify, boolean()}
.br
Reason = term()
.br
.RE
.RE
.RS
.LP
Reads a file produced by \fBtab2file/2\fR\& or \fBtab2file/3\fR\& and creates the corresponding table \fITab\fR\&\&.
.LP
The currently only supported option is \fI{verify,boolean()}\fR\&\&. If verification is turned on (by means of specifying \fI{verify,true}\fR\&), the function utilizes whatever information is present in the file to assert that the information is not damaged\&. How this is done depends on which \fIextended_info\fR\& was written using \fBtab2file/3\fR\&\&.
.LP
If no \fIextended_info\fR\& is present in the file and \fI{verify,true}\fR\& is specified, the number of objects written is compared to the size of the original table when the dump was started\&. This might make verification fail if the table was \fIpublic\fR\& and objects were added or removed while the table was dumped to file\&. To avoid this type of problems, either do not verify files dumped while updated simultaneously or use the \fI{extended_info, [object_count]}\fR\& option to \fBtab2file/3\fR\&, which extends the information in the file with the number of objects actually written\&.
.LP
If verification is turned on and the file was written with the option \fI{extended_info, [md5sum]}\fR\&, reading the file is slower and consumes radically more CPU time than otherwise\&.
.LP
\fI{verify,false}\fR\& is the default\&.
.RE
.LP
.nf

.B
first(Tab) -> Key | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Key = term()
.br
.RE
.RE
.RS
.LP
Returns the first key \fIKey\fR\& in the table \fITab\fR\&\&. If the table is of the \fIordered_set\fR\& type, the first key in Erlang term order will be returned\&. If the table is of any other type, the first key according to the table\&'s internal order will be returned\&. If the table is empty, \fI\&'$end_of_table\&'\fR\& will be returned\&.
.LP
Use \fInext/2\fR\& to find subsequent keys in the table\&.
.RE
.LP
.nf

.B
foldl(Function, Acc0, Tab) -> Acc1
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Function = fun((Element :: term(), AccIn) -> AccOut)
.br
Tab = \fBtab()\fR\&
.br
Acc0 = Acc1 = AccIn = AccOut = term()
.br
.RE
.RE
.RS
.LP
\fIAcc0\fR\& is returned if the table is empty\&. This function is similar to \fIlists:foldl/3\fR\&\&. The order in which the elements of the table are traversed is unspecified, except for tables of type \fIordered_set\fR\&, for which they are traversed first to last\&.
.LP
If \fIFunction\fR\& inserts objects into the table, or another process inserts objects into the table, those objects \fImay\fR\& (depending on key ordering) be included in the traversal\&.
.RE
.LP
.nf

.B
foldr(Function, Acc0, Tab) -> Acc1
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Function = fun((Element :: term(), AccIn) -> AccOut)
.br
Tab = \fBtab()\fR\&
.br
Acc0 = Acc1 = AccIn = AccOut = term()
.br
.RE
.RE
.RS
.LP
\fIAcc0\fR\& is returned if the table is empty\&. This function is similar to \fIlists:foldr/3\fR\&\&. The order in which the elements of the table are traversed is unspecified, except for tables of type \fIordered_set\fR\&, for which they are traversed last to first\&.
.LP
If \fIFunction\fR\& inserts objects into the table, or another process inserts objects into the table, those objects \fImay\fR\& (depending on key ordering) be included in the traversal\&.
.RE
.LP
.nf

.B
from_dets(Tab, DetsTab) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
DetsTab = \fBdets:tab_name()\fR\&
.br
.RE
.RE
.RS
.LP
Fills an already created ETS table with the objects in the already opened Dets table named \fIDetsTab\fR\&\&. The existing objects of the ETS table are kept unless overwritten\&.
.LP
Throws a badarg error if any of the tables does not exist or the dets table is not open\&.
.RE
.LP
.nf

.B
fun2ms(LiteralFun) -> MatchSpec
.br
.fi
.br
.RS
.LP
Types:

.RS 3
LiteralFun = function()
.br
MatchSpec = \fBmatch_spec()\fR\&
.br
.RE
.RE
.RS
.LP
Pseudo function that by means of a \fIparse_transform\fR\& translates \fILiteralFun\fR\& typed as parameter in the function call to a \fBmatch_spec\fR\&\&. With "literal" is meant that the fun needs to textually be written as the parameter of the function, it cannot be held in a variable which in turn is passed to the function)\&.
.LP
The parse transform is implemented in the module \fIms_transform\fR\& and the source \fImust\fR\& include the file \fIms_transform\&.hrl\fR\& in STDLIB for this pseudo function to work\&. Failing to include the hrl file in the source will result in a runtime error, not a compile time ditto\&. The include file is easiest included by adding the line \fI-include_lib("stdlib/include/ms_transform\&.hrl")\&.\fR\& to the source file\&.
.LP
The fun is very restricted, it can take only a single parameter (the object to match): a sole variable or a tuple\&. It needs to use the \fIis_\fR\& guard tests\&. Language constructs that have no representation in a match_spec (like \fIif\fR\&, \fIcase\fR\&, \fIreceive\fR\& etc) are not allowed\&.
.LP
The return value is the resulting match_spec\&.
.LP
Example:
.LP
.nf

1> ets:fun2ms(fun({M,N}) when N > 3 -> M end)\&.
[{{'$1','$2'},[{'>','$2',3}],['$1']}]
.fi
.LP
Variables from the environment can be imported, so that this works:
.LP
.nf

2> X=3\&.
3
3> ets:fun2ms(fun({M,N}) when N > X -> M end)\&.
[{{'$1','$2'},[{'>','$2',{const,3}}],['$1']}]
.fi
.LP
The imported variables will be replaced by match_spec \fIconst\fR\& expressions, which is consistent with the static scoping for Erlang funs\&. Local or global function calls can not be in the guard or body of the fun however\&. Calls to builtin match_spec functions of course is allowed:
.LP
.nf

4> ets:fun2ms(fun({M,N}) when N > X, is_atomm(M) -> M end)\&.
Error: fun containing local Erlang function calls
('is_atomm' called in guard) cannot be translated into match_spec
{error,transform_error}
5> ets:fun2ms(fun({M,N}) when N > X, is_atom(M) -> M end)\&.
[{{'$1','$2'},[{'>','$2',{const,3}},{is_atom,'$1'}],['$1']}]
.fi
.LP
As can be seen by the example, the function can be called from the shell too\&. The fun needs to be literally in the call when used from the shell as well\&. Other means than the parse_transform are used in the shell case, but more or less the same restrictions apply (the exception being records, as they are not handled by the shell)\&.
.LP

.RS -4
.B
Warning:
.RE
If the parse_transform is not applied to a module which calls this pseudo function, the call will fail in runtime (with a \fIbadarg\fR\&)\&. The module \fIets\fR\& actually exports a function with this name, but it should never really be called except for when using the function in the shell\&. If the \fIparse_transform\fR\& is properly applied by including the \fIms_transform\&.hrl\fR\& header file, compiled code will never call the function, but the function call is replaced by a literal match_spec\&.

.LP
For more information, see \fBms_transform(3)\fR\&\&.
.RE
.LP
.nf

.B
give_away(Tab, Pid, GiftData) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Pid = pid()
.br
GiftData = term()
.br
.RE
.RE
.RS
.LP
Make process \fIPid\fR\& the new owner of table \fITab\fR\&\&. If successful, the message \fI{\&'ETS-TRANSFER\&',Tab,FromPid,GiftData}\fR\& will be sent to the new owner\&.
.LP
The process \fIPid\fR\& must be alive, local and not already the owner of the table\&. The calling process must be the table owner\&.
.LP
Note that \fIgive_away\fR\& does not at all affect the \fBheir\fR\& option of the table\&. A table owner can for example set the \fIheir\fR\& to itself, give the table away and then get it back in case the receiver terminates\&.
.RE
.LP
.nf

.B
i() -> ok
.br
.fi
.br
.RS
.LP
Displays information about all ETS tables on tty\&.
.RE
.LP
.nf

.B
i(Tab) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
.RE
.RE
.RS
.LP
Browses the table \fITab\fR\& on tty\&.
.RE
.LP
.nf

.B
info(Tab) -> InfoList | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
InfoList = [InfoTuple]
.br
InfoTuple = {compressed, boolean()}
.br
          | {heir, pid() | none}
.br
          | {keypos, integer() >= 1}
.br
          | {memory, integer() >= 0}
.br
          | {name, atom()}
.br
          | {named_table, boolean()}
.br
          | {node, node()}
.br
          | {owner, pid()}
.br
          | {protection, \fBaccess()\fR\&}
.br
          | {size, integer() >= 0}
.br
          | {type, \fBtype()\fR\&}
.br
.RE
.RE
.RS
.LP
Returns information about the table \fITab\fR\& as a list of tuples\&. If \fITab\fR\& has the correct type for a table identifier, but does not refer to an existing ETS table, \fIundefined\fR\& is returned\&. If \fITab\fR\& is not of the correct type, this function fails with reason \fIbadarg\fR\&\&.
.RS 2
.TP 2
*
\fI{compressed, boolean()}\fR\&
.br
 Indicates if the table is compressed or not\&.
.LP
.TP 2
*
\fI{heir, pid() | none}\fR\&
.br
 The pid of the heir of the table, or \fInone\fR\& if no heir is set\&.
.LP
.TP 2
*
\fI{keypos, integer() >= 1}\fR\&
.br
 The key position\&.
.LP
.TP 2
*
\fI{memory, integer() >= 0\fR\&
.br
 The number of words allocated to the table\&.
.LP
.TP 2
*
\fI{name, atom()}\fR\&
.br
 The name of the table\&.
.LP
.TP 2
*
\fI{named_table, boolean()}\fR\&
.br
 Indicates if the table is named or not\&.
.LP
.TP 2
*
\fI{node, node()}\fR\&
.br
 The node where the table is stored\&. This field is no longer meaningful as tables cannot be accessed from other nodes\&.
.LP
.TP 2
*
\fI{owner, pid()}\fR\&
.br
 The pid of the owner of the table\&.
.LP
.TP 2
*
\fI{protection, \fBaccess()\fR\&}\fR\&
.br
 The table access rights\&.
.LP
.TP 2
*
\fI{size, integer() >= 0\fR\&
.br
 The number of objects inserted in the table\&.
.LP
.TP 2
*
\fI{type, \fBtype()\fR\&}\fR\&
.br
 The table type\&.
.LP
.RE

.RE
.LP
.nf

.B
info(Tab, Item) -> Value | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Item = compressed
.br
     | fixed
.br
     | heir
.br
     | keypos
.br
     | memory
.br
     | name
.br
     | named_table
.br
     | node
.br
     | owner
.br
     | protection
.br
     | safe_fixed
.br
     | size
.br
     | stats
.br
     | type
.br
Value = term()
.br
.RE
.RE
.RS
.LP
Returns the information associated with \fIItem\fR\& for the table \fITab\fR\&, or returns \fIundefined\fR\& if \fITab\fR\& does not refer an existing ETS table\&. If \fITab\fR\& is not of the correct type, or if \fIItem\fR\& is not one of the allowed values, this function fails with reason \fIbadarg\fR\&\&.
.LP

.RS -4
.B
Warning:
.RE
In R11B and earlier, this function would not fail but return \fIundefined\fR\& for invalid values for \fIItem\fR\&\&.

.LP
In addition to the \fI{Item,Value}\fR\& pairs defined for \fIinfo/1\fR\&, the following items are allowed:
.RS 2
.TP 2
*
\fIItem=fixed, Value=boolean()\fR\&
.br
 Indicates if the table is fixed by any process or not\&.
.LP
.TP 2
*
\fIItem=safe_fixed, Value={FirstFixed,Info}|false\fR\& 
.br

.RS 2
.LP
If the table has been fixed using \fIsafe_fixtable/2\fR\&, the call returns a tuple where \fIFirstFixed\fR\& is the time when the table was first fixed by a process, which may or may not be one of the processes it is fixed by right now\&.
.RE
.RS 2
.LP
\fIInfo\fR\& is a possibly empty lists of tuples \fI{Pid,RefCount}\fR\&, one tuple for every process the table is fixed by right now\&. \fIRefCount\fR\& is the value of the reference counter, keeping track of how many times the table has been fixed by the process\&.
.RE
.RS 2
.LP
If the table never has been fixed, the call returns \fIfalse\fR\&\&.
.RE
.LP
.TP 2
*
\fIItem=stats, Value=tuple()\fR\& 
.br
Returns internal statistics about set, bag and duplicate_bag tables on an internal format used by OTP test suites\&. Not for production use\&.
.LP
.RE

.RE
.LP
.nf

.B
init_table(Tab, InitFun) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
InitFun = fun((Arg) -> Res)
.br
Arg = read | close
.br
Res = end_of_input | {Objects :: [term()], InitFun} | term()
.br
.RE
.RE
.RS
.LP
Replaces the existing objects of the table \fITab\fR\& with objects created by calling the input function \fIInitFun\fR\&, see below\&. This function is provided for compatibility with the \fIdets\fR\& module, it is not more efficient than filling a table by using \fIets:insert/2\fR\&\&.
.LP
When called with the argument \fIread\fR\& the function \fIInitFun\fR\& is assumed to return \fIend_of_input\fR\& when there is no more input, or \fI{Objects, Fun}\fR\&, where \fIObjects\fR\& is a list of objects and \fIFun\fR\& is a new input function\&. Any other value Value is returned as an error \fI{error, {init_fun, Value}}\fR\&\&. Each input function will be called exactly once, and should an error occur, the last function is called with the argument \fIclose\fR\&, the reply of which is ignored\&.
.LP
If the type of the table is \fIset\fR\& and there is more than one object with a given key, one of the objects is chosen\&. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions\&. This holds also for duplicated objects stored in tables of type \fIbag\fR\&\&.
.RE
.LP
.nf

.B
insert(Tab, ObjectOrObjects) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
ObjectOrObjects = tuple() | [tuple()]
.br
.RE
.RE
.RS
.LP
Inserts the object or all of the objects in the list \fIObjectOrObjects\fR\& into the table \fITab\fR\&\&. If the table is a \fIset\fR\& and the key of the inserted objects \fImatches\fR\& the key of any object in the table, the old object will be replaced\&. If the table is an \fIordered_set\fR\& and the key of the inserted object \fIcompares equal\fR\& to the key of any object in the table, the old object is also replaced\&. If the list contains more than one object with \fImatching\fR\& keys and the table is a \fIset\fR\&, one will be inserted, which one is not defined\&. The same thing holds for \fIordered_set\fR\&, but will also happen if the keys \fIcompare equal\fR\&\&.
.LP
The entire operation is guaranteed to be \fBatomic and isolated\fR\&, even when a list of objects is inserted\&.
.RE
.LP
.nf

.B
insert_new(Tab, ObjectOrObjects) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
ObjectOrObjects = tuple() | [tuple()]
.br
.RE
.RE
.RS
.LP
This function works exactly like \fIinsert/2\fR\&, with the exception that instead of overwriting objects with the same key (in the case of \fIset\fR\& or \fIordered_set\fR\&) or adding more objects with keys already existing in the table (in the case of \fIbag\fR\& and \fIduplicate_bag\fR\&), it simply returns \fIfalse\fR\&\&. If \fIObjectOrObjects\fR\& is a list, the function checks \fIevery\fR\& key prior to inserting anything\&. Nothing will be inserted if not \fIall\fR\& keys present in the list are absent from the table\&. Like \fIinsert/2\fR\&, the entire operation is guaranteed to be \fBatomic and isolated\fR\&\&.
.RE
.LP
.nf

.B
is_compiled_ms(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
This function is used to check if a term is a valid compiled \fBmatch_spec\fR\&\&. The compiled match_spec is an opaque datatype which can \fInot\fR\& be sent between Erlang nodes nor be stored on disk\&. Any attempt to create an external representation of a compiled match_spec will result in an empty binary (\fI<<>>\fR\&)\&. As an example, the following expression:
.LP
.nf

ets:is_compiled_ms(ets:match_spec_compile([{'_',[],[true]}])).
.fi
.LP
will yield \fItrue\fR\&, while the following expressions:
.LP
.nf

MS = ets:match_spec_compile([{'_',[],[true]}]),
Broken = binary_to_term(term_to_binary(MS)),
ets:is_compiled_ms(Broken).
.fi
.LP
will yield false, as the variable \fIBroken\fR\& will contain a compiled match_spec that has passed through external representation\&.
.LP

.RS -4
.B
Note:
.RE
The fact that compiled match_specs has no external representation is for performance reasons\&. It may be subject to change in future releases, while this interface will still remain for backward compatibility reasons\&.

.RE
.LP
.nf

.B
last(Tab) -> Key | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Key = term()
.br
.RE
.RE
.RS
.LP
Returns the last key \fIKey\fR\& according to Erlang term order in the table \fITab\fR\& of the \fIordered_set\fR\& type\&. If the table is of any other type, the function is synonymous to \fIfirst/2\fR\&\&. If the table is empty, \fI\&'$end_of_table\&'\fR\& is returned\&.
.LP
Use \fIprev/2\fR\& to find preceding keys in the table\&.
.RE
.LP
.nf

.B
lookup(Tab, Key) -> [Object]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Key = term()
.br
Object = tuple()
.br
.RE
.RE
.RS
.LP
Returns a list of all objects with the key \fIKey\fR\& in the table \fITab\fR\&\&.
.LP
In the case of \fIset, bag and duplicate_bag\fR\&, an object is returned only if the given key \fImatches\fR\& the key of the object in the table\&. If the table is an \fIordered_set\fR\& however, an object is returned if the key given \fIcompares equal\fR\& to the key of an object in the table\&. The difference being the same as between \fI=:=\fR\& and \fI==\fR\&\&. As an example, one might insert an object with the \fIinteger()\fR\& \fI1\fR\& as a key in an \fIordered_set\fR\& and get the object returned as a result of doing a \fIlookup/2\fR\& with the \fIfloat()\fR\& \fI1\&.0\fR\& as the key to search for\&.
.LP
If the table is of type \fIset\fR\& or \fIordered_set\fR\&, the function returns either the empty list or a list with one element, as there cannot be more than one object with the same key\&. If the table is of type \fIbag\fR\& or \fIduplicate_bag\fR\&, the function returns a list of arbitrary length\&.
.LP
Note that the time order of object insertions is preserved; the first object inserted with the given key will be first in the resulting list, and so on\&.
.LP
Insert and look-up times in tables of type \fIset\fR\&, \fIbag\fR\& and \fIduplicate_bag\fR\& are constant, regardless of the size of the table\&. For the \fIordered_set\fR\& data-type, time is proportional to the (binary) logarithm of the number of objects\&.
.RE
.LP
.nf

.B
lookup_element(Tab, Key, Pos) -> Elem
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Key = term()
.br
Pos = integer() >= 1
.br
Elem = term() | [term()]
.br
.RE
.RE
.RS
.LP
If the table \fITab\fR\& is of type \fIset\fR\& or \fIordered_set\fR\&, the function returns the \fIPos\fR\&:th element of the object with the key \fIKey\fR\&\&.
.LP
If the table is of type \fIbag\fR\& or \fIduplicate_bag\fR\&, the functions returns a list with the \fIPos\fR\&:th element of every object with the key \fIKey\fR\&\&.
.LP
If no object with the key \fIKey\fR\& exists, the function will exit with reason \fIbadarg\fR\&\&.
.LP
The difference between \fIset\fR\&, \fIbag\fR\& and \fIduplicate_bag\fR\& on one hand, and \fIordered_set\fR\& on the other, regarding the fact that \fIordered_set\fR\&\&'s view keys as equal when they \fIcompare equal\fR\& whereas the other table types only regard them equal when they \fImatch\fR\&, naturally holds for \fIlookup_element\fR\& as well as for \fIlookup\fR\&\&.
.RE
.LP
.nf

.B
match(Tab, Pattern) -> [Match]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Pattern = \fBmatch_pattern()\fR\&
.br
Match = [term()]
.br
.RE
.RE
.RS
.LP
Matches the objects in the table \fITab\fR\& against the pattern \fIPattern\fR\&\&.
.LP
A pattern is a term that may contain:
.RS 2
.TP 2
*
bound parts (Erlang terms),
.LP
.TP 2
*
\fI\&'_\&'\fR\& which matches any Erlang term, and
.LP
.TP 2
*
pattern variables: \fI\&'$N\&'\fR\& where \fIN\fR\&=0,1,\&.\&.\&.
.LP
.RE

.LP
The function returns a list with one element for each matching object, where each element is an ordered list of pattern variable bindings\&. An example:
.LP
.nf

6> ets:match(T, \&'$1\&')\&. % Matches every object in the table
[[{rufsen,dog,7}],[{brunte,horse,5}],[{ludde,dog,5}]]
7> ets:match(T, {\&'_\&',dog,\&'$1\&'})\&.
[[7],[5]]
8> ets:match(T, {\&'_\&',cow,\&'$1\&'})\&.
[]
.fi
.LP
If the key is specified in the pattern, the match is very efficient\&. If the key is not specified, i\&.e\&. if it is a variable or an underscore, the entire table must be searched\&. The search time can be substantial if the table is very large\&.
.LP
On tables of the \fIordered_set\fR\& type, the result is in the same order as in a \fIfirst/next\fR\& traversal\&.
.RE
.LP
.nf

.B
match(Tab, Pattern, Limit) ->
.B
         {[Match], Continuation} | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Pattern = \fBmatch_pattern()\fR\&
.br
Limit = integer() >= 1
.br
Match = [term()]
.br
Continuation = \fBcontinuation()\fR\&
.br
.RE
.RE
.RS
.LP
Works like \fIets:match/2\fR\& but only returns a limited (\fILimit\fR\&) number of matching objects\&. The \fIContinuation\fR\& term can then be used in subsequent calls to \fIets:match/1\fR\& to get the next chunk of matching objects\&. This is a space efficient way to work on objects in a table which is still faster than traversing the table object by object using \fIets:first/1\fR\& and \fIets:next/1\fR\&\&.
.LP
\fI\&'$end_of_table\&'\fR\& is returned if the table is empty\&.
.RE
.LP
.nf

.B
match(Continuation) -> {[Match], Continuation} | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Match = [term()]
.br
Continuation = \fBcontinuation()\fR\&
.br
.RE
.RE
.RS
.LP
Continues a match started with \fIets:match/3\fR\&\&. The next chunk of the size given in the initial \fIets:match/3\fR\& call is returned together with a new \fIContinuation\fR\& that can be used in subsequent calls to this function\&.
.LP
\fI\&'$end_of_table\&'\fR\& is returned when there are no more objects in the table\&.
.RE
.LP
.nf

.B
match_delete(Tab, Pattern) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Pattern = \fBmatch_pattern()\fR\&
.br
.RE
.RE
.RS
.LP
Deletes all objects which match the pattern \fIPattern\fR\& from the table \fITab\fR\&\&. See \fImatch/2\fR\& for a description of patterns\&.
.RE
.LP
.nf

.B
match_object(Tab, Pattern) -> [Object]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Pattern = \fBmatch_pattern()\fR\&
.br
Object = tuple()
.br
.RE
.RE
.RS
.LP
Matches the objects in the table \fITab\fR\& against the pattern \fIPattern\fR\&\&. See \fImatch/2\fR\& for a description of patterns\&. The function returns a list of all objects which match the pattern\&.
.LP
If the key is specified in the pattern, the match is very efficient\&. If the key is not specified, i\&.e\&. if it is a variable or an underscore, the entire table must be searched\&. The search time can be substantial if the table is very large\&.
.LP
On tables of the \fIordered_set\fR\& type, the result is in the same order as in a \fIfirst/next\fR\& traversal\&.
.RE
.LP
.nf

.B
match_object(Tab, Pattern, Limit) ->
.B
                {[Match], Continuation} | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Pattern = \fBmatch_pattern()\fR\&
.br
Limit = integer() >= 1
.br
Match = [term()]
.br
Continuation = \fBcontinuation()\fR\&
.br
.RE
.RE
.RS
.LP
Works like \fIets:match_object/2\fR\& but only returns a limited (\fILimit\fR\&) number of matching objects\&. The \fIContinuation\fR\& term can then be used in subsequent calls to \fIets:match_object/1\fR\& to get the next chunk of matching objects\&. This is a space efficient way to work on objects in a table which is still faster than traversing the table object by object using \fIets:first/1\fR\& and \fIets:next/1\fR\&\&.
.LP
\fI\&'$end_of_table\&'\fR\& is returned if the table is empty\&.
.RE
.LP
.nf

.B
match_object(Continuation) ->
.B
                {[Match], Continuation} | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Match = [term()]
.br
Continuation = \fBcontinuation()\fR\&
.br
.RE
.RE
.RS
.LP
Continues a match started with \fIets:match_object/3\fR\&\&. The next chunk of the size given in the initial \fIets:match_object/3\fR\& call is returned together with a new \fIContinuation\fR\& that can be used in subsequent calls to this function\&.
.LP
\fI\&'$end_of_table\&'\fR\& is returned when there are no more objects in the table\&.
.RE
.LP
.nf

.B
match_spec_compile(MatchSpec) -> CompiledMatchSpec
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MatchSpec = \fBmatch_spec()\fR\&
.br
CompiledMatchSpec = \fBcomp_match_spec()\fR\&
.br
.RE
.RE
.RS
.LP
This function transforms a \fBmatch_spec\fR\& into an internal representation that can be used in subsequent calls to \fIets:match_spec_run/2\fR\&\&. The internal representation is opaque and can not be converted to external term format and then back again without losing its properties (meaning it can not be sent to a process on another node and still remain a valid compiled match_spec, nor can it be stored on disk)\&. The validity of a compiled match_spec can be checked using \fIets:is_compiled_ms/1\fR\&\&.
.LP
If the term \fIMatchSpec\fR\& can not be compiled (does not represent a valid match_spec), a \fIbadarg\fR\& fault is thrown\&.
.LP

.RS -4
.B
Note:
.RE
This function has limited use in normal code, it is used by Dets to perform the \fIdets:select\fR\& operations\&.

.RE
.LP
.nf

.B
match_spec_run(List, CompiledMatchSpec) -> list()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
List = [tuple()]
.br
CompiledMatchSpec = \fBcomp_match_spec()\fR\&
.br
.RE
.RE
.RS
.LP
This function executes the matching specified in a compiled \fBmatch_spec\fR\& on a list of tuples\&. The \fICompiledMatchSpec\fR\& term should be the result of a call to \fIets:match_spec_compile/1\fR\& and is hence the internal representation of the match_spec one wants to use\&.
.LP
The matching will be executed on each element in \fIList\fR\& and the function returns a list containing all results\&. If an element in \fIList\fR\& does not match, nothing is returned for that element\&. The length of the result list is therefore equal or less than the the length of the parameter \fIList\fR\&\&. The two calls in the following example will give the same result (but certainly not the same execution time\&.\&.\&.):
.LP
.nf

Table = ets:new...
MatchSpec = ....
% The following call...
ets:match_spec_run(ets:tab2list(Table),
ets:match_spec_compile(MatchSpec)),
% ...will give the same result as the more common (and more efficient)
ets:select(Table,MatchSpec),
.fi
.LP

.RS -4
.B
Note:
.RE
This function has limited use in normal code, it is used by Dets to perform the \fIdets:select\fR\& operations and by Mnesia during transactions\&.

.RE
.LP
.nf

.B
member(Tab, Key) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Key = term()
.br
.RE
.RE
.RS
.LP
Works like \fIlookup/2\fR\&, but does not return the objects\&. The function returns \fItrue\fR\& if one or more elements in the table has the key \fIKey\fR\&, \fIfalse\fR\& otherwise\&.
.RE
.LP
.nf

.B
new(Name, Options) -> tid() | atom()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = atom()
.br
Options = [Option]
.br
Option = Type
.br
       | Access
.br
       | named_table
.br
       | {keypos, Pos}
.br
       | {heir, Pid :: pid(), HeirData}
.br
       | {heir, none}
.br
       | Tweaks
.br
Type = \fBtype()\fR\&
.br
Access = \fBaccess()\fR\&
.br
Tweaks = {write_concurrency, boolean()}
.br
       | {read_concurrency, boolean()}
.br
       | compressed
.br
Pos = integer() >= 1
.br
HeirData = term()
.br
.RE
.RE
.RS
.LP
Creates a new table and returns a table identifier which can be used in subsequent operations\&. The table identifier can be sent to other processes so that a table can be shared between different processes within a node\&.
.LP
The parameter \fIOptions\fR\& is a list of atoms which specifies table type, access rights, key position and if the table is named or not\&. If one or more options are left out, the default values are used\&. This means that not specifying any options (\fI[]\fR\&) is the same as specifying \fI[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]\fR\&\&.
.RS 2
.TP 2
*
\fIset\fR\& The table is a \fIset\fR\& table - one key, one object, no order among objects\&. This is the default table type\&.
.LP
.TP 2
*
\fIordered_set\fR\& The table is a \fIordered_set\fR\& table - one key, one object, ordered in Erlang term order, which is the order implied by the < and > operators\&. Tables of this type have a somewhat different behavior in some situations than tables of the other types\&. Most notably the \fIordered_set\fR\& tables regard keys as equal when they \fIcompare equal\fR\&, not only when they match\&. This means that to an \fIordered_set\fR\&, the \fIinteger()\fR\& \fI1\fR\& and the \fIfloat()\fR\& \fI1\&.0\fR\& are regarded as equal\&. This also means that the key used to lookup an element not necessarily \fImatches\fR\& the key in the elements returned, if \fIfloat()\fR\&\&'s and \fIinteger()\fR\&\&'s are mixed in keys of a table\&.
.LP
.TP 2
*
\fIbag\fR\& The table is a \fIbag\fR\& table which can have many objects, but only one instance of each object, per key\&.
.LP
.TP 2
*
\fIduplicate_bag\fR\& The table is a \fIduplicate_bag\fR\& table which can have many objects, including multiple copies of the same object, per key\&.
.LP
.TP 2
*
\fIpublic\fR\& Any process may read or write to the table\&.
.LP
.TP 2
*

.RS 2
.LP
\fIprotected\fR\& The owner process can read and write to the table\&. Other processes can only read the table\&. This is the default setting for the access rights\&.
.RE
.LP
.TP 2
*

.RS 2
.LP
\fIprivate\fR\& Only the owner process can read or write to the table\&.
.RE
.LP
.TP 2
*
\fInamed_table\fR\& If this option is present, the name \fIName\fR\& is associated with the table identifier\&. The name can then be used instead of the table identifier in subsequent operations\&.
.LP
.TP 2
*
\fI{keypos,Pos}\fR\& Specfies which element in the stored tuples should be used as key\&. By default, it is the first element, i\&.e\&. \fIPos=1\fR\&\&. However, this is not always appropriate\&. In particular, we do not want the first element to be the key if we want to store Erlang records in a table\&.
.RS 2
.LP
Note that any tuple stored in the table must have at least \fIPos\fR\& number of elements\&.
.RE
.LP
.TP 2
*

.RS 2
.LP
\fI{heir,Pid,HeirData} | {heir,none}\fR\&
.br
Set a process as heir\&. The heir will inherit the table if the owner terminates\&. The message \fI{\&'ETS-TRANSFER\&',tid(),FromPid,HeirData}\fR\& will be sent to the heir when that happens\&. The heir must be a local process\&. Default heir is \fInone\fR\&, which will destroy the table when the owner terminates\&.
.RE
.LP
.TP 2
*

.RS 2
.LP
\fI{write_concurrency,boolean()}\fR\& Performance tuning\&. Default is \fIfalse\fR\&, in which case an operation that mutates (writes to) the table will obtain exclusive access, blocking any concurrent access of the same table until finished\&. If set to \fItrue\fR\&, the table is optimized towards concurrent write access\&. Different objects of the same table can be mutated (and read) by concurrent processes\&. This is achieved to some degree at the expense of memory consumption and the performance of sequential access and concurrent reading\&. The \fIwrite_concurrency\fR\& option can be combined with the \fBread_concurrency\fR\& option\&. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common (see the documentation of the \fBread_concurrency\fR\& option for more information)\&. Note that this option does not change any guarantees about \fBatomicy and isolation\fR\&\&. Functions that makes such promises over several objects (like \fIinsert/2\fR\&) will gain less (or nothing) from this option\&.
.RE
.RS 2
.LP
In current implementation, table type \fIordered_set\fR\& is not affected by this option\&. Also, the memory consumption inflicted by both \fIwrite_concurrency\fR\& and \fIread_concurrency\fR\& is a constant overhead per table\&. This overhead can be especially large when both options are combined\&.
.RE
.LP
.TP 2
*

.RS 2
.LP
\fI{read_concurrency,boolean()}\fR\& Performance tuning\&. Default is \fIfalse\fR\&\&. When set to \fItrue\fR\&, the table is optimized for concurrent read operations\&. When this option is enabled on a runtime system with SMP support, read operations become much cheaper; especially on systems with multiple physical processors\&. However, switching between read and write operations becomes more expensive\&. You typically want to enable this option when concurrent read operations are much more frequent than write operations, or when concurrent reads and writes comes in large read and write bursts (i\&.e\&., lots of reads not interrupted by writes, and lots of writes not interrupted by reads)\&. You typically do \fInot\fR\& want to enable this option when the common access pattern is a few read operations interleaved with a few write operations repeatedly\&. In this case you will get a performance degradation by enabling this option\&. The \fIread_concurrency\fR\& option can be combined with the \fBwrite_concurrency\fR\& option\&. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common\&.
.RE
.LP
.TP 2
*

.RS 2
.LP
\fIcompressed\fR\& If this option is present, the table data will be stored in a more compact format to consume less memory\&. The downside is that it will make table operations slower\&. Especially operations that need to inspect entire objects, such as \fImatch\fR\& and \fIselect\fR\&, will get much slower\&. The key element is not compressed in current implementation\&.
.RE
.LP
.RE

.RE
.LP
.nf

.B
next(Tab, Key1) -> Key2 | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Key1 = Key2 = term()
.br
.RE
.RE
.RS
.LP
Returns the next key \fIKey2\fR\&, following the key \fIKey1\fR\& in the table \fITab\fR\&\&. If the table is of the \fIordered_set\fR\& type, the next key in Erlang term order is returned\&. If the table is of any other type, the next key according to the table\&'s internal order is returned\&. If there is no next key, \fI\&'$end_of_table\&'\fR\& is returned\&.
.LP
Use \fIfirst/1\fR\& to find the first key in the table\&.
.LP
Unless a table of type \fIset\fR\&, \fIbag\fR\& or \fIduplicate_bag\fR\& is protected using \fIsafe_fixtable/2\fR\&, see below, a traversal may fail if concurrent updates are made to the table\&. If the table is of type \fIordered_set\fR\&, the function returns the next key in order, even if the object does no longer exist\&.
.RE
.LP
.nf

.B
prev(Tab, Key1) -> Key2 | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Key1 = Key2 = term()
.br
.RE
.RE
.RS
.LP
Returns the previous key \fIKey2\fR\&, preceding the key \fIKey1\fR\& according the Erlang term order in the table \fITab\fR\& of the \fIordered_set\fR\& type\&. If the table is of any other type, the function is synonymous to \fInext/2\fR\&\&. If there is no previous key, \fI\&'$end_of_table\&'\fR\& is returned\&.
.LP
Use \fIlast/1\fR\& to find the last key in the table\&.
.RE
.LP
.nf

.B
rename(Tab, Name) -> Name
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Name = atom()
.br
.RE
.RE
.RS
.LP
Renames the named table \fITab\fR\& to the new name \fIName\fR\&\&. Afterwards, the old name can not be used to access the table\&. Renaming an unnamed table has no effect\&.
.RE
.LP
.nf

.B
repair_continuation(Continuation, MatchSpec) -> Continuation
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Continuation = \fBcontinuation()\fR\&
.br
MatchSpec = \fBmatch_spec()\fR\&
.br
.RE
.RE
.RS
.LP
This function can be used to restore an opaque continuation returned by \fIets:select/3\fR\& or \fIets:select/1\fR\& if the continuation has passed through external term format (been sent between nodes or stored on disk)\&.
.LP
The reason for this function is that continuation terms contain compiled match_specs and therefore will be invalidated if converted to external term format\&. Given that the original match_spec is kept intact, the continuation can be restored, meaning it can once again be used in subsequent \fIets:select/1\fR\& calls even though it has been stored on disk or on another node\&.
.LP
As an example, the following sequence of calls will fail:
.LP
.nf

T=ets:new(x,[]),
...
{_,C} = ets:select(T,ets:fun2ms(fun({N,_}=A)
when (N rem 10) =:= 0 ->
A
end),10),
Broken = binary_to_term(term_to_binary(C)),
ets:select(Broken).
.fi
.LP
\&.\&.\&.while the following sequence will work:
.LP
.nf

T=ets:new(x,[]),
...
MS = ets:fun2ms(fun({N,_}=A)
when (N rem 10) =:= 0 ->
A
end),
{_,C} = ets:select(T,MS,10),
Broken = binary_to_term(term_to_binary(C)),
ets:select(ets:repair_continuation(Broken,MS)).
.fi
.LP
\&.\&.\&.as the call to \fIets:repair_continuation/2\fR\& will reestablish the (deliberately) invalidated continuation \fIBroken\fR\&\&.
.LP

.RS -4
.B
Note:
.RE
This function is very rarely needed in application code\&. It is used by Mnesia to implement distributed \fIselect/3\fR\& and \fIselect/1\fR\& sequences\&. A normal application would either use Mnesia or keep the continuation from being converted to external format\&.
.LP
The reason for not having an external representation of a compiled match_spec is performance\&. It may be subject to change in future releases, while this interface will remain for backward compatibility\&.

.RE
.LP
.nf

.B
safe_fixtable(Tab, Fix) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Fix = boolean()
.br
.RE
.RE
.RS
.LP
Fixes a table of the \fIset\fR\&, \fIbag\fR\& or \fIduplicate_bag\fR\& table type for safe traversal\&.
.LP
A process fixes a table by calling \fIsafe_fixtable(Tab, true)\fR\&\&. The table remains fixed until the process releases it by calling \fIsafe_fixtable(Tab, false)\fR\&, or until the process terminates\&.
.LP
If several processes fix a table, the table will remain fixed until all processes have released it (or terminated)\&. A reference counter is kept on a per process basis, and N consecutive fixes requires N releases to actually release the table\&.
.LP
When a table is fixed, a sequence of \fIfirst/1\fR\& and \fInext/2\fR\& calls are guaranteed to succeed and each object in the table will only be returned once, even if objects are removed or inserted during the traversal\&. The keys for new objects inserted during the traversal \fImay\fR\& be returned by \fBnext/2\fR\& (it depends on the internal ordering of the keys)\&. An example:
.LP
.nf

clean_all_with_value(Tab,X) ->
    safe_fixtable(Tab,true),
    clean_all_with_value(Tab,X,ets:first(Tab)),
    safe_fixtable(Tab,false).

clean_all_with_value(Tab,X,'$end_of_table') ->
    true;
clean_all_with_value(Tab,X,Key) ->
    case ets:lookup(Tab,Key) of
        [{Key,X}] ->
            ets:delete(Tab,Key);
        _ ->
            true
    end,
    clean_all_with_value(Tab,X,ets:next(Tab,Key)).
.fi
.LP
Note that no deleted objects are actually removed from a fixed table until it has been released\&. If a process fixes a table but never releases it, the memory used by the deleted objects will never be freed\&. The performance of operations on the table will also degrade significantly\&.
.LP
Use \fIinfo/2\fR\& to retrieve information about which processes have fixed which tables\&. A system with a lot of processes fixing tables may need a monitor which sends alarms when tables have been fixed for too long\&.
.LP
Note that for tables of the \fIordered_set\fR\& type, \fIsafe_fixtable/2\fR\& is not necessary as calls to \fIfirst/1\fR\& and \fInext/2\fR\& will always succeed\&.
.RE
.LP
.nf

.B
select(Tab, MatchSpec) -> [Match]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
MatchSpec = \fBmatch_spec()\fR\&
.br
Match = term()
.br
.RE
.RE
.RS
.LP
Matches the objects in the table \fITab\fR\& using a \fBmatch_spec\fR\&\&. This is a more general call than the \fIets:match/2\fR\& and \fIets:match_object/2\fR\& calls\&. In its simplest forms the match_specs look like this:
.RS 2
.TP 2
*
MatchSpec = [MatchFunction]
.LP
.TP 2
*
MatchFunction = {MatchHead, [Guard], [Result]}
.LP
.TP 2
*
MatchHead = "Pattern as in ets:match"
.LP
.TP 2
*
Guard = {"Guardtest name", \&.\&.\&.}
.LP
.TP 2
*
Result = "Term construct"
.LP
.RE

.LP
This means that the match_spec is always a list of one or more tuples (of arity 3)\&. The tuples first element should be a pattern as described in the documentation of \fIets:match/2\fR\&\&. The second element of the tuple should be a list of 0 or more guard tests (described below)\&. The third element of the tuple should be a list containing a description of the value to actually return\&. In almost all normal cases the list contains exactly one term which fully describes the value to return for each object\&.
.LP
The return value is constructed using the "match variables" bound in the MatchHead or using the special match variables \fI\&'$_\&'\fR\& (the whole matching object) and \fI\&'$$\&'\fR\& (all match variables in a list), so that the following \fIets:match/2\fR\& expression:
.LP
.nf

ets:match(Tab,{'$1','$2','$3'})
.fi
.LP
is exactly equivalent to:
.LP
.nf

ets:select(Tab,[{{'$1','$2','$3'},[],['$$']}])
.fi
.LP
- and the following \fIets:match_object/2\fR\& call:
.LP
.nf

ets:match_object(Tab,{'$1','$2','$1'})
.fi
.LP
is exactly equivalent to
.LP
.nf

ets:select(Tab,[{{'$1','$2','$1'},[],['$_']}])
.fi
.LP
Composite terms can be constructed in the \fIResult\fR\& part either by simply writing a list, so that this code:
.LP
.nf

ets:select(Tab,[{{'$1','$2','$3'},[],['$$']}])
.fi
.LP
gives the same output as:
.LP
.nf

ets:select(Tab,[{{'$1','$2','$3'},[],[['$1','$2','$3']]}])
.fi
.LP
i\&.e\&. all the bound variables in the match head as a list\&. If tuples are to be constructed, one has to write a tuple of arity 1 with the single element in the tuple being the tuple one wants to construct (as an ordinary tuple could be mistaken for a \fIGuard\fR\&)\&. Therefore the following call:
.LP
.nf

ets:select(Tab,[{{'$1','$2','$1'},[],['$_']}])
.fi
.LP
gives the same output as:
.LP
.nf

ets:select(Tab,[{{'$1','$2','$1'},[],[{{'$1','$2','$3'}}]}])
.fi
.LP
- this syntax is equivalent to the syntax used in the trace patterns (see \fBdbg(3)\fR\&)\&.
.LP
The \fIGuard\fR\&s are constructed as tuples where the first element is the name of the test and the rest of the elements are the parameters of the test\&. To check for a specific type (say a list) of the element bound to the match variable \fI\&'$1\&'\fR\&, one would write the test as \fI{is_list, \&'$1\&'}\fR\&\&. If the test fails, the object in the table will not match and the next \fIMatchFunction\fR\& (if any) will be tried\&. Most guard tests present in Erlang can be used, but only the new versions prefixed \fIis_\fR\& are allowed (like \fIis_float\fR\&, \fIis_atom\fR\& etc)\&.
.LP
The \fIGuard\fR\& section can also contain logic and arithmetic operations, which are written with the same syntax as the guard tests (prefix notation), so that a guard test written in Erlang looking like this:
.LP
.nf

is_integer(X), is_integer(Y), X + Y < 4711
.fi
.LP
is expressed like this (X replaced with \&'$1\&' and Y with \&'$2\&'):
.LP
.nf

[{is_integer, '$1'}, {is_integer, '$2'}, {'<', {'+', '$1', '$2'}, 4711}]
.fi
.LP
On tables of the \fIordered_set\fR\& type, objects are visited in the same order as in a \fIfirst/next\fR\& traversal\&. This means that the match specification will be executed against objects with keys in the \fIfirst/next\fR\& order and the corresponding result list will be in the order of that execution\&.
.RE
.LP
.nf

.B
select(Tab, MatchSpec, Limit) ->
.B
          {[Match], Continuation} | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
MatchSpec = \fBmatch_spec()\fR\&
.br
Limit = integer() >= 1
.br
Match = term()
.br
Continuation = \fBcontinuation()\fR\&
.br
.RE
.RE
.RS
.LP
Works like \fIets:select/2\fR\& but only returns a limited (\fILimit\fR\&) number of matching objects\&. The \fIContinuation\fR\& term can then be used in subsequent calls to \fIets:select/1\fR\& to get the next chunk of matching objects\&. This is a space efficient way to work on objects in a table which is still faster than traversing the table object by object using \fIets:first/1\fR\& and \fIets:next/1\fR\&\&.
.LP
\fI\&'$end_of_table\&'\fR\& is returned if the table is empty\&.
.RE
.LP
.nf

.B
select(Continuation) -> {[Match], Continuation} | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Match = term()
.br
Continuation = \fBcontinuation()\fR\&
.br
.RE
.RE
.RS
.LP
Continues a match started with \fIets:select/3\fR\&\&. The next chunk of the size given in the initial \fIets:select/3\fR\& call is returned together with a new \fIContinuation\fR\& that can be used in subsequent calls to this function\&.
.LP
\fI\&'$end_of_table\&'\fR\& is returned when there are no more objects in the table\&.
.RE
.LP
.nf

.B
select_count(Tab, MatchSpec) -> NumMatched
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
MatchSpec = \fBmatch_spec()\fR\&
.br
NumMatched = integer() >= 0
.br
.RE
.RE
.RS
.LP
Matches the objects in the table \fITab\fR\& using a \fBmatch_spec\fR\&\&. If the match_spec returns \fItrue\fR\& for an object, that object considered a match and is counted\&. For any other result from the match_spec the object is not considered a match and is therefore not counted\&.
.LP
The function could be described as a \fImatch_delete/2\fR\& that does not actually delete any elements, but only counts them\&.
.LP
The function returns the number of objects matched\&.
.RE
.LP
.nf

.B
select_delete(Tab, MatchSpec) -> NumDeleted
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
MatchSpec = \fBmatch_spec()\fR\&
.br
NumDeleted = integer() >= 0
.br
.RE
.RE
.RS
.LP
Matches the objects in the table \fITab\fR\& using a \fBmatch_spec\fR\&\&. If the match_spec returns \fItrue\fR\& for an object, that object is removed from the table\&. For any other result from the match_spec the object is retained\&. This is a more general call than the \fIets:match_delete/2\fR\& call\&.
.LP
The function returns the number of objects actually deleted from the table\&.
.LP

.RS -4
.B
Note:
.RE
The \fImatch_spec\fR\& has to return the atom \fItrue\fR\& if the object is to be deleted\&. No other return value will get the object deleted, why one can not use the same match specification for looking up elements as for deleting them\&.

.RE
.LP
.nf

.B
select_reverse(Tab, MatchSpec) -> [Match]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
MatchSpec = \fBmatch_spec()\fR\&
.br
Match = term()
.br
.RE
.RE
.RS
.LP
Works like \fIselect/2\fR\&, but returns the list in reverse order for the \fIordered_set\fR\& table type\&. For all other table types, the return value is identical to that of \fIselect/2\fR\&\&.
.RE
.LP
.nf

.B
select_reverse(Tab, MatchSpec, Limit) ->
.B
                  {[Match], Continuation} | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
MatchSpec = \fBmatch_spec()\fR\&
.br
Limit = integer() >= 1
.br
Match = term()
.br
Continuation = \fBcontinuation()\fR\&
.br
.RE
.RE
.RS
.LP
Works like \fIselect/3\fR\&, but for the \fIordered_set\fR\& table type, traversing is done starting at the last object in Erlang term order and moves towards the first\&. For all other table types, the return value is identical to that of \fIselect/3\fR\&\&.
.LP
Note that this is \fInot\fR\& equivalent to reversing the result list of a \fIselect/3\fR\& call, as the result list is not only reversed, but also contains the last \fILimit\fR\& matching objects in the table, not the first\&.
.RE
.LP
.nf

.B
select_reverse(Continuation) ->
.B
                  {[Match], Continuation} | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Continuation = \fBcontinuation()\fR\&
.br
Match = term()
.br
.RE
.RE
.RS
.LP
Continues a match started with \fIets:select_reverse/3\fR\&\&. If the table is an \fIordered_set\fR\&, the traversal of the table will continue towards objects with keys earlier in the Erlang term order\&. The returned list will also contain objects with keys in reverse order\&.
.LP
For all other table types, the behaviour is exactly that of \fIselect/1\fR\&\&.
.LP
Example:
.LP
.nf

1> T = ets:new(x,[ordered_set]).
2> [ ets:insert(T,{N}) || N <- lists:seq(1,10) ].
...
3> {R0,C0} = ets:select_reverse(T,[{'_',[],['$_']}],4).
...
4> R0.
[{10},{9},{8},{7}]
5> {R1,C1} = ets:select_reverse(C0).
...
6> R1.
[{6},{5},{4},{3}]
7> {R2,C2} = ets:select_reverse(C1).
...
8> R2.
[{2},{1}]
9> '$end_of_table' = ets:select_reverse(C2).
...
      
.fi
.RE
.LP
.nf

.B
setopts(Tab, Opts) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Opts = Opt | [Opt]
.br
Opt = {heir, pid(), HeirData} | {heir, none}
.br
HeirData = term()
.br
.RE
.RE
.RS
.LP
Set table options\&. The only option that currently is allowed to be set after the table has been created is \fBheir\fR\&\&. The calling process must be the table owner\&.
.RE
.LP
.nf

.B
slot(Tab, I) -> [Object] | \&'$end_of_table\&'
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
I = integer() >= 0
.br
Object = tuple()
.br
.RE
.RE
.RS
.LP
This function is mostly for debugging purposes, Normally one should use \fIfirst/next\fR\& or \fIlast/prev\fR\& instead\&.
.LP
Returns all objects in the \fII\fR\&:th slot of the table \fITab\fR\&\&. A table can be traversed by repeatedly calling the function, starting with the first slot \fII=0\fR\& and ending when \fI\&'$end_of_table\&'\fR\& is returned\&. The function will fail with reason \fIbadarg\fR\& if the \fII\fR\& argument is out of range\&.
.LP
Unless a table of type \fIset\fR\&, \fIbag\fR\& or \fIduplicate_bag\fR\& is protected using \fIsafe_fixtable/2\fR\&, see above, a traversal may fail if concurrent updates are made to the table\&. If the table is of type \fIordered_set\fR\&, the function returns a list containing the \fII\fR\&:th object in Erlang term order\&.
.RE
.LP
.nf

.B
tab2file(Tab, Filename) -> ok | {error, Reason}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Filename = \fBfile:name()\fR\&
.br
Reason = term()
.br
.RE
.RE
.RS
.LP
Dumps the table \fITab\fR\& to the file \fIFilename\fR\&\&.
.LP
Equivalent to \fItab2file(Tab, Filename,[])\fR\&
.RE
.LP
.nf

.B
tab2file(Tab, Filename, Options) -> ok | {error, Reason}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Filename = \fBfile:name()\fR\&
.br
Options = [Option]
.br
Option = {extended_info, [ExtInfo]}
.br
ExtInfo = md5sum | object_count
.br
Reason = term()
.br
.RE
.RE
.RS
.LP
Dumps the table \fITab\fR\& to the file \fIFilename\fR\&\&.
.LP
When dumping the table, certain information about the table is dumped to a header at the beginning of the dump\&. This information contains data about the table type, name, protection, size, version and if it\&'s a named table\&. It also contains notes about what extended information is added to the file, which can be a count of the objects in the file or a MD5 sum of the header and records in the file\&.
.LP
The size field in the header might not correspond to the actual number of records in the file if the table is public and records are added or removed from the table during dumping\&. Public tables updated during dump, and that one wants to verify when reading, needs at least one field of extended information for the read verification process to be reliable later\&.
.LP
The \fIextended_info\fR\& option specifies what extra information is written to the table dump:
.RS 2
.TP 2
.B
\fIobject_count\fR\&:
The number of objects actually written to the file is noted in the file footer, why verification of file truncation is possible even if the file was updated during dump\&.
.TP 2
.B
\fImd5sum\fR\&:
The header and objects in the file are checksummed using the built in MD5 functions\&. The MD5 sum of all objects is written in the file footer, so that verification while reading will detect the slightest bitflip in the file data\&. Using this costs a fair amount of CPU time\&.
.RE
.LP
Whenever the \fIextended_info\fR\& option is used, it results in a file not readable by versions of ets prior to that in stdlib-1\&.15\&.1
.RE
.LP
.nf

.B
tab2list(Tab) -> [Object]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Object = tuple()
.br
.RE
.RE
.RS
.LP
Returns a list of all objects in the table \fITab\fR\&\&.
.RE
.LP
.nf

.B
tabfile_info(Filename) -> {ok, TableInfo} | {error, Reason}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Filename = \fBfile:name()\fR\&
.br
TableInfo = [InfoItem]
.br
InfoItem = {name, atom()}
.br
         | {type, Type}
.br
         | {protection, Protection}
.br
         | {named_table, boolean()}
.br
         | {keypos, integer() >= 0}
.br
         | {size, integer() >= 0}
.br
         | {extended_info, [ExtInfo]}
.br
         | {version,
.br
            {Major :: integer() >= 0,
.br
             Minor :: integer() >= 0}}
.br
ExtInfo = md5sum | object_count
.br
Type = bag | duplicate_bag | ordered_set | set
.br
Protection = private | protected | public
.br
Reason = term()
.br
.RE
.RE
.RS
.LP
Returns information about the table dumped to file by \fBtab2file/2\fR\& or \fBtab2file/3\fR\&
.LP
The following items are returned:
.RS 2
.TP 2
.B
name:
The name of the dumped table\&. If the table was a named table, a table with the same name cannot exist when the table is loaded from file with \fBfile2tab/2\fR\&\&. If the table is not saved as a named table, this field has no significance at all when loading the table from file\&.
.TP 2
.B
type:
The ets type of the dumped table (i\&.e\&. \fIset\fR\&, \fIbag\fR\&, \fIduplicate_bag\fR\& or \fIordered_set\fR\&)\&. This type will be used when loading the table again\&.
.TP 2
.B
protection:
The protection of the dumped table (i\&.e\&. \fIprivate\fR\&, \fIprotected\fR\& or \fIpublic\fR\&)\&. A table loaded from the file will get the same protection\&.
.TP 2
.B
named_table:
\fItrue\fR\& if the table was a named table when dumped to file, otherwise \fIfalse\fR\&\&. Note that when a named table is loaded from a file, there cannot exist a table in the system with the same name\&.
.TP 2
.B
keypos:
The \fIkeypos\fR\& of the table dumped to file, which will be used when loading the table again\&.
.TP 2
.B
size:
The number of objects in the table when the table dump to file started, which in case of a \fIpublic\fR\& table need not correspond to the number of objects actually saved to the file, as objects might have been added or deleted by another process during table dump\&.
.TP 2
.B
extended_info:
The extended information written in the file footer to allow stronger verification during table loading from file, as specified to \fBtab2file/3\fR\&\&. Note that this function only tells \fIwhich\fR\& information is present, not the values in the file footer\&. The value is a list containing one or more of the atoms \fIobject_count\fR\& and \fImd5sum\fR\&\&.
.TP 2
.B
version:
A tuple \fI{Major,Minor}\fR\& containing the major and minor version of the file format for ets table dumps\&. This version field was added beginning with stdlib-1\&.5\&.1, files dumped with older versions will return \fI{0,0}\fR\& in this field\&.
.RE
.LP
An error is returned if the file is inaccessible, badly damaged or not an file produced with \fBtab2file/2\fR\& or \fBtab2file/3\fR\&\&.
.RE
.LP
.nf

.B
table(Tab) -> QueryHandle
.br
.fi
.br
.nf

.B
table(Tab, Options) -> QueryHandle
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
QueryHandle = \fBqlc:query_handle()\fR\&
.br
Options = [Option] | Option
.br
Option = {n_objects, NObjects} | {traverse, TraverseMethod}
.br
NObjects = default | integer() >= 1
.br
TraverseMethod = first_next
.br
               | last_prev
.br
               | select
.br
               | {select, MatchSpec :: \fBmatch_spec()\fR\&}
.br
.RE
.RE
.RS
.LP
Returns a QLC (Query List Comprehension) query handle\&. The module \fIqlc\fR\& implements a query language aimed mainly at Mnesia but ETS tables, Dets tables, and lists are also recognized by QLC as sources of data\&. Calling \fIets:table/1,2\fR\& is the means to make the ETS table \fITab\fR\& usable to QLC\&.
.LP
When there are only simple restrictions on the key position QLC uses \fIets:lookup/2\fR\& to look up the keys, but when that is not possible the whole table is traversed\&. The option \fItraverse\fR\& determines how this is done:
.RS 2
.TP 2
*
\fIfirst_next\fR\&\&. The table is traversed one key at a time by calling \fIets:first/1\fR\& and \fIets:next/2\fR\&\&.
.LP
.TP 2
*
\fIlast_prev\fR\&\&. The table is traversed one key at a time by calling \fIets:last/1\fR\& and \fIets:prev/2\fR\&\&.
.LP
.TP 2
*
\fIselect\fR\&\&. The table is traversed by calling \fIets:select/3\fR\& and \fIets:select/1\fR\&\&. The option \fIn_objects\fR\& determines the number of objects returned (the third argument of \fIselect/3\fR\&); the default is to return \fI100\fR\& objects at a time\&. The \fBmatch_spec\fR\& (the second argument of \fIselect/3\fR\&) is assembled by QLC: simple filters are translated into equivalent match_specs while more complicated filters have to be applied to all objects returned by \fIselect/3\fR\& given a match_spec that matches all objects\&.
.LP
.TP 2
*
\fI{select, MatchSpec}\fR\&\&. As for \fIselect\fR\& the table is traversed by calling \fIets:select/3\fR\& and \fIets:select/1\fR\&\&. The difference is that the match_spec is explicitly given\&. This is how to state match_specs that cannot easily be expressed within the syntax provided by QLC\&.
.LP
.RE

.LP
The following example uses an explicit match_spec to traverse the table:
.LP
.nf

9> true = ets:insert(Tab = ets:new(t, []), [{1,a},{2,b},{3,c},{4,d}]),
MS = ets:fun2ms(fun({X,Y}) when (X > 1) or (X < 5) -> {Y} end),
QH1 = ets:table(Tab, [{traverse, {select, MS}}])\&.
.fi
.LP
An example with implicit match_spec:
.LP
.nf

10> QH2 = qlc:q([{Y} || {X,Y} <- ets:table(Tab), (X > 1) or (X < 5)])\&.
.fi
.LP
The latter example is in fact equivalent to the former which can be verified using the function \fIqlc:info/1\fR\&:
.LP
.nf

11> qlc:info(QH1) =:= qlc:info(QH2)\&.
true
.fi
.LP
\fIqlc:info/1\fR\& returns information about a query handle, and in this case identical information is returned for the two query handles\&.
.RE
.LP
.nf

.B
test_ms(Tuple, MatchSpec) -> {ok, Result} | {error, Errors}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tuple = tuple()
.br
MatchSpec = \fBmatch_spec()\fR\&
.br
Result = term()
.br
Errors = [{warning | error, string()}]
.br
.RE
.RE
.RS
.LP
This function is a utility to test a \fBmatch_spec\fR\& used in calls to \fIets:select/2\fR\&\&. The function both tests \fIMatchSpec\fR\& for "syntactic" correctness and runs the match_spec against the object \fITuple\fR\&\&. If the match_spec contains errors, the tuple \fI{error, Errors}\fR\& is returned where \fIErrors\fR\& is a list of natural language descriptions of what was wrong with the match_spec\&. If the match_spec is syntactically OK, the function returns \fI{ok,Result}\fR\& where \fIResult\fR\& is what would have been the result in a real \fIets:select/2\fR\& call or \fIfalse\fR\& if the match_spec does not match the object \fITuple\fR\&\&.
.LP
This is a useful debugging and test tool, especially when writing complicated \fIets:select/2\fR\& calls\&.
.RE
.LP
.nf

.B
to_dets(Tab, DetsTab) -> DetsTab
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
DetsTab = \fBdets:tab_name()\fR\&
.br
.RE
.RE
.RS
.LP
Fills an already created/opened Dets table with the objects in the already opened ETS table named \fITab\fR\&\&. The Dets table is emptied before the objects are inserted\&.
.RE
.LP
.nf

.B
update_counter(Tab, Key, UpdateOp) -> Result
.br
.fi
.br
.nf

.B
update_counter(Tab, Key, UpdateOp :: [UpdateOp]) -> [Result]
.br
.fi
.br
.nf

.B
update_counter(Tab, Key, Incr) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Key = term()
.br
UpdateOp = {Pos, Incr} | {Pos, Incr, Threshold, SetValue}
.br
Pos = Incr = Threshold = SetValue = Result = integer()
.br
.RE
.RE
.RS
.LP
This function provides an efficient way to update one or more counters, without the hassle of having to look up an object, update the object by incrementing an element and insert the resulting object into the table again\&. (The update is done atomically; i\&.e\&. no process can access the ets table in the middle of the operation\&.)
.LP
It will destructively update the object with key \fIKey\fR\& in the table \fITab\fR\& by adding \fIIncr\fR\& to the element at the \fIPos\fR\&:th position\&. The new counter value is returned\&. If no position is specified, the element directly following the key (\fI<keypos>+1\fR\&) is updated\&.
.LP
If a \fIThreshold\fR\& is specified, the counter will be reset to the value \fISetValue\fR\& if the following conditions occur:
.RS 2
.TP 2
*
The \fIIncr\fR\& is not negative (\fI>= 0\fR\&) and the result would be greater than (\fI>\fR\&) \fIThreshold\fR\&
.LP
.TP 2
*
The \fIIncr\fR\& is negative (\fI< 0\fR\&) and the result would be less than (\fI<\fR\&) \fIThreshold\fR\&
.LP
.RE

.LP
A list of \fIUpdateOp\fR\& can be supplied to do several update operations within the object\&. The operations are carried out in the order specified in the list\&. If the same counter position occurs more than one time in the list, the corresponding counter will thus be updated several times, each time based on the previous result\&. The return value is a list of the new counter values from each update operation in the same order as in the operation list\&. If an empty list is specified, nothing is updated and an empty list is returned\&. If the function should fail, no updates will be done at all\&.
.LP
The given \fIKey\fR\& is used to identify the object by either \fImatching\fR\& the key of an object in a \fIset\fR\& table, or \fIcompare equal\fR\& to the key of an object in an \fIordered_set\fR\& table (see \fBlookup/2\fR\& and \fBnew/2\fR\& for details on the difference)\&.
.LP
The function will fail with reason \fIbadarg\fR\& if:
.RS 2
.TP 2
*
the table is not of type \fIset\fR\& or \fIordered_set\fR\&,
.LP
.TP 2
*
no object with the right key exists,
.LP
.TP 2
*
the object has the wrong arity,
.LP
.TP 2
*
the element to update is not an integer,
.LP
.TP 2
*
the element to update is also the key, or,
.LP
.TP 2
*
any of \fIPos\fR\&, \fIIncr\fR\&, \fIThreshold\fR\& or \fISetValue\fR\& is not an integer
.LP
.RE

.RE
.LP
.nf

.B
update_element(Tab, Key, ElementSpec :: {Pos, Value}) -> boolean()
.br
.fi
.br
.nf

.B
update_element(Tab, Key, ElementSpec :: [{Pos, Value}]) ->
.B
                  boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tab = \fBtab()\fR\&
.br
Key = term()
.br
Value = term()
.br
Pos = integer() >= 1
.br
.RE
.RE
.RS
.LP
This function provides an efficient way to update one or more elements within an object, without the hassle of having to look up, update and write back the entire object\&.
.LP
It will destructively update the object with key \fIKey\fR\& in the table \fITab\fR\&\&. The element at the \fIPos\fR\&:th position will be given the value \fIValue\fR\&\&.
.LP
A list of \fI{Pos,Value}\fR\& can be supplied to update several elements within the same object\&. If the same position occurs more than one in the list, the last value in the list will be written\&. If the list is empty or the function fails, no updates will be done at all\&. The function is also atomic in the sense that other processes can never see any intermediate results\&.
.LP
The function returns \fItrue\fR\& if an object with the key \fIKey\fR\& was found, \fIfalse\fR\& otherwise\&.
.LP
The given \fIKey\fR\& is used to identify the object by either \fImatching\fR\& the key of an object in a \fIset\fR\& table, or \fIcompare equal\fR\& to the key of an object in an \fIordered_set\fR\& table (see \fBlookup/2\fR\& and \fBnew/2\fR\& for details on the difference)\&.
.LP
The function will fail with reason \fIbadarg\fR\& if:
.RS 2
.TP 2
*
the table is not of type \fIset\fR\& or \fIordered_set\fR\&,
.LP
.TP 2
*
\fIPos\fR\& is less than 1 or greater than the object arity, or,
.LP
.TP 2
*
the element to update is also the key
.LP
.RE

.RE