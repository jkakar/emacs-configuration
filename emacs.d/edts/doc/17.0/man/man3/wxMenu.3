.TH wxMenu 3 "wx 1.2" "" "Erlang Module Definition"
.SH NAME
wxMenu \- See external documentation: wxMenu.
.SH DESCRIPTION
.LP
See external documentation: wxMenu\&.
.LP
This class is derived (and can use functions) from: 
.br
\fBwxEvtHandler\fR\& 
.SH "DATA TYPES"

.RS 2
.TP 2
.B
\fIwxMenu()\fR\&:

.RS 2
.LP
An object reference, The representation is internal and can be changed without notice\&. It can\&'t be used for comparsion stored on disc or distributed for use on other nodes\&.
.RE
.RE
.SH EXPORTS
.LP
.B
new() -> wxMenu()
.br
.RS
.LP
Equivalent to \fBnew([])\fR\&\&.
.RE
.LP
.B
new(Option::[Option]) -> wxMenu()
.br
.RS
.LP
Types:

.RS 3
Option = {style, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
new(Title, Option::[Option]) -> wxMenu()
.br
.RS
.LP
Types:

.RS 3
Title = chardata() (see module unicode)
.br
Option = {style, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
append(This, Item) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Item = wxMenuItem() (see module wxMenuItem)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
append(This, Itemid, Text) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBappend(This, Itemid, Text, [])\fR\&\&.
.RE
.LP
.B
append(This, Itemid, Text, Submenu) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Submenu = wxMenu()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
append(This, Itemid, Text, [Option]) -> wxMenuItem:wxMenuItem() when
.br
This::wxMenu(), Itemid::integer(), Text::unicode:chardata(),
.br
Option :: {help, unicode:chardata()}
.br
| {kind, wx:wx_enum()}\&.
.br

.LP

.br
Kind = ?wxITEM_SEPARATOR | ?wxITEM_NORMAL | ?wxITEM_CHECK | ?wxITEM_RADIO | ?wxITEM_MAX
.RE
.LP
.B
append(This, Itemid, Text, Help, IsCheckable) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Help = chardata() (see module unicode)
.br
IsCheckable = boolean()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
append(This, Itemid, Text, Submenu, [Option]) -> wxMenuItem:wxMenuItem() when
.br
This::wxMenu(), Itemid::integer(), Text::unicode:chardata(), Submenu::wxMenu(),
.br
Option :: {help, unicode:chardata()}\&.
.br

.RE
.LP
.B
appendCheckItem(This, Itemid, Text) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBappendCheckItem(This, Itemid, Text, [])\fR\&\&.
.RE
.LP
.B
appendCheckItem(This, Itemid, Text, Option::[Option]) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Option = {help, chardata() (see module unicode)}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
appendRadioItem(This, Itemid, Text) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBappendRadioItem(This, Itemid, Text, [])\fR\&\&.
.RE
.LP
.B
appendRadioItem(This, Itemid, Text, Option::[Option]) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Option = {help, chardata() (see module unicode)}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
appendSeparator(This) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
break(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
check(This, Itemid, Check) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Check = boolean()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
delete(This, Itemid) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
delete(This, Item) -> boolean() when
.br
This::wxMenu(), Item::wxMenuItem:wxMenuItem()\&.
.br

.RE
.LP
.B
Destroy(This, Itemid) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
\&'Destroy\&'(This, Item) -> boolean() when
.br
This::wxMenu(), Item::wxMenuItem:wxMenuItem()\&.
.br

.RE
.LP
.B
enable(This, Itemid, Enable) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Enable = boolean()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
findItem(This, Itemid) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
findItem(This, Item) -> integer() when
.br
This::wxMenu(), Item::unicode:chardata()\&.
.br

.RE
.LP
.B
findItemByPosition(This, Position) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Position = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getHelpString(This, Itemid) -> charlist() (see module unicode)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getLabel(This, Itemid) -> charlist() (see module unicode)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getMenuItemCount(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getMenuItems(This) -> [wxMenuItem() (see module wxMenuItem)]
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getTitle(This) -> charlist() (see module unicode)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
insert(This, Pos, Itemid) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Pos = integer()
.br
Itemid = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
insert(This, Pos, Item) -> wxMenuItem:wxMenuItem() when
.br
This::wxMenu(), Pos::integer(), Item::wxMenuItem:wxMenuItem()\&.
.br

.LP

.br
Kind = ?wxITEM_SEPARATOR | ?wxITEM_NORMAL | ?wxITEM_CHECK | ?wxITEM_RADIO | ?wxITEM_MAX
.RE
.LP
.B
insert(This, Pos, Itemid, Option::[Option]) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Pos = integer()
.br
Itemid = integer()
.br
Option = {text, chardata() (see module unicode)} | {help, chardata() (see module unicode)} | {kind, wx_enum() (see module wx)}
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Kind = ?wxITEM_SEPARATOR | ?wxITEM_NORMAL | ?wxITEM_CHECK | ?wxITEM_RADIO | ?wxITEM_MAX
.RE
.LP
.B
insert(This, Pos, Itemid, Text, Submenu) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Pos = integer()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Submenu = wxMenu()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBinsert(This, Pos, Itemid, Text, Submenu, [])\fR\&\&.
.RE
.LP
.B
insert(This, Pos, Itemid, Text, Help, IsCheckable) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Pos = integer()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Help = chardata() (see module unicode)
.br
IsCheckable = boolean()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
insert(This, Pos, Itemid, Text, Submenu, [Option]) -> wxMenuItem:wxMenuItem() when
.br
This::wxMenu(), Pos::integer(), Itemid::integer(), Text::unicode:chardata(), Submenu::wxMenu(),
.br
Option :: {help, unicode:chardata()}\&.
.br

.RE
.LP
.B
insertCheckItem(This, Pos, Itemid, Text) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Pos = integer()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBinsertCheckItem(This, Pos, Itemid, Text, [])\fR\&\&.
.RE
.LP
.B
insertCheckItem(This, Pos, Itemid, Text, Option::[Option]) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Pos = integer()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Option = {help, chardata() (see module unicode)}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
insertRadioItem(This, Pos, Itemid, Text) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Pos = integer()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBinsertRadioItem(This, Pos, Itemid, Text, [])\fR\&\&.
.RE
.LP
.B
insertRadioItem(This, Pos, Itemid, Text, Option::[Option]) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Pos = integer()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Option = {help, chardata() (see module unicode)}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
insertSeparator(This, Pos) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
isChecked(This, Itemid) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
isEnabled(This, Itemid) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
prepend(This, Itemid) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
prepend(This, Item) -> wxMenuItem:wxMenuItem() when
.br
This::wxMenu(), Item::wxMenuItem:wxMenuItem()\&.
.br

.LP

.br
Kind = ?wxITEM_SEPARATOR | ?wxITEM_NORMAL | ?wxITEM_CHECK | ?wxITEM_RADIO | ?wxITEM_MAX
.RE
.LP
.B
prepend(This, Itemid, Option::[Option]) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Option = {text, chardata() (see module unicode)} | {help, chardata() (see module unicode)} | {kind, wx_enum() (see module wx)}
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Kind = ?wxITEM_SEPARATOR | ?wxITEM_NORMAL | ?wxITEM_CHECK | ?wxITEM_RADIO | ?wxITEM_MAX
.RE
.LP
.B
prepend(This, Itemid, Text, Submenu) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Submenu = wxMenu()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBprepend(This, Itemid, Text, Submenu, [])\fR\&\&.
.RE
.LP
.B
prepend(This, Itemid, Text, Help, IsCheckable) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Help = chardata() (see module unicode)
.br
IsCheckable = boolean()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
prepend(This, Itemid, Text, Submenu, [Option]) -> wxMenuItem:wxMenuItem() when
.br
This::wxMenu(), Itemid::integer(), Text::unicode:chardata(), Submenu::wxMenu(),
.br
Option :: {help, unicode:chardata()}\&.
.br

.RE
.LP
.B
prependCheckItem(This, Itemid, Text) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBprependCheckItem(This, Itemid, Text, [])\fR\&\&.
.RE
.LP
.B
prependCheckItem(This, Itemid, Text, Option::[Option]) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Option = {help, chardata() (see module unicode)}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
prependRadioItem(This, Itemid, Text) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBprependRadioItem(This, Itemid, Text, [])\fR\&\&.
.RE
.LP
.B
prependRadioItem(This, Itemid, Text, Option::[Option]) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Text = chardata() (see module unicode)
.br
Option = {help, chardata() (see module unicode)}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
prependSeparator(This) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
remove(This, Itemid) -> wxMenuItem() (see module wxMenuItem)
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
remove(This, Item) -> wxMenuItem:wxMenuItem() when
.br
This::wxMenu(), Item::wxMenuItem:wxMenuItem()\&.
.br

.RE
.LP
.B
setHelpString(This, Itemid, HelpString) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
HelpString = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setLabel(This, Itemid, Label) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Itemid = integer()
.br
Label = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setTitle(This, Title) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxMenu()
.br
Title = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
destroy(This::wxMenu()) -> ok
.br
.RS
.LP
Destroys this object, do not use object again
.RE
.SH AUTHORS
.LP

.I
<>