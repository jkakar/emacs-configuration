.TH erlang 3 "erts 6.0" "Ericsson AB" "Erlang Module Definition"
.SH NAME
erlang \- The Erlang BIFs
.SH DESCRIPTION
.LP
By convention, most built-in functions (BIFs) are seen as being in the module \fIerlang\fR\&\&. A number of the BIFs are viewed more or less as part of the Erlang programming language and are \fIauto-imported\fR\&\&. Thus, it is not necessary to specify the module name and both the calls \fIatom_to_list(Erlang)\fR\& and \fIerlang:atom_to_list(Erlang)\fR\& are identical\&.
.LP
In the text, auto-imported BIFs are listed without module prefix\&. BIFs listed with module prefix are not auto-imported\&.
.LP
BIFs may fail for a variety of reasons\&. All BIFs fail with reason \fIbadarg\fR\& if they are called with arguments of an incorrect type\&. The other reasons that may make BIFs fail are described in connection with the description of each individual BIF\&.
.LP
Some BIFs may be used in guard tests, these are marked with "Allowed in guard tests"\&.
.SH DATA TYPES
.nf

.B
\fBext_binary()\fR\&
.br
.fi
.RS
.LP
A binary data object, structured according to the Erlang external term format\&.
.RE
.nf

\fBtimestamp()\fR\& = 
.br
    {MegaSecs :: integer() >= 0,
.br
     Secs :: integer() >= 0,
.br
     MicroSecs :: integer() >= 0}
.br
.fi
.RS
.LP
See \fBnow/0\fR\&\&.
.RE
.SH EXPORTS
.LP
.nf

.B
abs(Float) -> float()
.br
.fi
.br
.nf

.B
abs(Int) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Float = float()
.br
Int = integer()
.br
.RE
.RE
.RS
.LP
Returns an integer or float which is the arithmetical absolute value of \fIFloat\fR\& or \fIInt\fR\&\&.
.LP
.nf

> abs(-3\&.33)\&.
3.33
> abs(-3)\&.
3
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
erlang:adler32(Data) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Data = iodata()
.br
.RE
.RE
.RS
.LP
Computes and returns the adler32 checksum for \fIData\fR\&\&.
.RE
.LP
.nf

.B
erlang:adler32(OldAdler, Data) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OldAdler = integer() >= 0
.br
Data = iodata()
.br
.RE
.RE
.RS
.LP
Continue computing the adler32 checksum by combining the previous checksum, \fIOldAdler\fR\&, with the checksum of \fIData\fR\&\&.
.LP
The following code:
.LP
.nf

	X = erlang:adler32(Data1),
	Y = erlang:adler32(X,Data2).
	
.fi
.LP
- would assign the same value to \fIY\fR\& as this would:
.LP
.nf

	Y = erlang:adler32([Data1,Data2]).
	
.fi
.RE
.LP
.nf

.B
erlang:adler32_combine(FirstAdler, SecondAdler, SecondSize) ->
.B
                          integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
FirstAdler = SecondAdler = SecondSize = integer() >= 0
.br
.RE
.RE
.RS
.LP
Combines two previously computed adler32 checksums\&. This computation requires the size of the data object for the second checksum to be known\&.
.LP
The following code:
.LP
.nf

	Y = erlang:adler32(Data1),
	Z = erlang:adler32(Y,Data2).
	
.fi
.LP
- would assign the same value to \fIZ\fR\& as this would:
.LP
.nf

	X = erlang:adler32(Data1),
	Y = erlang:adler32(Data2),
	Z = erlang:adler32_combine(X,Y,iolist_size(Data2)).
	
.fi
.RE
.LP
.nf

.B
erlang:append_element(Tuple1, Term) -> Tuple2
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tuple1 = Tuple2 = tuple()
.br
Term = term()
.br
.RE
.RE
.RS
.LP
Returns a new tuple which has one element more than \fITuple1\fR\&, and contains the elements in \fITuple1\fR\& followed by \fITerm\fR\& as the last element\&. Semantically equivalent to \fIlist_to_tuple(tuple_to_list(Tuple1) ++ [Term])\fR\&, but much faster\&.
.LP
.nf

> erlang:append_element({one, two}, three)\&.
{one,two,three}
.fi
.RE
.LP
.nf

.B
apply(Fun, Args) -> term()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Fun = function()
.br
Args = [term()]
.br
.RE
.RE
.RS
.LP
Call a fun, passing the elements in \fIArgs\fR\& as arguments\&.
.LP
Note: If the number of elements in the arguments are known at compile-time, the call is better written as \fIFun(Arg1, Arg2, \&.\&.\&. ArgN)\fR\&\&.
.LP

.RS -4
.B
Warning:
.RE
Earlier, \fIFun\fR\& could also be given as \fI{Module, Function}\fR\&, equivalent to \fIapply(Module, Function, Args)\fR\&\&. This usage is deprecated and will stop working in a future release of Erlang/OTP\&.

.RE
.LP
.nf

.B
apply(Module, Function, Args) -> term()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Function = atom()
.br
Args = [term()]
.br
.RE
.RE
.RS
.LP
Returns the result of applying \fIFunction\fR\& in \fIModule\fR\& to \fIArgs\fR\&\&. The applied function must be exported from \fIModule\fR\&\&. The arity of the function is the length of \fIArgs\fR\&\&.
.LP
.nf

> apply(lists, reverse, [[a, b, c]])\&.
[c,b,a]
.fi
.LP
\fIapply\fR\& can be used to evaluate BIFs by using the module name \fIerlang\fR\&\&.
.LP
.nf

> apply(erlang, atom_to_list, [\&'Erlang\&'])\&.
"Erlang"
.fi
.LP
Note: If the number of arguments are known at compile-time, the call is better written as \fIModule:Function(Arg1, Arg2, \&.\&.\&., ArgN)\fR\&\&.
.LP
Failure: \fIerror_handler:undefined_function/3\fR\& is called if the applied function is not exported\&. The error handler can be redefined (see \fBprocess_flag/2\fR\&)\&. If the \fIerror_handler\fR\& is undefined, or if the user has redefined the default \fIerror_handler\fR\& so the replacement module is undefined, an error with the reason \fIundef\fR\& is generated\&.
.RE
.LP
.nf

.B
atom_to_binary(Atom, Encoding) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Atom = atom()
.br
Encoding = latin1 | unicode | utf8
.br
.RE
.RE
.RS
.LP
Returns a binary which corresponds to the text representation of \fIAtom\fR\&\&. If \fIEncoding\fR\& is \fIlatin1\fR\&, there will be one byte for each character in the text representation\&. If \fIEncoding\fR\& is \fIutf8\fR\& or \fIunicode\fR\&, the characters will be encoded using UTF-8 (meaning that characters from 16#80 up to 0xFF will be encoded in two bytes)\&.
.LP

.RS -4
.B
Note:
.RE
Currently, \fIatom_to_binary(Atom, latin1)\fR\& can never fail because the text representation of an atom can only contain characters from 0 to 16#FF\&. In a future release, the text representation of atoms might be allowed to contain any Unicode character and \fIatom_to_binary(Atom, latin1)\fR\& will fail if the text representation for the \fIAtom\fR\& contains a Unicode character greater than 16#FF\&.

.LP
.nf

> atom_to_binary(\&'Erlang\&', latin1)\&.
<<"Erlang">>
.fi
.RE
.LP
.nf

.B
atom_to_list(Atom) -> string()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Atom = atom()
.br
.RE
.RE
.RS
.LP
Returns a string which corresponds to the text representation of \fIAtom\fR\&\&.
.LP
.nf

> atom_to_list(\&'Erlang\&')\&.
"Erlang"
.fi
.RE
.LP
.nf

.B
binary_part(Subject, PosLen) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Subject = binary()
.br
PosLen = {Start :: integer() >= 0, Length :: integer()}
.br
.RE
.RE
.RS
.LP
Extracts the part of the binary described by \fIPosLen\fR\&\&.
.LP
Negative length can be used to extract bytes at the end of a binary:
.LP
.nf

1> Bin = <<1,2,3,4,5,6,7,8,9,10>>.
2> binary_part(Bin,{byte_size(Bin), -5}).
<<6,7,8,9,10>>

.fi
.LP
If \fIPosLen\fR\& in any way references outside the binary, a \fIbadarg\fR\& exception is raised\&.
.LP
\fIStart\fR\& is zero-based, i\&.e\&.:
.LP
.nf

1> Bin = <<1,2,3>>
2> binary_part(Bin,{0,2}).
<<1,2>>

.fi
.LP
See the STDLIB module \fIbinary\fR\& for details about the \fIPosLen\fR\& semantics\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
binary_part(Subject, Start, Length) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Subject = binary()
.br
Start = integer() >= 0
.br
Length = integer()
.br
.RE
.RE
.RS
.LP
The same as \fIbinary_part(Subject, {Start, Length})\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
binary_to_atom(Binary, Encoding) -> atom()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Binary = binary()
.br
Encoding = latin1 | unicode | utf8
.br
.RE
.RE
.RS
.LP
Returns the atom whose text representation is \fIBinary\fR\&\&. If \fIEncoding\fR\& is \fIlatin1\fR\&, no translation of bytes in the binary is done\&. If \fIEncoding\fR\& is \fIutf8\fR\& or \fIunicode\fR\&, the binary must contain valid UTF-8 sequences; furthermore, only Unicode characters up to 0xFF are allowed\&.
.LP

.RS -4
.B
Note:
.RE
\fIbinary_to_atom(Binary, utf8)\fR\& will fail if the binary contains Unicode characters greater than 16#FF\&. In a future release, such Unicode characters might be allowed and \fIbinary_to_atom(Binary, utf8)\fR\& will not fail in that case\&. For more information on Unicode support in atoms see \fBnote on UTF-8 encoded atoms\fR\& in the chapter about the external term format in the ERTS User\&'s Guide\&.

.LP
.nf

> binary_to_atom(<<"Erlang">>, latin1)\&.
'Erlang'
> binary_to_atom(<<1024/utf8>>, utf8)\&.
** exception error: bad argument
     in function  binary_to_atom/2
        called as binary_to_atom(<<208,128>>,utf8)
.fi
.RE
.LP
.nf

.B
binary_to_existing_atom(Binary, Encoding) -> atom()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Binary = binary()
.br
Encoding = latin1 | unicode | utf8
.br
.RE
.RE
.RS
.LP
Works like \fBbinary_to_atom/2\fR\&, but the atom must already exist\&.
.LP
Failure: \fIbadarg\fR\& if the atom does not already exist\&.
.RE
.LP
.nf

.B
binary_to_float(Binary) -> float()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Binary = binary()
.br
.RE
.RE
.RS
.LP
Returns the float whose text representation is \fIBinary\fR\&\&.
.LP
.nf

> binary_to_float(<<"2\&.2017764e+0">>)\&.
2.2017764
.fi
.LP
Failure: \fIbadarg\fR\& if \fIBinary\fR\& contains a bad representation of a float\&.
.RE
.LP
.nf

.B
binary_to_integer(Binary) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Binary = binary()
.br
.RE
.RE
.RS
.LP
Returns an integer whose text representation is \fIBinary\fR\&\&.
.LP
.nf

> binary_to_integer(<<"123">>)\&.
123
.fi
.LP
Failure: \fIbadarg\fR\& if \fIBinary\fR\& contains a bad representation of an integer\&.
.RE
.LP
.nf

.B
binary_to_integer(Binary, Base) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Binary = binary()
.br
Base = 2\&.\&.36
.br
.RE
.RE
.RS
.LP
Returns an integer whose text representation in base \fIBase\fR\& is \fIBinary\fR\&\&.
.LP
.nf

> binary_to_integer(<<"3FF">>, 16)\&.
1023
.fi
.LP
Failure: \fIbadarg\fR\& if \fIBinary\fR\& contains a bad representation of an integer\&.
.RE
.LP
.nf

.B
binary_to_list(Binary) -> [byte()]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Binary = binary()
.br
.RE
.RE
.RS
.LP
Returns a list of integers which correspond to the bytes of \fIBinary\fR\&\&.
.RE
.LP
.nf

.B
binary_to_list(Binary, Start, Stop) -> [byte()]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Binary = binary()
.br
Start = Stop = integer() >= 1
.br
.RS 2
1\&.\&.byte_size(Binary)
.RE
.RE
.RE
.RS
.LP
As \fIbinary_to_list/1\fR\&, but returns a list of integers corresponding to the bytes from position \fIStart\fR\& to position \fIStop\fR\& in \fIBinary\fR\&\&. Positions in the binary are numbered starting from 1\&.
.LP

.RS -4
.B
Note:
.RE
This function\&'s indexing style of using one-based indices for binaries is deprecated\&. New code should use the functions in the STDLIB module \fIbinary\fR\& instead\&. They consequently use the same (zero-based) style of indexing\&.

.RE
.LP
.nf

.B
bitstring_to_list(Bitstring) -> [byte() | bitstring()]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Bitstring = bitstring()
.br
.RE
.RE
.RS
.LP
Returns a list of integers which correspond to the bytes of \fIBitstring\fR\&\&. If the number of bits in the binary is not divisible by 8, the last element of the list will be a bitstring containing the remaining bits (1 up to 7 bits)\&.
.RE
.LP
.nf

.B
binary_to_term(Binary) -> term()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Binary = \fBext_binary()\fR\&
.br
.RE
.RE
.RS
.LP
Returns an Erlang term which is the result of decoding the binary object \fIBinary\fR\&, which must be encoded according to the Erlang external term format\&.
.LP

.RS -4
.B
Warning:
.RE
When decoding binaries from untrusted sources, consider using \fIbinary_to_term/2\fR\& to prevent denial of service attacks\&.

.LP
See also \fBterm_to_binary/1\fR\& and \fBbinary_to_term/2\fR\&\&.
.RE
.LP
.nf

.B
binary_to_term(Binary, Opts) -> term()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Binary = \fBext_binary()\fR\&
.br
Opts = [safe]
.br
.RE
.RE
.RS
.LP
As \fIbinary_to_term/1\fR\&, but takes options that affect decoding of the binary\&.
.RS 2
.TP 2
.B
\fIsafe\fR\&:
Use this option when receiving binaries from an untrusted source\&.
.RS 2
.LP
When enabled, it prevents decoding data that may be used to attack the Erlang system\&. In the event of receiving unsafe data, decoding fails with a badarg error\&.
.RE
.RS 2
.LP
Currently, this prevents creation of new atoms directly, creation of new atoms indirectly (as they are embedded in certain structures like pids, refs, funs, etc\&.), and creation of new external function references\&. None of those resources are currently garbage collected, so unchecked creation of them can exhaust available memory\&.
.RE
.RE
.LP
Failure: \fIbadarg\fR\& if \fIsafe\fR\& is specified and unsafe data is decoded\&.
.LP
See also \fBterm_to_binary/1\fR\&, \fBbinary_to_term/1\fR\&, and \fB list_to_existing_atom/1\fR\&\&.
.RE
.LP
.nf

.B
bit_size(Bitstring) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Bitstring = bitstring()
.br
.RE
.RE
.RS
.LP
Returns an integer which is the size in bits of \fIBitstring\fR\&\&.
.LP
.nf

> bit_size(<<433:16,3:3>>)\&.
19
> bit_size(<<1,2,3>>)\&.
24
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
erlang:bump_reductions(Reductions) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Reductions = integer() >= 1
.br
.RE
.RE
.RS
.LP
This implementation-dependent function increments the reduction counter for the calling process\&. In the Beam emulator, the reduction counter is normally incremented by one for each function and BIF call, and a context switch is forced when the counter reaches the maximum number of reductions for a process (2000 reductions in R12B)\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF might be removed in a future version of the Beam machine without prior warning\&. It is unlikely to be implemented in other Erlang implementations\&.

.RE
.LP
.nf

.B
byte_size(Bitstring) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Bitstring = bitstring()
.br
.RE
.RE
.RS
.LP
Returns an integer which is the number of bytes needed to contain \fIBitstring\fR\&\&. (That is, if the number of bits in \fIBitstring\fR\& is not divisible by 8, the resulting number of bytes will be rounded \fIup\fR\&\&.)
.LP
.nf

> byte_size(<<433:16,3:3>>)\&.
3
> byte_size(<<1,2,3>>)\&.
3
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
erlang:cancel_timer(TimerRef) -> Time | false
.br
.fi
.br
.RS
.LP
Types:

.RS 3
TimerRef = reference()
.br
Time = integer() >= 0
.br
.RE
.RE
.RS
.LP
Cancels a timer, where \fITimerRef\fR\& was returned by either \fBerlang:send_after/3\fR\& or \fBerlang:start_timer/3\fR\&\&. If the timer is there to be removed, the function returns the time in milliseconds left until the timer would have expired, otherwise \fIfalse\fR\& (which means that \fITimerRef\fR\& was never a timer, that it has already been cancelled, or that it has already delivered its message)\&.
.LP
See also \fBerlang:send_after/3\fR\&, \fBerlang:start_timer/3\fR\&, and \fBerlang:read_timer/1\fR\&\&.
.LP
Note: Cancelling a timer does not guarantee that the message has not already been delivered to the message queue\&.
.RE
.LP
.nf

.B
check_old_code(Module) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if the \fIModule\fR\& has old code, and \fIfalse\fR\& otherwise\&.
.LP
See also \fBcode(3)\fR\&\&.
.RE
.LP
.nf

.B
check_process_code(Pid, Module) -> CheckResult
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid()
.br
Module = module()
.br
CheckResult = boolean()
.br
.RE
.RE
.RS
.LP
The same as \fB\fIerlang:check_process_code(Pid, Module, [])\fR\&\fR\&\&.
.RE
.LP
.nf

.B
check_process_code(Pid, Module, OptionList) -> CheckResult | async
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid()
.br
Module = module()
.br
RequestId = term()
.br
Option = {async, RequestId} | {allow_gc, boolean()}
.br
OptionList = [Option]
.br
CheckResult = boolean() | aborted
.br
.RE
.RE
.RS
.LP
Check if the node local process identified by \fIPid\fR\& is executing old code for \fIModule\fR\&\&.
.LP
Currently available \fIOptions\fR\&:
.RS 2
.TP 2
.B
\fI{allow_gc, boolean()}\fR\&:
 Determines if garbage collection is allowed when performing the operation\&. If \fI{allow_gc, false}\fR\& is passed, and a garbage collection is needed in order to determine the result of the operation, the operation will be aborted (see information on \fICheckResult\fR\& below)\&. The default is to allow garbage collection, i\&.e\&., \fI{allow_gc, true}\fR\&\&. 
.TP 2
.B
\fI{async, RequestId}\fR\&:
 The \fIcheck_process_code/3\fR\& function will return the value \fIasync\fR\& immediately after the request has been sent\&. When the request has been processed, the process that called this function will be passed a message on the form:
.br
\fI{check_process_code, RequestId, CheckResult}\fR\&\&. 
.RE
.LP
If \fIPid\fR\& equals \fIself()\fR\&, and no \fIasync\fR\& option has been passed, the operation will be performed at once\&. In all other cases a request for the operation will be sent to the process identified by \fIPid\fR\&, and will be handled when appropriate\&. If no \fIasync\fR\& option has been passed, the caller will block until \fICheckResult\fR\& is available and can be returned\&.
.LP
\fICheckResult\fR\& informs about the result of the request:
.RS 2
.TP 2
.B
\fItrue\fR\&:
 The process identified by \fIPid\fR\& is executing old code for \fIModule\fR\&\&. That is, the current call of the process executes old code for this module, or the process has references to old code for this module, or the process contains funs that references old code for this module\&. 
.TP 2
.B
\fIfalse\fR\&:
 The process identified by \fIPid\fR\& is not executing old code for \fIModule\fR\&\&. 
.TP 2
.B
\fIaborted\fR\&:
 The operation was aborted since the process needed to be garbage collected in order to determine the result of the operation, and the operation was requested by passing the \fI{allow_gc, false}\fR\& option\&.
.RE
.LP
See also \fBcode(3)\fR\&\&.
.LP
Failures:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
 If \fIPid\fR\& is not a node local process identifier\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If \fIModule\fR\& is not an atom\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If \fIOptionList\fR\& is not a valid list of options\&. 
.RE
.RE
.LP
.nf

.B
erlang:crc32(Data) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Data = iodata()
.br
.RE
.RE
.RS
.LP
Computes and returns the crc32 (IEEE 802\&.3 style) checksum for \fIData\fR\&\&.
.RE
.LP
.nf

.B
erlang:crc32(OldCrc, Data) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OldCrc = integer() >= 0
.br
Data = iodata()
.br
.RE
.RE
.RS
.LP
Continue computing the crc32 checksum by combining the previous checksum, \fIOldCrc\fR\&, with the checksum of \fIData\fR\&\&.
.LP
The following code:
.LP
.nf

	X = erlang:crc32(Data1),
	Y = erlang:crc32(X,Data2).
	
.fi
.LP
- would assign the same value to \fIY\fR\& as this would:
.LP
.nf

	Y = erlang:crc32([Data1,Data2]).
	
.fi
.RE
.LP
.nf

.B
erlang:crc32_combine(FirstCrc, SecondCrc, SecondSize) ->
.B
                        integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
FirstCrc = SecondCrc = SecondSize = integer() >= 0
.br
.RE
.RE
.RS
.LP
Combines two previously computed crc32 checksums\&. This computation requires the size of the data object for the second checksum to be known\&.
.LP
The following code:
.LP
.nf

	Y = erlang:crc32(Data1),
	Z = erlang:crc32(Y,Data2).
	
.fi
.LP
- would assign the same value to \fIZ\fR\& as this would:
.LP
.nf

	X = erlang:crc32(Data1),
	Y = erlang:crc32(Data2),
	Z = erlang:crc32_combine(X,Y,iolist_size(Data2)).
	
.fi
.RE
.LP
.nf

.B
date() -> Date
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Date = \fBcalendar:date()\fR\&
.br
.RE
.RE
.RS
.LP
Returns the current date as \fI{Year, Month, Day}\fR\&\&.
.LP
The time zone and daylight saving time correction depend on the underlying OS\&.
.LP
.nf

> date()\&.
{1995,2,19}
.fi
.RE
.LP
.nf

.B
erlang:decode_packet(Type, Bin, Options) ->
.B
                        {ok, Packet, Rest} |
.B
                        {more, Length} |
.B
                        {error, Reason}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = raw
.br
     | 0
.br
     | 1
.br
     | 2
.br
     | 4
.br
     | asn1
.br
     | cdr
.br
     | sunrm
.br
     | fcgi
.br
     | tpkt
.br
     | line
.br
     | http
.br
     | http_bin
.br
     | httph
.br
     | httph_bin
.br
Bin = binary()
.br
Options = [Opt]
.br
Opt = {packet_size, integer() >= 0}
.br
    | {line_length, integer() >= 0}
.br
Packet = binary() | HttpPacket
.br
Rest = binary()
.br
Length = integer() >= 0 | undefined
.br
Reason = term()
.br
HttpPacket = HttpRequest
.br
           | HttpResponse
.br
           | HttpHeader
.br
           | http_eoh
.br
           | HttpError
.br
HttpRequest = {http_request, HttpMethod, HttpUri, HttpVersion}
.br
HttpResponse = 
.br
    {http_response, HttpVersion, integer(), HttpString}
.br
HttpHeader = 
.br
    {http_header,
.br
     integer(),
.br
     HttpField,
.br
     Reserved :: term(),
.br
     Value :: HttpString}
.br
HttpError = {http_error, HttpString}
.br
HttpMethod = \&'OPTIONS\&'
.br
           | \&'GET\&'
.br
           | \&'HEAD\&'
.br
           | \&'POST\&'
.br
           | \&'PUT\&'
.br
           | \&'DELETE\&'
.br
           | \&'TRACE\&'
.br
           | HttpString
.br
HttpUri = \&'*\&'
.br
        | {absoluteURI,
.br
           http | https,
.br
           Host :: HttpString,
.br
           Port :: \fBinet:port_number()\fR\& | undefined,
.br
           Path :: HttpString}
.br
        | {scheme, Scheme :: HttpString, HttpString}
.br
        | {abs_path, HttpString}
.br
        | HttpString
.br
HttpVersion = 
.br
    {Major :: integer() >= 0, Minor :: integer() >= 0}
.br
HttpField = \&'Cache-Control\&'
.br
          | \&'Connection\&'
.br
          | \&'Date\&'
.br
          | \&'Pragma\&'
.br
          | \&'Transfer-Encoding\&'
.br
          | \&'Upgrade\&'
.br
          | \&'Via\&'
.br
          | \&'Accept\&'
.br
          | \&'Accept-Charset\&'
.br
          | \&'Accept-Encoding\&'
.br
          | \&'Accept-Language\&'
.br
          | \&'Authorization\&'
.br
          | \&'From\&'
.br
          | \&'Host\&'
.br
          | \&'If-Modified-Since\&'
.br
          | \&'If-Match\&'
.br
          | \&'If-None-Match\&'
.br
          | \&'If-Range\&'
.br
          | \&'If-Unmodified-Since\&'
.br
          | \&'Max-Forwards\&'
.br
          | \&'Proxy-Authorization\&'
.br
          | \&'Range\&'
.br
          | \&'Referer\&'
.br
          | \&'User-Agent\&'
.br
          | \&'Age\&'
.br
          | \&'Location\&'
.br
          | \&'Proxy-Authenticate\&'
.br
          | \&'Public\&'
.br
          | \&'Retry-After\&'
.br
          | \&'Server\&'
.br
          | \&'Vary\&'
.br
          | \&'Warning\&'
.br
          | \&'Www-Authenticate\&'
.br
          | \&'Allow\&'
.br
          | \&'Content-Base\&'
.br
          | \&'Content-Encoding\&'
.br
          | \&'Content-Language\&'
.br
          | \&'Content-Length\&'
.br
          | \&'Content-Location\&'
.br
          | \&'Content-Md5\&'
.br
          | \&'Content-Range\&'
.br
          | \&'Content-Type\&'
.br
          | \&'Etag\&'
.br
          | \&'Expires\&'
.br
          | \&'Last-Modified\&'
.br
          | \&'Accept-Ranges\&'
.br
          | \&'Set-Cookie\&'
.br
          | \&'Set-Cookie2\&'
.br
          | \&'X-Forwarded-For\&'
.br
          | \&'Cookie\&'
.br
          | \&'Keep-Alive\&'
.br
          | \&'Proxy-Connection\&'
.br
          | HttpString
.br
HttpString = string() | binary()
.br
.RE
.RE
.RS
.LP
Decodes the binary \fIBin\fR\& according to the packet protocol specified by \fIType\fR\&\&. Very similar to the packet handling done by sockets with the option {packet,Type}\&.
.LP
If an entire packet is contained in \fIBin\fR\& it is returned together with the remainder of the binary as \fI{ok,Packet,Rest}\fR\&\&.
.LP
If \fIBin\fR\& does not contain the entire packet, \fI{more,Length}\fR\& is returned\&. \fILength\fR\& is either the expected \fItotal size\fR\& of the packet or \fIundefined\fR\& if the expected packet size is not known\&. \fIdecode_packet\fR\& can then be called again with more data added\&.
.LP
If the packet does not conform to the protocol format \fI{error,Reason}\fR\& is returned\&.
.LP
The following values of \fIType\fR\& are valid:
.RS 2
.TP 2
.B
\fIraw | 0\fR\&:
No packet handling is done\&. Entire binary is returned unless it is empty\&.
.TP 2
.B
\fI1 | 2 | 4\fR\&:
Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes\&. The length of header can be one, two, or four bytes; the order of the bytes is big-endian\&. The header will be stripped off when the packet is returned\&.
.TP 2
.B
\fIline\fR\&:
A packet is a line terminated with newline\&. The newline character is included in the returned packet unless the line was truncated according to the option \fIline_length\fR\&\&.
.TP 2
.B
\fIasn1 | cdr | sunrm | fcgi | tpkt\fR\&:
The header is \fInot\fR\& stripped off\&.
.RS 2
.LP
The meanings of the packet types are as follows:
.RE
.RS 2
.TP 2
.B
\fIasn1\fR\& - ASN\&.1 BER:

.TP 2
.B
\fIsunrm\fR\& - Sun\&'s RPC encoding:

.TP 2
.B
\fIcdr\fR\& - CORBA (GIOP 1\&.1):

.TP 2
.B
\fIfcgi\fR\& - Fast CGI:

.TP 2
.B
\fItpkt\fR\& - TPKT format [RFC1006]:

.RE
.TP 2
.B
\fIhttp | httph | http_bin | httph_bin\fR\&:
The Hypertext Transfer Protocol\&. The packets are returned with the format according to \fIHttpPacket\fR\& described above\&. A packet is either a request, a response, a header or an end of header mark\&. Invalid lines are returned as \fIHttpError\fR\&\&.
.RS 2
.LP
Recognized request methods and header fields are returned as atoms\&. Others are returned as strings\&. Strings of unrecognized header fields are formatted with only capital letters first and after hyphen characters (like \fI"Sec-Websocket-Key"\fR\&)\&.
.RE
.RS 2
.LP
The protocol type \fIhttp\fR\& should only be used for the first line when a \fIHttpRequest\fR\& or a \fIHttpResponse\fR\& is expected\&. The following calls should use \fIhttph\fR\& to get \fIHttpHeader\fR\&\&'s until \fIhttp_eoh\fR\& is returned that marks the end of the headers and the beginning of any following message body\&.
.RE
.RS 2
.LP
The variants \fIhttp_bin\fR\& and \fIhttph_bin\fR\& will return strings (\fIHttpString\fR\&) as binaries instead of lists\&.
.RE
.RE
.LP
The following options are available:
.RS 2
.TP 2
.B
\fI{packet_size, integer() >= 0}\fR\&:
Sets the max allowed size of the packet body\&. If the packet header indicates that the length of the packet is longer than the max allowed length, the packet is considered invalid\&. Default is 0 which means no size limit\&.
.TP 2
.B
\fI{line_length, integer() >= 0}\fR\&:
For packet type \fIline\fR\&, truncate lines longer than the indicated length\&.
.RS 2
.LP
Option \fIline_length\fR\& also applies to \fIhttp*\fR\& packet types as an alias for option \fIpacket_size\fR\& in the case when \fIpacket_size\fR\& itself is not set\&. This usage is only intended for backward compatibility\&.
.RE
.RE
.LP
.nf

> erlang:decode_packet(1,<<3,"abcd">>,[])\&.
{ok,<<"abc">>,<<"d">>}
> erlang:decode_packet(1,<<5,"abcd">>,[])\&.
{more,6}
.fi
.RE
.LP
.nf

.B
erlang:delete_element(Index, Tuple1) -> Tuple2
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Index = integer() >= 1
.br
.RS 2
1\&.\&.tuple_size(Tuple1)
.RE
Tuple1 = Tuple2 = tuple()
.br
.RE
.RE
.RS
.LP
Returns a new tuple with element at \fIIndex\fR\& removed from tuple \fITuple1\fR\&\&.
.LP
.nf

> erlang:delete_element(2, {one, two, three})\&.
{one,three}
.fi
.RE
.LP
.nf

.B
delete_module(Module) -> true | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
.RE
.RE
.RS
.LP
Makes the current code for \fIModule\fR\& become old code, and deletes all references for this module from the export table\&. Returns \fIundefined\fR\& if the module does not exist, otherwise \fItrue\fR\&\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for the code server (see \fBcode(3)\fR\&) and should not be used elsewhere\&.

.LP
Failure: \fIbadarg\fR\& if there is already an old version of \fIModule\fR\&\&.
.RE
.LP
.nf

.B
demonitor(MonitorRef) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MonitorRef = reference()
.br
.RE
.RE
.RS
.LP
If \fIMonitorRef\fR\& is a reference which the calling process obtained by calling \fBmonitor/2\fR\&, this monitoring is turned off\&. If the monitoring is already turned off, nothing happens\&.
.LP
Once \fIdemonitor(MonitorRef)\fR\& has returned it is guaranteed that no \fI{\&'DOWN\&', MonitorRef, _, _, _}\fR\& message due to the monitor will be placed in the caller\&'s message queue in the future\&. A \fI{\&'DOWN\&', MonitorRef, _, _, _}\fR\& message might have been placed in the caller\&'s message queue prior to the call, though\&. Therefore, in most cases, it is advisable to remove such a \fI\&'DOWN\&'\fR\& message from the message queue after monitoring has been stopped\&. \fBdemonitor(MonitorRef, [flush])\fR\& can be used instead of \fIdemonitor(MonitorRef)\fR\& if this cleanup is wanted\&.
.LP

.RS -4
.B
Note:
.RE
Prior to OTP release R11B (erts version 5\&.5) \fIdemonitor/1\fR\& behaved completely asynchronous, i\&.e\&., the monitor was active until the "demonitor signal" reached the monitored entity\&. This had one undesirable effect, though\&. You could never know when you were guaranteed \fInot\fR\& to receive a \fIDOWN\fR\& message due to the monitor\&.
.LP
Current behavior can be viewed as two combined operations: asynchronously send a "demonitor signal" to the monitored entity and ignore any future results of the monitor\&.

.LP
Failure: It is an error if \fIMonitorRef\fR\& refers to a monitoring started by another process\&. Not all such cases are cheap to check; if checking is cheap, the call fails with \fIbadarg\fR\& (for example if \fIMonitorRef\fR\& is a remote reference)\&.
.RE
.LP
.nf

.B
demonitor(MonitorRef, OptionList) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MonitorRef = reference()
.br
OptionList = [Option]
.br
Option = flush | info
.br
.RE
.RE
.RS
.LP
The returned value is \fItrue\fR\& unless \fIinfo\fR\& is part of \fIOptionList\fR\&\&.
.LP
\fIdemonitor(MonitorRef, [])\fR\& is equivalent to \fBdemonitor(MonitorRef)\fR\&\&.
.LP
Currently the following \fIOption\fR\&s are valid:
.RS 2
.TP 2
.B
\fIflush\fR\&:
Remove (one) \fI{_, MonitorRef, _, _, _}\fR\& message, if there is one, from the caller\&'s message queue after monitoring has been stopped\&.
.RS 2
.LP
Calling \fIdemonitor(MonitorRef, [flush])\fR\& is equivalent to the following, but more efficient:
.RE
.LP
.nf


    demonitor(MonitorRef),
    receive
        {_, MonitorRef, _, _, _} ->
            true
    after 0 ->
            true
    end
.fi
.TP 2
.B
\fIinfo\fR\&:
The returned value is one of the following:
.RS 2
.TP 2
.B
\fItrue\fR\&:
The monitor was found and removed\&. In this case no \fI\&'DOWN\&'\fR\& message due to this monitor have been nor will be placed in the message queue of the caller\&.
.TP 2
.B
\fIfalse\fR\&:
The monitor was not found and could not be removed\&. This probably because someone already has placed a \fI\&'DOWN\&'\fR\& message corresponding to this monitor in the caller\&'s message queue\&.
.RE
.RS 2
.LP
If the \fIinfo\fR\& option is combined with the \fIflush\fR\& option, \fIfalse\fR\& will be returned if a flush was needed; otherwise, \fItrue\fR\&\&.
.RE
.RE
.LP

.RS -4
.B
Note:
.RE
More options may be added in the future\&.

.LP
Failure: \fIbadarg\fR\& if \fIOptionList\fR\& is not a list, or if \fIOption\fR\& is not a valid option, or the same failure as for \fBdemonitor/1\fR\&
.RE
.LP
.nf

.B
disconnect_node(Node) -> boolean() | ignored
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
.RE
.RE
.RS
.LP
Forces the disconnection of a node\&. This will appear to the node \fINode\fR\& as if the local node has crashed\&. This BIF is mainly used in the Erlang network authentication protocols\&. Returns \fItrue\fR\& if disconnection succeeds, otherwise \fIfalse\fR\&\&. If the local node is not alive, the function returns \fIignored\fR\&\&.
.RE
.LP
.nf

.B
erlang:display(Term) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Prints a text representation of \fITerm\fR\& on the standard output\&. On OSE the term is printed to the ramlog\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for debugging only\&.

.RE
.LP
.nf

.B
element(N, Tuple) -> term()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
N = integer() >= 1
.br
.RS 2
1\&.\&.tuple_size(Tuple)
.RE
Tuple = tuple()
.br
.RE
.RE
.RS
.LP
Returns the \fIN\fR\&th element (numbering from 1) of \fITuple\fR\&\&.
.LP
.nf

> element(2, {a, b, c})\&.
b
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
erase() -> [{Key, Val}]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Val = term()
.br
.RE
.RE
.RS
.LP
Returns the process dictionary and deletes it\&.
.LP
.nf

> put(key1, {1, 2, 3}),
put(key2, [a, b, c]),
erase()\&.
[{key1,{1,2,3}},{key2,[a,b,c]}]
.fi
.RE
.LP
.nf

.B
erase(Key) -> Val | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Val = term()
.br
.RE
.RE
.RS
.LP
Returns the value \fIVal\fR\& associated with \fIKey\fR\& and deletes it from the process dictionary\&. Returns \fIundefined\fR\& if no value is associated with \fIKey\fR\&\&.
.LP
.nf

> put(key1, {merry, lambs, are, playing}),
X = erase(key1),
{X, erase(key1)}\&.
{{merry,lambs,are,playing},undefined}
.fi
.RE
.LP
.nf

.B
error(Reason) -> no_return()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Reason = term()
.br
.RE
.RE
.RS
.LP
Stops the execution of the calling process with the reason \fIReason\fR\&, where \fIReason\fR\& is any term\&. The actual exit reason will be \fI{Reason, Where}\fR\&, where \fIWhere\fR\& is a list of the functions most recently called (the current function first)\&. Since evaluating this function causes the process to terminate, it has no return value\&.
.LP
.nf

> catch error(foobar)\&.
{'EXIT',{foobar,[{erl_eval,do_apply,5},
                 {erl_eval,expr,5},
                 {shell,exprs,6},
                 {shell,eval_exprs,6},
                 {shell,eval_loop,3}]}}
.fi
.RE
.LP
.nf

.B
error(Reason, Args) -> no_return()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Reason = term()
.br
Args = [term()]
.br
.RE
.RE
.RS
.LP
Stops the execution of the calling process with the reason \fIReason\fR\&, where \fIReason\fR\& is any term\&. The actual exit reason will be \fI{Reason, Where}\fR\&, where \fIWhere\fR\& is a list of the functions most recently called (the current function first)\&. \fIArgs\fR\& is expected to be the list of arguments for the current function; in Beam it will be used to provide the actual arguments for the current function in the \fIWhere\fR\& term\&. Since evaluating this function causes the process to terminate, it has no return value\&.
.RE
.LP
.nf

.B
exit(Reason) -> no_return()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Reason = term()
.br
.RE
.RE
.RS
.LP
Stops the execution of the calling process with the exit reason \fIReason\fR\&, where \fIReason\fR\& is any term\&. Since evaluating this function causes the process to terminate, it has no return value\&.
.LP
.nf

> exit(foobar)\&.
** exception exit: foobar
> catch exit(foobar)\&.
{'EXIT',foobar}
.fi
.RE
.LP
.nf

.B
exit(Pid, Reason) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid() | port()
.br
Reason = term()
.br
.RE
.RE
.RS
.LP
Sends an exit signal with exit reason \fIReason\fR\& to the process or port identified by \fIPid\fR\&\&.
.LP
The following behavior apply if \fIReason\fR\& is any term except \fInormal\fR\& or \fIkill\fR\&:
.LP
If \fIPid\fR\& is not trapping exits, \fIPid\fR\& itself will exit with exit reason \fIReason\fR\&\&. If \fIPid\fR\& is trapping exits, the exit signal is transformed into a message \fI{\&'EXIT\&', From, Reason}\fR\& and delivered to the message queue of \fIPid\fR\&\&. \fIFrom\fR\& is the pid of the process which sent the exit signal\&. See also \fBprocess_flag/2\fR\&\&.
.LP
If \fIReason\fR\& is the atom \fInormal\fR\&, \fIPid\fR\& will not exit\&. If it is trapping exits, the exit signal is transformed into a message \fI{\&'EXIT\&', From, normal}\fR\& and delivered to its message queue\&.
.LP
If \fIReason\fR\& is the atom \fIkill\fR\&, that is if \fIexit(Pid, kill)\fR\& is called, an untrappable exit signal is sent to \fIPid\fR\& which will unconditionally exit with exit reason \fIkilled\fR\&\&.
.RE
.LP
.nf

.B
erlang:external_size(Term) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Calculates, without doing the encoding, the maximum byte size for a term encoded in the Erlang external term format\&. The following condition applies always:
.LP

.LP
.nf

> Size1 = byte_size(term_to_binary(Term)),
> Size2 = erlang:external_size(Term),
> true = Size1 =< Size2\&.
true
          
.fi 
.LP
This is equivalent to a call to: 
.LP
.nf
erlang:external_size(Term, [])
          
.fi
.RE
.LP
.nf

.B
erlang:external_size(Term, Options) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
Options = [{minor_version, Version :: integer() >= 0}]
.br
.RE
.RE
.RS
.LP
Calculates, without doing the encoding, the maximum byte size for a term encoded in the Erlang external term format\&. The following condition applies always:
.LP

.LP
.nf

> Size1 = byte_size(term_to_binary(Term, Options)),
> Size2 = erlang:external_size(Term, Options),
> true = Size1 =< Size2\&.
true
          
.fi 
.LP
The option \fI{minor_version, Version}\fR\& specifies how floats are encoded\&. See \fBterm_to_binary/2\fR\& for a more detailed description\&.
.RE
.LP
.nf

.B
float(Number) -> float()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Number = number()
.br
.RE
.RE
.RS
.LP
Returns a float by converting \fINumber\fR\& to a float\&.
.LP
.nf

> float(55)\&.
55.0
.fi
.LP
Allowed in guard tests\&.
.LP

.RS -4
.B
Note:
.RE
Note that if used on the top-level in a guard, it will test whether the argument is a floating point number; for clarity, use \fBis_float/1\fR\& instead\&.
.LP
When \fIfloat/1\fR\& is used in an expression in a guard, such as \&'\fIfloat(A) == 4\&.0\fR\&\&', it converts a number as described above\&.

.RE
.LP
.nf

.B
float_to_binary(Float) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Float = float()
.br
.RE
.RE
.RS
.LP
The same as \fIfloat_to_binary(Float,[{scientific,20}])\fR\&\&.
.RE
.LP
.nf

.B
float_to_binary(Float, Options) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Float = float()
.br
Options = [Option]
.br
Option = {decimals, Decimals :: 0\&.\&.253}
.br
       | {scientific, Decimals :: 0\&.\&.249}
.br
       | compact
.br
.RE
.RE
.RS
.LP
Returns a binary which corresponds to the text representation of \fIFloat\fR\& using fixed decimal point formatting\&. The \fIOptions\fR\& behave in the same way as \fBfloat_to_list/2\fR\&\&.
.LP
.nf

> float_to_binary(7\&.12, [{decimals, 4}])\&.
<<"7.1200">>
> float_to_binary(7\&.12, [{decimals, 4}, compact])\&.
<<"7.12">>
.fi
.RE
.LP
.nf

.B
float_to_list(Float) -> string()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Float = float()
.br
.RE
.RE
.RS
.LP
The same as \fIfloat_to_list(Float,[{scientific,20}])\fR\&\&.
.RE
.LP
.nf

.B
float_to_list(Float, Options) -> string()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Float = float()
.br
Options = [Option]
.br
Option = {decimals, Decimals :: 0\&.\&.253}
.br
       | {scientific, Decimals :: 0\&.\&.249}
.br
       | compact
.br
.RE
.RE
.RS
.LP
Returns a string which corresponds to the text representation of \fIFloat\fR\& using fixed decimal point formatting\&. When \fIdecimals\fR\& option is specified the returned value will contain at most \fIDecimals\fR\& number of digits past the decimal point\&. If the number doesn\&'t fit in the internal static buffer of 256 bytes, the function throws \fIbadarg\fR\&\&. When \fIcompact\fR\& option is provided the trailing zeros at the end of the list are truncated (this option is only meaningful together with the \fIdecimals\fR\& option)\&. When \fIscientific\fR\& option is provided, the float will be formatted using scientific notation with \fIDecimals\fR\& digits of precision\&. If \fIOptions\fR\& is \fI[]\fR\& the function behaves like \fI\fBfloat_to_list/1\fR\&\fR\&\&.
.LP
.nf

> float_to_list(7\&.12, [{decimals, 4}])\&.
"7.1200"
> float_to_list(7\&.12, [{decimals, 4}, compact])\&.
"7.12"
.fi
.RE
.LP
.nf

.B
erlang:fun_info(Fun) -> [{Item, Info}]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Fun = function()
.br
Item = arity
.br
     | env
.br
     | index
.br
     | name
.br
     | module
.br
     | new_index
.br
     | new_uniq
.br
     | pid
.br
     | type
.br
     | uniq
.br
Info = term()
.br
.RE
.RE
.RS
.LP
Returns a list containing information about the fun \fIFun\fR\&\&. Each element of the list is a tuple\&. The order of the tuples is not defined, and more tuples may be added in a future release\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is mainly intended for debugging, but it can occasionally be useful in library functions that might need to verify, for instance, the arity of a fun\&.

.LP
There are two types of funs with slightly different semantics:
.LP
A fun created by \fIfun M:F/A\fR\& is called an \fIexternal\fR\& fun\&. Calling it will always call the function \fIF\fR\& with arity \fIA\fR\& in the latest code for module \fIM\fR\&\&. Note that module \fIM\fR\& does not even need to be loaded when the fun \fIfun M:F/A\fR\& is created\&.
.LP
All other funs are called \fIlocal\fR\&\&. When a local fun is called, the same version of the code that created the fun will be called (even if newer version of the module has been loaded)\&.
.LP
The following elements will always be present in the list for both local and external funs:
.RS 2
.TP 2
.B
\fI{type, Type}\fR\&:
\fIType\fR\& is either \fIlocal\fR\& or \fIexternal\fR\&\&.
.TP 2
.B
\fI{module, Module}\fR\&:
\fIModule\fR\& (an atom) is the module name\&.
.RS 2
.LP
If \fIFun\fR\& is a local fun, \fIModule\fR\& is the module in which the fun is defined\&.
.RE
.RS 2
.LP
If \fIFun\fR\& is an external fun, \fIModule\fR\& is the module that the fun refers to\&.
.RE
.TP 2
.B
\fI{name, Name}\fR\&:
\fIName\fR\& (an atom) is a function name\&.
.RS 2
.LP
If \fIFun\fR\& is a local fun, \fIName\fR\& is the name of the local function that implements the fun\&. (This name was generated by the compiler, and is generally only of informational use\&. As it is a local function, it is not possible to call it directly\&.) If no code is currently loaded for the fun, \fI[]\fR\& will be returned instead of an atom\&.
.RE
.RS 2
.LP
If \fIFun\fR\& is an external fun, \fIName\fR\& is the name of the exported function that the fun refers to\&.
.RE
.TP 2
.B
\fI{arity, Arity}\fR\&:
\fIArity\fR\& is the number of arguments that the fun should be called with\&.
.TP 2
.B
\fI{env, Env}\fR\&:
\fIEnv\fR\& (a list) is the environment or free variables for the fun\&. (For external funs, the returned list is always empty\&.)
.RE
.LP
The following elements will only be present in the list if \fIFun\fR\& is local:
.RS 2
.TP 2
.B
\fI{pid, Pid}\fR\&:
\fIPid\fR\& is the pid of the process that originally created the fun\&.
.TP 2
.B
\fI{index, Index}\fR\&:
\fIIndex\fR\& (an integer) is an index into the module\&'s fun table\&.
.TP 2
.B
\fI{new_index, Index}\fR\&:
\fIIndex\fR\& (an integer) is an index into the module\&'s fun table\&.
.TP 2
.B
\fI{new_uniq, Uniq}\fR\&:
\fIUniq\fR\& (a binary) is a unique value for this fun\&. It is calculated from the compiled code for the entire module\&.
.TP 2
.B
\fI{uniq, Uniq}\fR\&:
\fIUniq\fR\& (an integer) is a unique value for this fun\&. Starting in the R15 release, this integer is calculated from the compiled code for the entire module\&. Before R15, this integer was based on only the body of the fun\&.
.RE
.RE
.LP
.nf

.B
erlang:fun_info(Fun, Item) -> {Item, Info}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Fun = function()
.br
Item = \fBfun_info_item()\fR\&
.br
Info = term()
.br
.nf
\fBfun_info_item()\fR\& = arity
.br
                | env
.br
                | index
.br
                | name
.br
                | module
.br
                | new_index
.br
                | new_uniq
.br
                | pid
.br
                | type
.br
                | uniq
.fi
.br
.RE
.RE
.RS
.LP
Returns information about \fIFun\fR\& as specified by \fIItem\fR\&, in the form \fI{Item,Info}\fR\&\&.
.LP
For any fun, \fIItem\fR\& can be any of the atoms \fImodule\fR\&, \fIname\fR\&, \fIarity\fR\&, \fIenv\fR\&, or \fItype\fR\&\&.
.LP
For a local fun, \fIItem\fR\& can also be any of the atoms \fIindex\fR\&, \fInew_index\fR\&, \fInew_uniq\fR\&, \fIuniq\fR\&, and \fIpid\fR\&\&. For an external fun, the value of any of these items is always the atom \fIundefined\fR\&\&.
.LP
See \fBerlang:fun_info/1\fR\&\&.
.RE
.LP
.nf

.B
erlang:fun_to_list(Fun) -> string()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Fun = function()
.br
.RE
.RE
.RS
.LP
Returns a string which corresponds to the text representation of \fIFun\fR\&\&.
.RE
.LP
.nf

.B
erlang:function_exported(Module, Function, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Function = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if the module \fIModule\fR\& is loaded and contains an exported function \fIFunction/Arity\fR\&; otherwise \fIfalse\fR\&\&.
.LP
Returns \fIfalse\fR\& for any BIF (functions implemented in C rather than in Erlang)\&.
.RE
.LP
.nf

.B
garbage_collect() -> true
.br
.fi
.br
.RS
.LP
Forces an immediate garbage collection of the currently executing process\&. The function should not be used, unless it has been noticed -- or there are good reasons to suspect -- that the spontaneous garbage collection will occur too late or not at all\&. Improper use may seriously degrade system performance\&.
.RE
.LP
.nf

.B
garbage_collect(Pid) -> GCResult
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid()
.br
GCResult = boolean()
.br
.RE
.RE
.RS
.LP
The same as \fB\fIgarbage_collect(Pid, [])\fR\&\fR\&\&.
.RE
.LP
.nf

.B
garbage_collect(Pid, OptionList) -> GCResult | async
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid()
.br
RequestId = term()
.br
Option = {async, RequestId}
.br
OptionList = [Option]
.br
GCResult = boolean()
.br
.RE
.RE
.RS
.LP
Garbage collect the node local process identified by \fIPid\fR\&\&.
.LP
Currently available \fIOption\fR\&s:
.RS 2
.TP 2
.B
\fI{async, RequestId}\fR\&:
 The \fIgarbage_collect/2\fR\& function will return the value \fIasync\fR\& immediately after the request has been sent\&. When the request has been processed, the process that called this function will be passed a message on the form:
.br
\fI{garbage_collect, RequestId, GCResult}\fR\&\&. 
.RE
.LP
If \fIPid\fR\& equals \fIself()\fR\&, and no \fIasync\fR\& option has been passed, the garbage collection will be performed at once, i\&.e\&. the same as calling \fBgarbage_collect/0\fR\&\&. In all other cases a request for garbage collection will be sent to the process identified by \fIPid\fR\&, and will be handled when appropriate\&. If no \fIasync\fR\& option has been passed, the caller will block until \fIGCResult\fR\& is available and can be returned\&.
.LP
\fIGCResult\fR\& informs about the result of the garbage collection request:
.RS 2
.TP 2
.B
\fItrue\fR\&:
 The process identified by \fIPid\fR\& has been garbage collected\&. 
.TP 2
.B
\fIfalse\fR\&:
 No garbage collection was performed\&. This since the the process identified by \fIPid\fR\& terminated before the request could be satisfied\&. 
.RE
.LP
Note that the same caveats as for \fBgarbage_collect/0\fR\& apply\&.
.LP
Failures:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
 If \fIPid\fR\& is not a node local process identifier\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If \fIOptionList\fR\& is not a valid list of options\&. 
.RE
.RE
.LP
.nf

.B
get() -> [{Key, Val}]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Val = term()
.br
.RE
.RE
.RS
.LP
Returns the process dictionary as a list of \fI{Key, Val}\fR\& tuples\&.
.LP
.nf

> put(key1, merry),
put(key2, lambs),
put(key3, {are, playing}),
get()\&.
[{key1,merry},{key2,lambs},{key3,{are,playing}}]
.fi
.RE
.LP
.nf

.B
get(Key) -> Val | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Val = term()
.br
.RE
.RE
.RS
.LP
Returns the value \fIVal\fR\&associated with \fIKey\fR\& in the process dictionary, or \fIundefined\fR\& if \fIKey\fR\& does not exist\&.
.LP
.nf

> put(key1, merry),
put(key2, lambs),
put({any, [valid, term]}, {are, playing}),
get({any, [valid, term]})\&.
{are,playing}
.fi
.RE
.LP
.nf

.B
erlang:get_cookie() -> Cookie | nocookie
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cookie = atom()
.br
.RE
.RE
.RS
.LP
Returns the magic cookie of the local node, if the node is alive; otherwise the atom \fInocookie\fR\&\&.
.RE
.LP
.nf

.B
get_keys(Val) -> [Key]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Val = Key = term()
.br
.RE
.RE
.RS
.LP
Returns a list of keys which are associated with the value \fIVal\fR\& in the process dictionary\&.
.LP
.nf

> put(mary, {1, 2}),
put(had, {1, 2}),
put(a, {1, 2}),
put(little, {1, 2}),
put(dog, {1, 3}),
put(lamb, {1, 2}),
get_keys({1, 2})\&.
[mary,had,a,little,lamb]
.fi
.RE
.LP
.nf

.B
erlang:get_stacktrace() -> [stack_item()]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
.nf
\fBstack_item()\fR\& = 
.br
    {Module :: module(),
.br
     Function :: atom(),
.br
     Arity :: arity() | (Args :: [term()]),
.br
     Location ::
.br
         [{file, Filename :: string()} |
.br
          {line, Line :: integer() >= 1}]}
.fi
.br
.RE
.RE
.RS
.LP
Get the call stack back-trace (\fIstacktrace\fR\&) of the last exception in the calling process as a list of \fI{Module,Function,Arity,Location}\fR\& tuples\&. The \fIArity\fR\& field in the first tuple may be the argument list of that function call instead of an arity integer, depending on the exception\&.
.LP
If there has not been any exceptions in a process, the stacktrace is \fI[]\fR\&\&. After a code change for the process, the stacktrace may also be reset to []\&.
.LP
The stacktrace is the same data as the \fIcatch\fR\& operator returns, for example:
.LP
\fI{\&'EXIT\&',{badarg,Stacktrace}} = catch abs(x)\fR\&
.LP
\fILocation\fR\& is a (possibly empty) list of two-tuples that may indicate the location in the source code of the function\&. The first element is an atom that describes the type of information in the second element\&. Currently the following items may occur:
.RS 2
.TP 2
.B
\fIfile\fR\&:
The second element of the tuple is a string (list of characters) representing the filename of the source file of the function\&.
.TP 2
.B
\fIline\fR\&:
The second element of the tuple is the line number (an integer greater than zero) in the source file where the exception occurred or the function was called\&.
.RE
.LP
See also \fBerlang:error/1\fR\& and \fBerlang:error/2\fR\&\&.
.RE
.LP
.nf

.B
group_leader() -> pid()
.br
.fi
.br
.RS
.LP
Returns the pid of the group leader for the process which evaluates the function\&.
.LP
Every process is a member of some process group and all groups have a \fIgroup leader\fR\&\&. All IO from the group is channeled to the group leader\&. When a new process is spawned, it gets the same group leader as the spawning process\&. Initially, at system start-up, \fIinit\fR\& is both its own group leader and the group leader of all processes\&.
.RE
.LP
.nf

.B
group_leader(GroupLeader, Pid) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
GroupLeader = Pid = pid()
.br
.RE
.RE
.RS
.LP
Sets the group leader of \fIPid\fR\& to \fIGroupLeader\fR\&\&. Typically, this is used when a processes started from a certain shell should have another group leader than \fIinit\fR\&\&.
.LP
See also \fBgroup_leader/0\fR\&\&.
.RE
.LP
.nf

.B
halt() -> no_return()
.br
.fi
.br
.RS
.LP
The same as \fB\fIhalt(0, [])\fR\&\fR\&\&.
.LP
.nf

> halt()\&.
os_prompt% 
.fi
.RE
.LP
.nf

.B
halt(Status) -> no_return()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Status = integer() >= 0 | abort | string()
.br
.RE
.RE
.RS
.LP
The same as \fB\fIhalt(Status, [])\fR\&\fR\&\&.
.LP
.nf

> halt(17)\&.
os_prompt% echo $?
17
os_prompt% 
.fi
.RE
.LP
.nf

.B
halt(Status, Options) -> no_return()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Status = integer() >= 0 | abort | string()
.br
Options = [Option]
.br
Option = {flush, boolean()}
.br
.RE
.RE
.RS
.LP
\fIStatus\fR\& must be a non-negative integer, a string, or the atom \fIabort\fR\&\&. Halts the Erlang runtime system\&. Has no return value\&. Depending on \fIStatus\fR\&:
.RS 2
.TP 2
.B
integer():
The runtime system exits with the integer value \fIStatus\fR\& as status code to the calling environment (operating system)\&. 
.TP 2
.B
string():
An erlang crash dump is produced with \fIStatus\fR\& as slogan, and then the runtime system exits with status code \fI1\fR\&\&. 
.TP 2
.B
\fIabort\fR\&:
 The runtime system aborts producing a core dump, if that is enabled in the operating system\&. 
.RE
.LP
Note that on many platforms, only the status codes 0-255 are supported by the operating system\&.
.LP
For integer \fIStatus\fR\& the Erlang runtime system closes all ports and allows async threads to finish their operations before exiting\&. To exit without such flushing use \fIOption\fR\& as \fI{flush,false}\fR\&\&.
.LP
For statuses \fIstring()\fR\& and \fIabort\fR\& the \fIflush\fR\& option is ignored and flushing is \fInot\fR\& done\&.
.RE
.LP
.nf

.B
erlang:hash(Term, Range) -> integer() >= 1
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
Range = integer() >= 1
.br
.RE
.RE
.RS
.LP
Returns a hash value for \fITerm\fR\& within the range \fI1\&.\&.Range\fR\&\&. The allowed range is 1\&.\&.2^27-1\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is deprecated as the hash value may differ on different architectures\&. Also the hash values for integer terms larger than 2^27 as well as large binaries are very poor\&. The BIF is retained for backward compatibility reasons (it may have been used to hash records into a file), but all new code should use one of the BIFs \fIerlang:phash/2\fR\& or \fIerlang:phash2/1,2\fR\& instead\&.

.RE
.LP
.nf

.B
hd(List) -> term()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
List = [term(), \&.\&.\&.]
.br
.RE
.RE
.RS
.LP
Returns the head of \fIList\fR\&, that is, the first element\&.
.LP
.nf

> hd([1,2,3,4,5])\&.
1
.fi
.LP
Allowed in guard tests\&.
.LP
Failure: \fIbadarg\fR\& if \fIList\fR\& is the empty list []\&.
.RE
.LP
.nf

.B
erlang:hibernate(Module, Function, Args) -> no_return()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Function = atom()
.br
Args = [term()]
.br
.RE
.RE
.RS
.LP
Puts the calling process into a wait state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future\&.
.LP
The process will be awaken when a message is sent to it, and control will resume in \fIModule:Function\fR\& with the arguments given by \fIArgs\fR\& with the call stack emptied, meaning that the process will terminate when that function returns\&. Thus \fIerlang:hibernate/3\fR\& will never return to its caller\&.
.LP
If the process has any message in its message queue, the process will be awaken immediately in the same way as described above\&.
.LP
In more technical terms, what \fIerlang:hibernate/3\fR\& does is the following\&. It discards the call stack for the process\&. Then it garbage collects the process\&. After the garbage collection, all live data is in one continuous heap\&. The heap is then shrunken to the exact same size as the live data which it holds (even if that size is less than the minimum heap size for the process)\&.
.LP
If the size of the live data in the process is less than the minimum heap size, the first garbage collection occurring after the process has been awaken will ensure that the heap size is changed to a size not smaller than the minimum heap size\&.
.LP
Note that emptying the call stack means that any surrounding \fIcatch\fR\& is removed and has to be re-inserted after hibernation\&. One effect of this is that processes started using \fIproc_lib\fR\& (also indirectly, such as \fIgen_server\fR\& processes), should use \fBproc_lib:hibernate/3\fR\& instead to ensure that the exception handler continues to work when the process wakes up\&.
.RE
.LP
.nf

.B
erlang:insert_element(Index, Tuple1, Term) -> Tuple2
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Index = integer() >= 1
.br
.RS 2
1\&.\&.tuple_size(Tuple1) + 1
.RE
Tuple1 = Tuple2 = tuple()
.br
Term = term()
.br
.RE
.RE
.RS
.LP
Returns a new tuple with element \fITerm\fR\& insert at position \fIIndex\fR\& in tuple \fITuple1\fR\&\&. All elements from position \fIIndex\fR\& and upwards are subsequently pushed one step higher in the new tuple \fITuple2\fR\&\&.
.LP
.nf

> erlang:insert_element(2, {one, two, three}, new)\&.
{one,new,two,three}
.fi
.RE
.LP
.nf

.B
integer_to_binary(Integer) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Integer = integer()
.br
.RE
.RE
.RS
.LP
Returns a binary which corresponds to the text representation of \fIInteger\fR\&\&.
.LP
.nf

> integer_to_binary(77)\&.
<<"77">>
.fi
.RE
.LP
.nf

.B
integer_to_binary(Integer, Base) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Integer = integer()
.br
Base = 2\&.\&.36
.br
.RE
.RE
.RS
.LP
Returns a binary which corresponds to the text representation of \fIInteger\fR\& in base \fIBase\fR\&\&.
.LP
.nf

> integer_to_binary(1023, 16)\&.
<<"3FF">>
.fi
.RE
.LP
.nf

.B
integer_to_list(Integer) -> string()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Integer = integer()
.br
.RE
.RE
.RS
.LP
Returns a string which corresponds to the text representation of \fIInteger\fR\&\&.
.LP
.nf

> integer_to_list(77)\&.
"77"
.fi
.RE
.LP
.nf

.B
integer_to_list(Integer, Base) -> string()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Integer = integer()
.br
Base = 2\&.\&.36
.br
.RE
.RE
.RS
.LP
Returns a string which corresponds to the text representation of \fIInteger\fR\& in base \fIBase\fR\&\&.
.LP
.nf

> integer_to_list(1023, 16)\&.
"3FF"
.fi
.RE
.LP
.nf

.B
iolist_to_binary(IoListOrBinary) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
IoListOrBinary = iolist() | binary()
.br
.RE
.RE
.RS
.LP
Returns a binary which is made from the integers and binaries in \fIIoListOrBinary\fR\&\&.
.LP
.nf

> Bin1 = <<1,2,3>>\&.
<<1,2,3>>
> Bin2 = <<4,5>>\&.
<<4,5>>
> Bin3 = <<6>>\&.
<<6>>
> iolist_to_binary([Bin1,1,[2,3,Bin2],4|Bin3])\&.
<<1,2,3,1,2,3,4,5,4,6>>
.fi
.RE
.LP
.nf

.B
iolist_size(Item) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Item = iolist() | binary()
.br
.RE
.RE
.RS
.LP
Returns an integer which is the size in bytes of the binary that would be the result of \fIiolist_to_binary(Item)\fR\&\&.
.LP
.nf

> iolist_size([1,2|<<3,4>>])\&.
4
.fi
.RE
.LP
.nf

.B
is_alive() -> boolean()
.br
.fi
.br
.RS
.LP
Returns \fItrue\fR\& if the local node is alive; that is, if the node can be part of a distributed system\&. Otherwise, it returns \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
is_atom(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is an atom; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_binary(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a binary; otherwise returns \fIfalse\fR\&\&.
.LP
A binary always contains a complete number of bytes\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_bitstring(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a bitstring (including a binary); otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_boolean(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is either the atom \fItrue\fR\& or the atom \fIfalse\fR\& (i\&.e\&. a boolean); otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
erlang:is_builtin(Module, Function, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Function = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIModule:Function/Arity\fR\& is a BIF implemented in C; otherwise returns \fIfalse\fR\&\&. This BIF is useful for builders of cross reference tools\&.
.RE
.LP
.nf

.B
is_float(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a floating point number; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_function(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a fun; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_function(Term, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a fun that can be applied with \fIArity\fR\& number of arguments; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_integer(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is an integer; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_list(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a list with zero or more elements; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_map(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a map; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_number(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is either an integer or a floating point number; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_pid(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a pid (process identifier); otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_port(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a port identifier; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_process_alive(Pid) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid()
.br
.RE
.RE
.RS
.LP
\fIPid\fR\& must refer to a process at the local node\&. Returns \fItrue\fR\& if the process exists and is alive, that is, is not exiting and has not exited\&. Otherwise, returns \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
is_record(Term, RecordTag) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
RecordTag = atom()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a tuple and its first element is \fIRecordTag\fR\&\&. Otherwise, returns \fIfalse\fR\&\&.
.LP

.RS -4
.B
Note:
.RE
Normally the compiler treats calls to \fIis_record/2\fR\& specially\&. It emits code to verify that \fITerm\fR\& is a tuple, that its first element is \fIRecordTag\fR\&, and that the size is correct\&. However, if the \fIRecordTag\fR\& is not a literal atom, the \fIis_record/2\fR\& BIF will be called instead and the size of the tuple will not be verified\&.

.LP
Allowed in guard tests, if \fIRecordTag\fR\& is a literal atom\&.
.RE
.LP
.nf

.B
is_record(Term, RecordTag, Size) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
RecordTag = atom()
.br
Size = integer() >= 0
.br
.RE
.RE
.RS
.LP
\fIRecordTag\fR\& must be an atom\&. Returns \fItrue\fR\& if \fITerm\fR\& is a tuple, its first element is \fIRecordTag\fR\&, and its size is \fISize\fR\&\&. Otherwise, returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests, provided that \fIRecordTag\fR\& is a literal atom and \fISize\fR\& is a literal integer\&.
.LP

.RS -4
.B
Note:
.RE
This BIF is documented for completeness\&. In most cases \fIis_record/2\fR\& should be used\&.

.RE
.LP
.nf

.B
is_reference(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a reference; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
is_tuple(Term) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fITerm\fR\& is a tuple; otherwise returns \fIfalse\fR\&\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
length(List) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
List = [term()]
.br
.RE
.RE
.RS
.LP
Returns the length of \fIList\fR\&\&.
.LP
.nf

> length([1,2,3,4,5,6,7,8,9])\&.
9
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
link(PidOrPort) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
PidOrPort = pid() | port()
.br
.RE
.RE
.RS
.LP
Creates a link between the calling process and another process (or port) \fIPidOrPort\fR\&, if there is not such a link already\&. If a process attempts to create a link to itself, nothing is done\&. Returns \fItrue\fR\&\&.
.LP
If \fIPidOrPort\fR\& does not exist, the behavior of the BIF depends on if the calling process is trapping exits or not (see \fBprocess_flag/2\fR\&):
.RS 2
.TP 2
*
If the calling process is not trapping exits, and checking \fIPidOrPort\fR\& is cheap -- that is, if \fIPidOrPort\fR\& is local -- \fIlink/1\fR\& fails with reason \fInoproc\fR\&\&.
.LP
.TP 2
*
Otherwise, if the calling process is trapping exits, and/or \fIPidOrPort\fR\& is remote, \fIlink/1\fR\& returns \fItrue\fR\&, but an exit signal with reason \fInoproc\fR\& is sent to the calling process\&.
.LP
.RE

.RE
.LP
.nf

.B
list_to_atom(String) -> atom()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
.RE
.RE
.RS
.LP
Returns the atom whose text representation is \fIString\fR\&\&.
.LP
\fIString\fR\& may only contain ISO-latin-1 characters (i\&.e\&. numbers below 256) as the current implementation does not allow unicode characters >= 256 in atoms\&. For more information on Unicode support in atoms see \fBnote on UTF-8 encoded atoms\fR\& in the chapter about the external term format in the ERTS User\&'s Guide\&.
.LP
.nf

> list_to_atom("Erlang")\&.
'Erlang'
.fi
.RE
.LP
.nf

.B
list_to_binary(IoList) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
IoList = iolist()
.br
.RE
.RE
.RS
.LP
Returns a binary which is made from the integers and binaries in \fIIoList\fR\&\&.
.LP
.nf

> Bin1 = <<1,2,3>>\&.
<<1,2,3>>
> Bin2 = <<4,5>>\&.
<<4,5>>
> Bin3 = <<6>>\&.
<<6>>
> list_to_binary([Bin1,1,[2,3,Bin2],4|Bin3])\&.
<<1,2,3,1,2,3,4,5,4,6>>
.fi
.RE
.LP
.nf

.B
list_to_bitstring(BitstringList) -> bitstring()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
BitstringList = \fBbitstring_list()\fR\&
.br
.nf
\fBbitstring_list()\fR\& = 
.br
    maybe_improper_list(byte() | bitstring() | \fBbitstring_list()\fR\&,
.br
                        bitstring() | [])
.fi
.br
.RE
.RE
.RS
.LP
Returns a bitstring which is made from the integers and bitstrings in \fIBitstringList\fR\&\&. (The last tail in \fIBitstringList\fR\& is allowed to be a bitstring\&.)
.LP
.nf

> Bin1 = <<1,2,3>>\&.
<<1,2,3>>
> Bin2 = <<4,5>>\&.
<<4,5>>
> Bin3 = <<6,7:4,>>\&.
<<6>>
> list_to_bitstring([Bin1,1,[2,3,Bin2],4|Bin3])\&.
<<1,2,3,1,2,3,4,5,4,6,7:46>>
.fi
.RE
.LP
.nf

.B
list_to_existing_atom(String) -> atom()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
.RE
.RE
.RS
.LP
Returns the atom whose text representation is \fIString\fR\&, but only if there already exists such atom\&.
.LP
Failure: \fIbadarg\fR\& if there does not already exist an atom whose text representation is \fIString\fR\&\&.
.RE
.LP
.nf

.B
list_to_float(String) -> float()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
.RE
.RE
.RS
.LP
Returns the float whose text representation is \fIString\fR\&\&.
.LP
.nf

> list_to_float("2\&.2017764e+0")\&.
2.2017764
.fi
.LP
Failure: \fIbadarg\fR\& if \fIString\fR\& contains a bad representation of a float\&.
.RE
.LP
.nf

.B
list_to_integer(String) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
.RE
.RE
.RS
.LP
Returns an integer whose text representation is \fIString\fR\&\&.
.LP
.nf

> list_to_integer("123")\&.
123
.fi
.LP
Failure: \fIbadarg\fR\& if \fIString\fR\& contains a bad representation of an integer\&.
.RE
.LP
.nf

.B
list_to_integer(String, Base) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
Base = 2\&.\&.36
.br
.RE
.RE
.RS
.LP
Returns an integer whose text representation in base \fIBase\fR\& is \fIString\fR\&\&.
.LP
.nf

> list_to_integer("3FF", 16)\&.
1023
.fi
.LP
Failure: \fIbadarg\fR\& if \fIString\fR\& contains a bad representation of an integer\&.
.RE
.LP
.nf

.B
list_to_pid(String) -> pid()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
.RE
.RE
.RS
.LP
Returns a pid whose text representation is \fIString\fR\&\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for debugging and for use in the Erlang operating system\&. It should not be used in application programs\&.

.LP
.nf

> list_to_pid("<0\&.4\&.1>")\&.
<0.4.1>
.fi
.LP
Failure: \fIbadarg\fR\& if \fIString\fR\& contains a bad representation of a pid\&.
.RE
.LP
.nf

.B
list_to_tuple(List) -> tuple()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
List = [term()]
.br
.RE
.RE
.RS
.LP
Returns a tuple which corresponds to \fIList\fR\&\&. \fIList\fR\& can contain any Erlang terms\&.
.LP
.nf

> list_to_tuple([share, [\&'Ericsson_B\&', 163]])\&.
{share, ['Ericsson_B', 163]}
.fi
.RE
.LP
.nf

.B
load_module(Module, Binary) -> {module, Module} | {error, Reason}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Binary = binary()
.br
Reason = badfile | not_purged | on_load
.br
.RE
.RE
.RS
.LP
If \fIBinary\fR\& contains the object code for the module \fIModule\fR\&, this BIF loads that object code\&. Also, if the code for the module \fIModule\fR\& already exists, all export references are replaced so they point to the newly loaded code\&. The previously loaded code is kept in the system as old code, as there may still be processes which are executing that code\&. It returns either \fI{module, Module}\fR\&, or \fI{error, Reason}\fR\& if loading fails\&. \fIReason\fR\& is one of the following:
.RS 2
.TP 2
.B
\fIbadfile\fR\&:
The object code in \fIBinary\fR\& has an incorrect format \fIor\fR\& the object code contains code for another module than \fIModule\fR\&\&.
.TP 2
.B
\fInot_purged\fR\&:
\fIBinary\fR\& contains a module which cannot be loaded because old code for this module already exists\&.
.RE
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for the code server (see \fBcode(3)\fR\&) and should not be used elsewhere\&.

.RE
.LP
.nf

.B
erlang:load_nif(Path, LoadInfo) -> ok | Error
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Path = string()
.br
LoadInfo = term()
.br
Error = {error, {Reason, Text :: string()}}
.br
Reason = load_failed
.br
       | bad_lib
.br
       | load
.br
       | reload
.br
       | upgrade
.br
       | old_code
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Note:
.RE
In releases older than OTP R14B, NIFs were an experimental feature\&. Versions of OTP older than R14B might have different and possibly incompatible NIF semantics and interfaces\&. For example, in R13B03 the return value on failure was \fI{error,Reason,Text}\fR\&\&.

.LP
Loads and links a dynamic library containing native implemented functions (NIFs) for a module\&. \fIPath\fR\& is a file path to the sharable object/dynamic library file minus the OS-dependent file extension (\&.so for Unix and \&.dll for Windows)\&. See \fBerl_nif\fR\& on how to implement a NIF library\&.
.LP
\fILoadInfo\fR\& can be any term\&. It will be passed on to the library as part of the initialization\&. A good practice is to include a module version number to support future code upgrade scenarios\&.
.LP
The call to \fIload_nif/2\fR\& must be made \fIdirectly\fR\& from the Erlang code of the module that the NIF library belongs to\&.
.LP
It returns either \fIok\fR\&, or \fI{error,{Reason,Text}}\fR\& if loading fails\&. \fIReason\fR\& is one of the atoms below, while \fIText\fR\& is a human readable string that may give some more information about the failure\&.
.RS 2
.TP 2
.B
\fIload_failed\fR\&:
The OS failed to load the NIF library\&.
.TP 2
.B
\fIbad_lib\fR\&:
The library did not fulfil the requirements as a NIF library of the calling module\&.
.TP 2
.B
\fIload | reload | upgrade\fR\&:
The corresponding library callback was not successful\&.
.TP 2
.B
\fIold_code\fR\&:
The call to \fIload_nif/2\fR\& was made from the old code of a module that has been upgraded\&. This is not allowed\&.
.RE
.RE
.LP
.nf

.B
erlang:loaded() -> [Module]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
.RE
.RE
.RS
.LP
Returns a list of all loaded Erlang modules (current and/or old code), including preloaded modules\&.
.LP
See also \fBcode(3)\fR\&\&.
.RE
.LP
.nf

.B
erlang:localtime() -> DateTime
.br
.fi
.br
.RS
.LP
Types:

.RS 3
DateTime = \fBcalendar:datetime()\fR\&
.br
.RE
.RE
.RS
.LP
Returns the current local date and time \fI{{Year, Month, Day}, {Hour, Minute, Second}}\fR\&\&.
.LP
The time zone and daylight saving time correction depend on the underlying OS\&.
.LP
.nf

> erlang:localtime()\&.
{{1996,11,6},{14,45,17}}
.fi
.RE
.LP
.nf

.B
erlang:localtime_to_universaltime(Localtime) -> Universaltime
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Localtime = Universaltime = \fBcalendar:datetime()\fR\&
.br
.RE
.RE
.RS
.LP
Converts local date and time to Universal Time Coordinated (UTC), if this is supported by the underlying OS\&. Otherwise, no conversion is done and \fILocaltime\fR\& is returned\&.
.LP
.nf

> erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}})\&.
{{1996,11,6},{13,45,17}}
.fi
.LP
Failure: \fIbadarg\fR\& if \fILocaltime\fR\& does not denote a valid date and time\&.
.RE
.LP
.nf

.B
erlang:localtime_to_universaltime(Localtime, IsDst) ->
.B
                                     Universaltime
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Localtime = Universaltime = \fBcalendar:datetime()\fR\&
.br
IsDst = true | false | undefined
.br
.RE
.RE
.RS
.LP
Converts local date and time to Universal Time Coordinated (UTC) just like \fIerlang:localtime_to_universaltime/1\fR\&, but the caller decides if daylight saving time is active or not\&.
.LP
If \fIIsDst == true\fR\& the \fILocaltime\fR\& is during daylight saving time, if \fIIsDst == false\fR\& it is not, and if \fIIsDst == undefined\fR\& the underlying OS may guess, which is the same as calling \fIerlang:localtime_to_universaltime(Localtime)\fR\&\&.
.LP
.nf

> erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, true)\&.
{{1996,11,6},{12,45,17}}
> erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, false)\&.
{{1996,11,6},{13,45,17}}
> erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, undefined)\&.
{{1996,11,6},{13,45,17}}
.fi
.LP
Failure: \fIbadarg\fR\& if \fILocaltime\fR\& does not denote a valid date and time\&.
.RE
.LP
.nf

.B
make_ref() -> reference()
.br
.fi
.br
.RS
.LP
Returns an almost unique reference\&.
.LP
The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes\&.
.LP
.nf

> make_ref()\&.
#Ref<0.0.0.135>
.fi
.RE
.LP
.nf

.B
erlang:make_tuple(Arity, InitialValue) -> tuple()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Arity = arity()
.br
InitialValue = term()
.br
.RE
.RE
.RS
.LP
Returns a new tuple of the given \fIArity\fR\&, where all elements are \fIInitialValue\fR\&\&.
.LP
.nf

> erlang:make_tuple(4, [])\&.
{[],[],[],[]}
.fi
.RE
.LP
.nf

.B
erlang:make_tuple(Arity, DefaultValue, InitList) -> tuple()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Arity = arity()
.br
DefaultValue = term()
.br
InitList = [{Position :: integer() >= 1, term()}]
.br
.RE
.RE
.RS
.LP
\fIerlang:make_tuple\fR\& first creates a tuple of size \fIArity\fR\& where each element has the value \fIDefaultValue\fR\&\&. It then fills in values from \fIInitList\fR\&\&. Each list element in \fIInitList\fR\& must be a two-tuple where the first element is a position in the newly created tuple and the second element is any term\&. If a position occurs more than once in the list, the term corresponding to last occurrence will be used\&.
.LP
.nf

> erlang:make_tuple(5, [], [{2,ignored},{5,zz},{2,aa}])\&.
{{[],aa,[],[],zz}
.fi
.RE
.LP
.nf

.B
map_size(Map) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Map = map()
.br
.RE
.RE
.RS
.LP
Returns an integer which is the number of key-value pairs in \fIMap\fR\&\&.
.LP
.nf

> map_size(#{a=>1, b=>2, c=>3})\&.
3
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
max(Term1, Term2) -> Maximum
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term1 = Term2 = Maximum = term()
.br
.RE
.RE
.RS
.LP
Return the largest of \fITerm1\fR\& and \fITerm2\fR\&; if the terms compare equal, \fITerm1\fR\& will be returned\&.
.RE
.LP
.nf

.B
erlang:md5(Data) -> Digest
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Data = iodata()
.br
Digest = binary()
.br
.RE
.RE
.RS
.LP
Computes an \fIMD5\fR\& message digest from \fIData\fR\&, where the length of the digest is 128 bits (16 bytes)\&. \fIData\fR\& is a binary or a list of small integers and binaries\&.
.LP
See The MD5 Message Digest Algorithm (RFC 1321) for more information about MD5\&.
.LP

.RS -4
.B
Warning:
.RE
The MD5 Message Digest Algorithm is \fInot\fR\& considered safe for code-signing or software integrity purposes\&.

.RE
.LP
.nf

.B
erlang:md5_final(Context) -> Digest
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Context = Digest = binary()
.br
.RE
.RE
.RS
.LP
Finishes the update of an MD5 \fIContext\fR\& and returns the computed \fIMD5\fR\& message digest\&.
.RE
.LP
.nf

.B
erlang:md5_init() -> Context
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Context = binary()
.br
.RE
.RE
.RS
.LP
Creates an MD5 context, to be used in subsequent calls to \fImd5_update/2\fR\&\&.
.RE
.LP
.nf

.B
erlang:md5_update(Context, Data) -> NewContext
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Context = binary()
.br
Data = iodata()
.br
NewContext = binary()
.br
.RE
.RE
.RS
.LP
Updates an MD5 \fIContext\fR\& with \fIData\fR\&, and returns a \fINewContext\fR\&\&.
.RE
.LP
.nf

.B
erlang:memory() -> [{Type, Size}]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = \fBmemory_type()\fR\&
.br
Size = integer() >= 0
.br
.nf
\fBmemory_type()\fR\& = total
.br
              | processes
.br
              | processes_used
.br
              | system
.br
              | atom
.br
              | atom_used
.br
              | binary
.br
              | code
.br
              | ets
.br
              | low
.br
              | maximum
.fi
.br
.RE
.RE
.RS
.LP
Returns a list containing information about memory dynamically allocated by the Erlang emulator\&. Each element of the list is a tuple \fI{Type, Size}\fR\&\&. The first element \fIType\fR\&is an atom describing memory type\&. The second element \fISize\fR\&is memory size in bytes\&. A description of each memory type follows:
.RS 2
.TP 2
.B
\fItotal\fR\&:
The total amount of memory currently allocated, which is the same as the sum of memory size for \fIprocesses\fR\& and \fIsystem\fR\&\&.
.TP 2
.B
\fIprocesses\fR\&:
The total amount of memory currently allocated by the Erlang processes\&.
.TP 2
.B
\fIprocesses_used\fR\&:
The total amount of memory currently used by the Erlang processes\&.
.RS 2
.LP
This memory is part of the memory presented as \fIprocesses\fR\& memory\&.
.RE
.TP 2
.B
\fIsystem\fR\&:
The total amount of memory currently allocated by the emulator that is not directly related to any Erlang process\&.
.RS 2
.LP
Memory presented as \fIprocesses\fR\& is not included in this memory\&.
.RE
.TP 2
.B
\fIatom\fR\&:
The total amount of memory currently allocated for atoms\&.
.RS 2
.LP
This memory is part of the memory presented as \fIsystem\fR\& memory\&.
.RE
.TP 2
.B
\fIatom_used\fR\&:
The total amount of memory currently used for atoms\&.
.RS 2
.LP
This memory is part of the memory presented as \fIatom\fR\& memory\&.
.RE
.TP 2
.B
\fIbinary\fR\&:
The total amount of memory currently allocated for binaries\&.
.RS 2
.LP
This memory is part of the memory presented as \fIsystem\fR\& memory\&.
.RE
.TP 2
.B
\fIcode\fR\&:
The total amount of memory currently allocated for Erlang code\&.
.RS 2
.LP
This memory is part of the memory presented as \fIsystem\fR\& memory\&.
.RE
.TP 2
.B
\fIets\fR\&:
The total amount of memory currently allocated for ets tables\&.
.RS 2
.LP
This memory is part of the memory presented as \fIsystem\fR\& memory\&.
.RE
.TP 2
.B
\fIlow\fR\&:
Only on 64-bit halfword emulator\&.
.RS 2
.LP
The total amount of memory allocated in low memory areas that are restricted to less than 4 Gb even though the system may have more physical memory\&.
.RE
.RS 2
.LP
May be removed in future releases of halfword emulator\&.
.RE
.TP 2
.B
\fImaximum\fR\&:
The maximum total amount of memory allocated since the emulator was started\&.
.RS 2
.LP
This tuple is only present when the emulator is run with instrumentation\&.
.RE
.RS 2
.LP
For information on how to run the emulator with instrumentation see \fBinstrument(3)\fR\& and/or \fBerl(1)\fR\&\&.
.RE
.RE
.LP

.RS -4
.B
Note:
.RE
The \fIsystem\fR\& value is not complete\&. Some allocated memory that should be part of the \fIsystem\fR\& value are not\&.
.LP
When the emulator is run with instrumentation, the \fIsystem\fR\& value is more accurate, but memory directly allocated by \fImalloc\fR\& (and friends) are still not part of the \fIsystem\fR\& value\&. Direct calls to \fImalloc\fR\& are only done from OS specific runtime libraries and perhaps from user implemented Erlang drivers that do not use the memory allocation functions in the driver interface\&.
.LP
Since the \fItotal\fR\& value is the sum of \fIprocesses\fR\& and \fIsystem\fR\& the error in \fIsystem\fR\& will propagate to the \fItotal\fR\& value\&.
.LP
The different amounts of memory that are summed are \fInot\fR\& gathered atomically which also introduce an error in the result\&.

.LP
The different values has the following relation to each other\&. Values beginning with an uppercase letter is not part of the result\&.
.LP
.nf

        total = processes + system
        processes = processes_used + ProcessesNotUsed
        system = atom + binary + code + ets + OtherSystem
        atom = atom_used + AtomNotUsed

        RealTotal = processes + RealSystem
        RealSystem = system + MissedSystem
.fi
.LP
More tuples in the returned list may be added in the future\&.
.LP

.RS -4
.B
Note:
.RE
The \fItotal\fR\& value is supposed to be the total amount of memory dynamically allocated by the emulator\&. Shared libraries, the code of the emulator itself, and the emulator stack(s) are not supposed to be included\&. That is, the \fItotal\fR\& value is \fInot\fR\& supposed to be equal to the total size of all pages mapped to the emulator\&. Furthermore, due to fragmentation and pre-reservation of memory areas, the size of the memory segments which contain the dynamically allocated memory blocks can be substantially larger than the total size of the dynamically allocated memory blocks\&.

.LP

.RS -4
.B
Note:
.RE
Since erts version 5\&.6\&.4 \fIerlang:memory/0\fR\& requires that all \fBerts_alloc(3)\fR\& allocators are enabled (default behaviour)\&.

.LP
Failure:
.RS 2
.TP 2
.B
\fInotsup\fR\&:
 If an \fBerts_alloc(3)\fR\& allocator has been disabled\&. 
.RE
.RE
.LP
.nf

.B
erlang:memory(Type :: memory_type()) -> integer() >= 0
.br
.fi
.br
.nf

.B
erlang:memory(TypeList :: [memory_type()]) ->
.B
                 [{memory_type(), integer() >= 0}]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
.nf
\fBmemory_type()\fR\& = total
.br
              | processes
.br
              | processes_used
.br
              | system
.br
              | atom
.br
              | atom_used
.br
              | binary
.br
              | code
.br
              | ets
.br
              | low
.br
              | maximum
.fi
.br
.RE
.RE
.RS
.LP
Returns the memory size in bytes allocated for memory of type \fIType\fR\&\&. The argument can also be given as a list of \fImemory_type()\fR\& atoms, in which case a corresponding list of \fI{memory_type(), Size :: integer >= 0}\fR\& tuples is returned\&.
.LP

.RS -4
.B
Note:
.RE
Since erts version 5\&.6\&.4 \fIerlang:memory/1\fR\& requires that all \fBerts_alloc(3)\fR\& allocators are enabled (default behaviour)\&.

.LP
Failures:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
 If \fIType\fR\& is not one of the memory types listed in the documentation of \fBerlang:memory/0\fR\&\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If \fImaximum\fR\& is passed as \fIType\fR\& and the emulator is not run in instrumented mode\&. 
.TP 2
.B
\fInotsup\fR\&:
 If an \fBerts_alloc(3)\fR\& allocator has been disabled\&. 
.RE
.LP
See also \fBerlang:memory/0\fR\&\&.
.RE
.LP
.nf

.B
min(Term1, Term2) -> Minimum
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term1 = Term2 = Minimum = term()
.br
.RE
.RE
.RS
.LP
Return the smallest of \fITerm1\fR\& and \fITerm2\fR\&; if the terms compare equal, \fITerm1\fR\& will be returned\&.
.RE
.LP
.nf

.B
module_loaded(Module) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if the module \fIModule\fR\& is loaded, otherwise returns \fIfalse\fR\&\&. It does not attempt to load the module\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for the code server (see \fBcode(3)\fR\&) and should not be used elsewhere\&.

.RE
.LP
.nf

.B
monitor(Type, Item) -> MonitorRef
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = process
.br
Item = pid() | RegName | {RegName, Node}
.br
RegName = module()
.br
Node = node()
.br
MonitorRef = reference()
.br
.RE
.RE
.RS
.LP
The calling process starts monitoring \fIItem\fR\& which is an object of type \fIType\fR\&\&.
.LP
Currently only processes can be monitored, i\&.e\&. the only allowed \fIType\fR\& is \fIprocess\fR\&, but other types may be allowed in the future\&.
.LP
\fIItem\fR\& can be:
.RS 2
.TP 2
.B
\fIpid()\fR\&:
The pid of the process to monitor\&.
.TP 2
.B
\fI{RegName, Node}\fR\&:
A tuple consisting of a registered name of a process and a node name\&. The process residing on the node \fINode\fR\& with the registered name \fIRegName\fR\& will be monitored\&.
.TP 2
.B
\fIRegName\fR\&:
The process locally registered as \fIRegName\fR\& will be monitored\&.
.RE
.LP

.RS -4
.B
Note:
.RE
When a process is monitored by registered name, the process that has the registered name at the time when \fImonitor/2\fR\& is called will be monitored\&. The monitor will not be effected, if the registered name is unregistered\&.

.LP
A \fI\&'DOWN\&'\fR\& message will be sent to the monitoring process if \fIItem\fR\& dies, if \fIItem\fR\& does not exist, or if the connection is lost to the node which \fIItem\fR\& resides on\&. A \fI\&'DOWN\&'\fR\& message has the following pattern:
.LP
.nf

{'DOWN', MonitorRef, Type, Object, Info}
.fi
.LP
where \fIMonitorRef\fR\& and \fIType\fR\& are the same as described above, and:
.RS 2
.TP 2
.B
\fIObject\fR\&:
A reference to the monitored object:
.RS 2
.TP 2
*
the pid of the monitored process, if \fIItem\fR\& was specified as a pid\&.
.LP
.TP 2
*
\fI{RegName, Node}\fR\&, if \fIItem\fR\& was specified as \fI{RegName, Node}\fR\&\&.
.LP
.TP 2
*
\fI{RegName, Node}\fR\&, if \fIItem\fR\& was specified as \fIRegName\fR\&\&. \fINode\fR\& will in this case be the name of the local node (\fInode()\fR\&)\&.
.LP
.RE

.TP 2
.B
\fIInfo\fR\&:
Either the exit reason of the process, \fInoproc\fR\& (non-existing process), or \fInoconnection\fR\& (no connection to \fINode\fR\&)\&.
.RE
.LP

.RS -4
.B
Note:
.RE
If/when \fImonitor/2\fR\& is extended (e\&.g\&. to handle other item types than \fIprocess\fR\&), other possible values for \fIObject\fR\&, and \fIInfo\fR\& in the \fI\&'DOWN\&'\fR\& message will be introduced\&.

.LP
The monitoring is turned off either when the \fI\&'DOWN\&'\fR\& message is sent, or when \fBdemonitor/1\fR\& is called\&.
.LP
If an attempt is made to monitor a process on an older node (where remote process monitoring is not implemented or one where remote process monitoring by registered name is not implemented), the call fails with \fIbadarg\fR\&\&.
.LP
Making several calls to \fImonitor/2\fR\& for the same \fIItem\fR\& is not an error; it results in as many, completely independent, monitorings\&.
.LP

.RS -4
.B
Note:
.RE
The format of the \fI\&'DOWN\&'\fR\& message changed in the 5\&.2 version of the emulator (OTP release R9B) for monitor \fIby registered name\fR\&\&. The \fIObject\fR\& element of the \fI\&'DOWN\&'\fR\& message could in earlier versions sometimes be the pid of the monitored process and sometimes be the registered name\&. Now the \fIObject\fR\& element is always a tuple consisting of the registered name and the node name\&. Processes on new nodes (emulator version 5\&.2 or greater) will always get \fI\&'DOWN\&'\fR\& messages on the new format even if they are monitoring processes on old nodes\&. Processes on old nodes will always get \fI\&'DOWN\&'\fR\& messages on the old format\&.

.RE
.LP
.nf

.B
monitor_node(Node, Flag) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
Flag = boolean()
.br
.RE
.RE
.RS
.LP
Monitors the status of the node \fINode\fR\&\&. If \fIFlag\fR\& is \fItrue\fR\&, monitoring is turned on; if \fIFlag\fR\& is \fIfalse\fR\&, monitoring is turned off\&.
.LP
Making several calls to \fImonitor_node(Node, true)\fR\& for the same \fINode\fR\& is not an error; it results in as many, completely independent, monitorings\&.
.LP
If \fINode\fR\& fails or does not exist, the message \fI{nodedown, Node}\fR\& is delivered to the process\&. If a process has made two calls to \fImonitor_node(Node, true)\fR\& and \fINode\fR\& terminates, two \fInodedown\fR\& messages are delivered to the process\&. If there is no connection to \fINode\fR\&, there will be an attempt to create one\&. If this fails, a \fInodedown\fR\& message is delivered\&.
.LP
Nodes connected through hidden connections can be monitored as any other node\&.
.LP
Failure: \fIbadarg\fR\& if the local node is not alive\&.
.RE
.LP
.nf

.B
erlang:monitor_node(Node, Flag, Options) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
Flag = boolean()
.br
Options = [Option]
.br
Option = allow_passive_connect
.br
.RE
.RE
.RS
.LP
Behaves as \fImonitor_node/2\fR\& except that it allows an extra option to be given, namely \fIallow_passive_connect\fR\&\&. The option allows the BIF to wait the normal net connection timeout for the \fImonitored node\fR\& to connect itself, even if it cannot be actively connected from this node (i\&.e\&. it is blocked)\&. The state where this might be useful can only be achieved by using the kernel option \fIdist_auto_connect once\fR\&\&. If that kernel option is not used, the \fIallow_passive_connect\fR\& option has no effect\&.
.LP

.RS -4
.B
Note:
.RE
The \fIallow_passive_connect\fR\& option is used internally and is seldom needed in applications where the network topology and the kernel options in effect is known in advance\&.

.LP
Failure: \fIbadarg\fR\& if the local node is not alive or the option list is malformed\&.
.RE
.LP
.nf

.B
erlang:nif_error(Reason) -> no_return()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Reason = term()
.br
.RE
.RE
.RS
.LP
Works exactly like \fBerlang:error/1\fR\&, but Dialyzer thinks that this BIF will return an arbitrary term\&. When used in a stub function for a NIF to generate an exception when the NIF library is not loaded, Dialyzer will not generate false warnings\&.
.RE
.LP
.nf

.B
erlang:nif_error(Reason, Args) -> no_return()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Reason = term()
.br
Args = [term()]
.br
.RE
.RE
.RS
.LP
Works exactly like \fBerlang:error/2\fR\&, but Dialyzer thinks that this BIF will return an arbitrary term\&. When used in a stub function for a NIF to generate an exception when the NIF library is not loaded, Dialyzer will not generate false warnings\&.
.RE
.LP
.nf

.B
node() -> Node
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
.RE
.RE
.RS
.LP
Returns the name of the local node\&. If the node is not alive, \fInonode@nohost\fR\& is returned instead\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
node(Arg) -> Node
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Arg = pid() | port() | reference()
.br
Node = node()
.br
.RE
.RE
.RS
.LP
Returns the node where \fIArg\fR\& is located\&. \fIArg\fR\& can be a pid, a reference, or a port\&. If the local node is not alive, \fInonode@nohost\fR\& is returned\&.
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
nodes() -> Nodes
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Nodes = [node()]
.br
.RE
.RE
.RS
.LP
Returns a list of all visible nodes in the system, excluding the local node\&. Same as \fInodes(visible)\fR\&\&.
.RE
.LP
.nf

.B
nodes(Arg) -> Nodes
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Arg = NodeType | [NodeType]
.br
NodeType = visible | hidden | connected | this | known
.br
Nodes = [node()]
.br
.RE
.RE
.RS
.LP
Returns a list of nodes according to argument given\&. The result returned when the argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements\&.
.LP
\fINodeType\fR\& can be any of the following:
.RS 2
.TP 2
.B
\fIvisible\fR\&:
Nodes connected to this node through normal connections\&.
.TP 2
.B
\fIhidden\fR\&:
Nodes connected to this node through hidden connections\&.
.TP 2
.B
\fIconnected\fR\&:
All nodes connected to this node\&.
.TP 2
.B
\fIthis\fR\&:
This node\&.
.TP 2
.B
\fIknown\fR\&:
Nodes which are known to this node, i\&.e\&., connected, previously connected, etc\&.
.RE
.LP
Some equalities: \fI[node()] = nodes(this)\fR\&, \fInodes(connected) = nodes([visible, hidden])\fR\&, and \fInodes() = nodes(visible)\fR\&\&.
.LP
If the local node is not alive, \fInodes(this) == nodes(known) == [nonode@nohost]\fR\&, for any other \fIArg\fR\& the empty list [] is returned\&.
.RE
.LP
.nf

.B
now() -> Timestamp
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Timestamp = \fBtimestamp()\fR\&
.br
.nf
\fBtimestamp()\fR\& = 
.br
    {MegaSecs :: integer() >= 0,
.br
     Secs :: integer() >= 0,
.br
     MicroSecs :: integer() >= 0}
.fi
.br
.RE
.RE
.RS
.LP
Returns the tuple \fI{MegaSecs, Secs, MicroSecs}\fR\& which is the elapsed time since 00:00 GMT, January 1, 1970 (zero hour) on the assumption that the underlying OS supports this\&. Otherwise, some other point in time is chosen\&. It is also guaranteed that subsequent calls to this BIF returns continuously increasing values\&. Hence, the return value from \fInow()\fR\& can be used to generate unique time-stamps, and if it is called in a tight loop on a fast machine the time of the node can become skewed\&.
.LP
It can only be used to check the local time of day if the time-zone info of the underlying operating system is properly configured\&.
.LP
If you do not need the return value to be unique and monotonically increasing, use \fBos:timestamp/0\fR\& instead to avoid some overhead\&.
.RE
.LP
.nf

.B
open_port(PortName, PortSettings) -> port()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
PortName = {spawn, Command :: string() | binary()}
.br
         | {spawn_driver, Command :: string() | binary()}
.br
         | {spawn_executable, FileName :: \fBfile:name()\fR\&}
.br
         | {fd,
.br
            In :: integer() >= 0,
.br
            Out :: integer() >= 0}
.br
PortSettings = [Opt]
.br
Opt = {packet, N :: 1 | 2 | 4}
.br
    | stream
.br
    | {line, L :: integer() >= 0}
.br
    | {cd, Dir :: string() | binary()}
.br
    | {env,
.br
       Env :: [{Name :: string(), Val :: string() | false}]}
.br
    | {args, [string() | binary()]}
.br
    | {arg0, string() | binary()}
.br
    | exit_status
.br
    | use_stdio
.br
    | nouse_stdio
.br
    | stderr_to_stdout
.br
    | in
.br
    | out
.br
    | binary
.br
    | eof
.br
    | {parallelism, Boolean :: boolean()}
.br
    | hide
.br
.RE
.RE
.RS
.LP
Returns a port identifier as the result of opening a new Erlang port\&. A port can be seen as an external Erlang process\&.
.LP
The name of the executable as well as the arguments given in \fIcd\fR\&, \fIenv\fR\&, \fIargs\fR\& and \fIarg0\fR\& is subject to Unicode file name translation if the system is running in Unicode file name mode\&. To avoid translation or force i\&.e\&. UTF-8, supply the executable and/or arguments as a binary in the correct encoding\&. See the \fBfile\fR\& module, the \fB file:native_name_encoding/0\fR\& function and the \fBstdlib users guide \fR\& for details\&.
.LP

.RS -4
.B
Note:
.RE
The characters in the name (if given as a list) can only be > 255 if the Erlang VM is started in Unicode file name translation mode, otherwise the name of the executable is limited to the ISO-latin-1 character set\&.

.LP
\fIPortName\fR\& is one of the following:
.RS 2
.TP 2
.B
\fI{spawn, Command}\fR\&:
Starts an external program\&. \fICommand\fR\& is the name of the external program which will be run\&. \fICommand\fR\& runs outside the Erlang work space unless an Erlang driver with the name \fICommand\fR\& is found\&. If found, that driver will be started\&. A driver runs in the Erlang workspace, which means that it is linked with the Erlang runtime system\&.
.RS 2
.LP
When starting external programs on Solaris, the system call \fIvfork\fR\& is used in preference to \fIfork\fR\& for performance reasons, although it has a history of being less robust\&. If there are problems with using \fIvfork\fR\&, setting the environment variable \fIERL_NO_VFORK\fR\& to any value will cause \fIfork\fR\& to be used instead\&.
.RE
.RS 2
.LP
For external programs, the \fIPATH\fR\& is searched (or an equivalent method is used to find programs, depending on operating system)\&. This is done by invoking the shell on certain platforms\&. The first space separated token of the command will be considered as the name of the executable (or driver)\&. This (among other things) makes this option unsuitable for running programs having spaces in file or directory names\&. Use {spawn_executable, Command} instead if spaces in executable file names is desired\&.
.RE
.TP 2
.B
\fI{spawn_driver, Command}\fR\&:
Works like \fI{spawn, Command}\fR\&, but demands the first (space separated) token of the command to be the name of a loaded driver\&. If no driver with that name is loaded, a \fIbadarg\fR\& error is raised\&.
.TP 2
.B
\fI{spawn_executable, FileName}\fR\&:
Works like \fI{spawn, FileName}\fR\&, but only runs external executables\&. The \fIFileName\fR\& in its whole is used as the name of the executable, including any spaces\&. If arguments are to be passed, the \fIargs\fR\& and \fIarg0\fR\& \fIPortSettings\fR\& can be used\&.
.RS 2
.LP
The shell is not usually invoked to start the program, it\&'s executed directly\&. Neither is the \fIPATH\fR\& (or equivalent) searched\&. To find a program in the PATH to execute, use \fBos:find_executable/1\fR\&\&.
.RE
.RS 2
.LP
Only if a shell script or \fI\&.bat\fR\& file is executed, the appropriate command interpreter will implicitly be invoked, but there will still be no command argument expansion or implicit PATH search\&.
.RE
.RS 2
.LP
If the \fIFileName\fR\& cannot be run, an error exception, with the posix error code as the reason, is raised\&. The error reason may differ between operating systems\&. Typically the error \fIenoent\fR\& is raised when one tries to run a program that is not found and \fIeaccess\fR\& is raised when the given file is not executable\&.
.RE
.TP 2
.B
\fI{fd, In, Out}\fR\&:
Allows an Erlang process to access any currently opened file descriptors used by Erlang\&. The file descriptor \fIIn\fR\& can be used for standard input, and the file descriptor \fIOut\fR\& for standard output\&. It is only used for various servers in the Erlang operating system (\fIshell\fR\& and \fIuser\fR\&)\&. Hence, its use is very limited\&.
.RE
.LP
\fIPortSettings\fR\& is a list of settings for the port\&. Valid settings are:
.RS 2
.TP 2
.B
\fI{packet, N}\fR\&:
Messages are preceded by their length, sent in \fIN\fR\& bytes, with the most significant byte first\&. Valid values for \fIN\fR\& are 1, 2, or 4\&.
.TP 2
.B
\fIstream\fR\&:
Output messages are sent without packet lengths\&. A user-defined protocol must be used between the Erlang process and the external object\&.
.TP 2
.B
\fI{line, L}\fR\&:
Messages are delivered on a per line basis\&. Each line (delimited by the OS-dependent newline sequence) is delivered in one single message\&. The message data format is \fI{Flag, Line}\fR\&, where \fIFlag\fR\& is either \fIeol\fR\& or \fInoeol\fR\& and \fILine\fR\& is the actual data delivered (without the newline sequence)\&.
.RS 2
.LP
\fIL\fR\& specifies the maximum line length in bytes\&. Lines longer than this will be delivered in more than one message, with the \fIFlag\fR\& set to \fInoeol\fR\& for all but the last message\&. If end of file is encountered anywhere else than immediately following a newline sequence, the last line will also be delivered with the \fIFlag\fR\& set to \fInoeol\fR\&\&. In all other cases, lines are delivered with \fIFlag\fR\& set to \fIeol\fR\&\&.
.RE
.RS 2
.LP
The \fI{packet, N}\fR\& and \fI{line, L}\fR\& settings are mutually exclusive\&.
.RE
.TP 2
.B
\fI{cd, Dir}\fR\&:
This is only valid for \fI{spawn, Command}\fR\& and \fI{spawn_executable, FileName}\fR\&\&. The external program starts using \fIDir\fR\& as its working directory\&. \fIDir\fR\& must be a string\&.
.TP 2
.B
\fI{env, Env}\fR\&:
This is only valid for \fI{spawn, Command}\fR\& and \fI{spawn_executable, FileName}\fR\&\&. The environment of the started process is extended using the environment specifications in \fIEnv\fR\&\&.
.RS 2
.LP
\fIEnv\fR\& should be a list of tuples \fI{Name, Val}\fR\&, where \fIName\fR\& is the name of an environment variable, and \fIVal\fR\& is the value it is to have in the spawned port process\&. Both \fIName\fR\& and \fIVal\fR\& must be strings\&. The one exception is \fIVal\fR\& being the atom \fIfalse\fR\& (in analogy with \fIos:getenv/1\fR\&), which removes the environment variable\&.
.RE
.TP 2
.B
\fI{args, [ string() | binary() ]}\fR\&:
This option is only valid for \fI{spawn_executable, FileName}\fR\& and specifies arguments to the executable\&. Each argument is given as a separate string and (on Unix) eventually ends up as one element each in the argument vector\&. On other platforms, similar behavior is mimicked\&.
.RS 2
.LP
The arguments are not expanded by the shell prior to being supplied to the executable, most notably this means that file wildcard expansion will not happen\&. Use \fBfilelib:wildcard/1\fR\& to expand wildcards for the arguments\&. Note that even if the program is a Unix shell script, meaning that the shell will ultimately be invoked, wildcard expansion will not happen and the script will be provided with the untouched arguments\&. On Windows(R), wildcard expansion is always up to the program itself, why this isn\&'t an issue\&.
.RE
.RS 2
.LP
Note also that the actual executable name (a\&.k\&.a\&. \fIargv[0]\fR\&) should not be given in this list\&. The proper executable name will automatically be used as argv[0] where applicable\&.
.RE
.RS 2
.LP
If one, for any reason, wants to explicitly set the program name in the argument vector, the \fIarg0\fR\& option can be used\&.
.RE
.TP 2
.B
\fI{arg0, string() | binary()}\fR\&:
This option is only valid for \fI{spawn_executable, FileName}\fR\& and explicitly specifies the program name argument when running an executable\&. This might in some circumstances, on some operating systems, be desirable\&. How the program responds to this is highly system dependent and no specific effect is guaranteed\&.
.TP 2
.B
\fIexit_status\fR\&:
This is only valid for \fI{spawn, Command}\fR\& where \fICommand\fR\& refers to an external program, and for \fI{spawn_executable, FileName}\fR\&\&.
.RS 2
.LP
When the external process connected to the port exits, a message of the form \fI{Port,{exit_status,Status}}\fR\& is sent to the connected process, where \fIStatus\fR\& is the exit status of the external process\&. If the program aborts, on Unix the same convention is used as the shells do (i\&.e\&., 128+signal)\&.
.RE
.RS 2
.LP
If the \fIeof\fR\& option has been given as well, the \fIeof\fR\& message and the \fIexit_status\fR\& message appear in an unspecified order\&.
.RE
.RS 2
.LP
If the port program closes its stdout without exiting, the \fIexit_status\fR\& option will not work\&.
.RE
.TP 2
.B
\fIuse_stdio\fR\&:
This is only valid for \fI{spawn, Command}\fR\& and \fI{spawn_executable, FileName}\fR\&\&. It allows the standard input and output (file descriptors 0 and 1) of the spawned (UNIX) process for communication with Erlang\&.
.TP 2
.B
\fInouse_stdio\fR\&:
The opposite of \fIuse_stdio\fR\&\&. Uses file descriptors 3 and 4 for communication with Erlang\&.
.TP 2
.B
\fIstderr_to_stdout\fR\&:
Affects ports to external programs\&. The executed program gets its standard error file redirected to its standard output file\&. \fIstderr_to_stdout\fR\& and \fInouse_stdio\fR\& are mutually exclusive\&.
.TP 2
.B
\fIoverlapped_io\fR\&:
Affects ports to external programs on Windows(R) only\&. The standard input and standard output handles of the port program will, if this option is supplied, be opened with the flag FILE_FLAG_OVERLAPPED, so that the port program can (and has to) do overlapped I/O on its standard handles\&. This is not normally the case for simple port programs, but an option of value for the experienced Windows programmer\&. \fIOn all other platforms, this option is silently discarded\fR\&\&.
.TP 2
.B
\fIin\fR\&:
The port can only be used for input\&.
.TP 2
.B
\fIout\fR\&:
The port can only be used for output\&.
.TP 2
.B
\fIbinary\fR\&:
All IO from the port are binary data objects as opposed to lists of bytes\&.
.TP 2
.B
\fIeof\fR\&:
The port will not be closed at the end of the file and produce an exit signal\&. Instead, it will remain open and a \fI{Port, eof}\fR\& message will be sent to the process holding the port\&.
.TP 2
.B
\fIhide\fR\&:
When running on Windows, suppress creation of a new console window when spawning the port program\&. (This option has no effect on other platforms\&.)
.TP 2
.B
\fB\fI{parallelism, Boolean}\fR\&\fR\&:
Set scheduler hint for port parallelism\&. If set to \fItrue\fR\&, the VM will schedule port tasks when doing so will improve parallelism in the system\&. If set to \fIfalse\fR\&, the VM will try to perform port tasks immediately, improving latency at the expense of parallelism\&. The default can be set on system startup by passing the \fB+spp\fR\& command line argument to \fBerl(1)\fR\&\&.
.RE
.LP
The default is \fIstream\fR\& for all types of port and \fIuse_stdio\fR\& for spawned ports\&.
.LP
Failure: If the port cannot be opened, the exit reason is \fIbadarg\fR\&, \fIsystem_limit\fR\&, or the Posix error code which most closely describes the error, or \fIeinval\fR\& if no Posix code is appropriate:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
Bad input arguments to \fIopen_port\fR\&\&.
.TP 2
.B
\fIsystem_limit\fR\&:
All available ports in the Erlang emulator are in use\&.
.TP 2
.B
\fIenomem\fR\&:
There was not enough memory to create the port\&.
.TP 2
.B
\fIeagain\fR\&:
There are no more available operating system processes\&.
.TP 2
.B
\fIenametoolong\fR\&:
The external command given was too long\&.
.TP 2
.B
\fIemfile\fR\&:
There are no more available file descriptors (for the operating system process that the Erlang emulator runs in)\&.
.TP 2
.B
\fIenfile\fR\&:
The file table is full (for the entire operating system)\&.
.TP 2
.B
\fIeacces\fR\&:
The \fICommand\fR\& given in \fI{spawn_executable, Command}\fR\& does not point out an executable file\&.
.TP 2
.B
\fIenoent\fR\&:
The \fIFileName\fR\& given in \fI{spawn_executable, FileName}\fR\& does not point out an existing file\&.
.RE
.LP
During use of a port opened using \fI{spawn, Name}\fR\&, \fI{spawn_driver, Name}\fR\& or \fI{spawn_executable, Name}\fR\&, errors arising when sending messages to it are reported to the owning process using signals of the form \fI{\&'EXIT\&', Port, PosixCode}\fR\&\&. See \fIfile(3)\fR\& for possible values of \fIPosixCode\fR\&\&.
.LP
The maximum number of ports that can be open at the same time can be configured by passing the \fB\fI+Q\fR\&\fR\& command line flag to \fB\fIerl(1)\fR\&\fR\&\&.
.RE
.LP
.nf

.B
erlang:phash(Term, Range) -> Hash
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
Range = Hash = integer() >= 1
.br
.RS 2
Range = 1\&.\&.2^32, Hash = 1\&.\&.Range
.RE
.RE
.RE
.RS
.LP
Portable hash function that will give the same hash for the same Erlang term regardless of machine architecture and ERTS version (the BIF was introduced in ERTS 4\&.9\&.1\&.1)\&. Range can be between 1 and 2^32, the function returns a hash value for \fITerm\fR\& within the range \fI1\&.\&.Range\fR\&\&.
.LP
This BIF could be used instead of the old deprecated \fIerlang:hash/2\fR\& BIF, as it calculates better hashes for all data-types, but consider using \fIphash2/1,2\fR\& instead\&.
.RE
.LP
.nf

.B
erlang:phash2(Term) -> Hash
.br
.fi
.br
.nf

.B
erlang:phash2(Term, Range) -> Hash
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
Range = integer() >= 1
.br
.RS 2
1\&.\&.2^32
.RE
Hash = integer() >= 0
.br
.RS 2
0\&.\&.Range-1
.RE
.RE
.RE
.RS
.LP
Portable hash function that will give the same hash for the same Erlang term regardless of machine architecture and ERTS version (the BIF was introduced in ERTS 5\&.2)\&. Range can be between 1 and 2^32, the function returns a hash value for \fITerm\fR\& within the range \fI0\&.\&.Range-1\fR\&\&. When called without the \fIRange\fR\& argument, a value in the range \fI0\&.\&.2^27-1\fR\& is returned\&.
.LP
This BIF should always be used for hashing terms\&. It distributes small integers better than \fIphash/2\fR\&, and it is faster for bignums and binaries\&.
.LP
Note that the range \fI0\&.\&.Range-1\fR\& is different from the range of \fIphash/2\fR\& (\fI1\&.\&.Range\fR\&)\&.
.RE
.LP
.nf

.B
pid_to_list(Pid) -> string()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid()
.br
.RE
.RE
.RS
.LP
Returns a string which corresponds to the text representation of \fIPid\fR\&\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for debugging and for use in the Erlang operating system\&. It should not be used in application programs\&.

.RE
.LP
.nf

.B
port_close(Port) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
.RE
.RE
.RS
.LP
Closes an open port\&. Roughly the same as \fIPort ! {self(), close}\fR\& except for the error behaviour (see below), being synchronous, and that the port does \fInot\fR\& reply with \fI{Port, closed}\fR\&\&. Any process may close a port with \fIport_close/1\fR\&, not only the port owner (the connected process)\&. If the calling process is linked to port identified by \fIPort\fR\&, an exit signal due to that link will be received by the process prior to the return from \fIport_close/1\fR\&\&.
.LP
For comparison: \fIPort ! {self(), close}\fR\& fails with \fIbadarg\fR\& if \fIPort\fR\& cannot be sent to (i\&.e\&., \fIPort\fR\& refers neither to a port nor to a process)\&. If \fIPort\fR\& is a closed port nothing happens\&. If \fIPort\fR\& is an open port and the calling process is the port owner, the port replies with \fI{Port, closed}\fR\& when all buffers have been flushed and the port really closes, but if the calling process is not the port owner the \fIport owner\fR\& fails with \fIbadsig\fR\&\&.
.LP
Note that any process can close a port using \fIPort ! {PortOwner, close}\fR\& just as if it itself was the port owner, but the reply always goes to the port owner\&.
.LP
As of OTP-R16 \fIPort ! {PortOwner, close}\fR\& is truly asynchronous\&. Note that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous\&. \fIport_close/1\fR\& is however still fully synchronous\&. This due to its error behavior\&.
.LP
Failure:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
 If \fIPort\fR\& is not an identifier of an open port, or the registered name of an open port\&. If the calling process was linked to the previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to this exception\&. 
.RE
.RE
.LP
.nf

.B
port_command(Port, Data) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Data = iodata()
.br
.RE
.RE
.RS
.LP
Sends data to a port\&. Same as \fIPort ! {PortOwner, {command, Data}}\fR\& except for the error behaviour and being synchronous (see below)\&. Any process may send data to a port with \fIport_command/2\fR\&, not only the port owner (the connected process)\&.
.LP
For comparison: \fIPort ! {PortOwner, {command, Data}}\fR\& fails with \fIbadarg\fR\& if \fIPort\fR\& cannot be sent to (i\&.e\&., \fIPort\fR\& refers neither to a port nor to a process)\&. If \fIPort\fR\& is a closed port the data message disappears without a sound\&. If \fIPort\fR\& is open and the calling process is not the port owner, the \fIport owner\fR\& fails with \fIbadsig\fR\&\&. The port owner fails with \fIbadsig\fR\& also if \fIData\fR\& is not a valid IO list\&.
.LP
Note that any process can send to a port using \fIPort ! {PortOwner, {command, Data}}\fR\& just as if it itself was the port owner\&.
.LP
If the port is busy, the calling process will be suspended until the port is not busy anymore\&.
.LP
As of OTP-R16 \fIPort ! {PortOwner, {command, Data}}\fR\& is truly asynchronous\&. Note that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous\&. \fIport_command/2\fR\& is however still fully synchronous\&. This due to its error behavior\&.
.LP
Failures:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
 If \fIPort\fR\& is not an identifier of an open port, or the registered name of an open port\&. If the calling process was linked to the previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to this exception\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If \fIData\fR\& is not a valid io list\&. 
.RE
.RE
.LP
.nf

.B
port_command(Port, Data, OptionList) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Data = iodata()
.br
Option = force | nosuspend
.br
OptionList = [Option]
.br
.RE
.RE
.RS
.LP
Sends data to a port\&. \fIport_command(Port, Data, [])\fR\& equals \fIport_command(Port, Data)\fR\&\&.
.LP
If the port command is aborted \fIfalse\fR\& is returned; otherwise, \fItrue\fR\& is returned\&.
.LP
If the port is busy, the calling process will be suspended until the port is not busy anymore\&.
.LP
Currently the following \fIOption\fR\&s are valid:
.RS 2
.TP 2
.B
\fIforce\fR\&:
The calling process will not be suspended if the port is busy; instead, the port command is forced through\&. The call will fail with a \fInotsup\fR\& exception if the driver of the port does not support this\&. For more information see the \fBERL_DRV_FLAG_SOFT_BUSY\fR\& driver flag\&. 
.TP 2
.B
\fInosuspend\fR\&:
The calling process will not be suspended if the port is busy; instead, the port command is aborted and \fIfalse\fR\& is returned\&. 
.RE
.LP

.RS -4
.B
Note:
.RE
More options may be added in the future\&.

.LP
Failures:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
 If \fIPort\fR\& is not an identifier of an open port, or the registered name of an open port\&. If the calling process was linked to the previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to this exception\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If \fIData\fR\& is not a valid io list\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If \fIOptionList\fR\& is not a valid option list\&. 
.TP 2
.B
\fInotsup\fR\&:
 If the \fIforce\fR\& option has been passed, but the driver of the port does not allow forcing through a busy port\&. 
.RE
.RE
.LP
.nf

.B
port_connect(Port, Pid) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Pid = pid()
.br
.RE
.RE
.RS
.LP
Sets the port owner (the connected port) to \fIPid\fR\&\&. Roughly the same as \fIPort ! {Owner, {connect, Pid}}\fR\& except for the following:
.RS 2
.TP 2
*
The error behavior differs, see below\&.
.LP
.TP 2
*
The port does \fInot\fR\& reply with \fI{Port,connected}\fR\&\&.
.LP
.TP 2
*
\fIport_connect/1\fR\& is synchronous, see below\&.
.LP
.TP 2
*
The new port owner gets linked to the port\&.
.LP
.RE

.LP
The old port owner stays linked to the port and have to call \fIunlink(Port)\fR\& if this is not desired\&. Any process may set the port owner to be any process with \fIport_connect/2\fR\&\&.
.LP
For comparison: \fIPort ! {self(), {connect, Pid}}\fR\& fails with \fIbadarg\fR\& if \fIPort\fR\& cannot be sent to (i\&.e\&., \fIPort\fR\& refers neither to a port nor to a process)\&. If \fIPort\fR\& is a closed port nothing happens\&. If \fIPort\fR\& is an open port and the calling process is the port owner, the port replies with \fI{Port, connected}\fR\& to the old port owner\&. Note that the old port owner is still linked to the port, and that the new is not\&. If \fIPort\fR\& is an open port and the calling process is not the port owner, the \fIport owner\fR\& fails with \fIbadsig\fR\&\&. The port owner fails with \fIbadsig\fR\& also if \fIPid\fR\& is not an existing local pid\&.
.LP
Note that any process can set the port owner using \fIPort ! {PortOwner, {connect, Pid}}\fR\& just as if it itself was the port owner, but the reply always goes to the port owner\&.
.LP
As of OTP-R16 \fIPort ! {PortOwner, {connect, Pid}}\fR\& is truly asynchronous\&. Note that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous\&. \fIport_connect/2\fR\& is however still fully synchronous\&. This due to its error behavior\&.
.LP
Failures:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
 If \fIPort\fR\& is not an identifier of an open port, or the registered name of an open port\&. If the calling process was linked to the previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to this exception\&. 
.TP 2
.B
\fIbadarg\fR\&:
If process identified by \fIPid\fR\& is not an existing local process\&.
.RE
.RE
.LP
.nf

.B
port_control(Port, Operation, Data) -> iodata() | binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Operation = integer()
.br
Data = iodata()
.br
.RE
.RE
.RS
.LP
Performs a synchronous control operation on a port\&. The meaning of \fIOperation\fR\& and \fIData\fR\& depends on the port, i\&.e\&., on the port driver\&. Not all port drivers support this control feature\&.
.LP
Returns: a list of integers in the range 0 through 255, or a binary, depending on the port driver\&. The meaning of the returned data also depends on the port driver\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not an open port or the registered name of an open port, if \fIOperation\fR\& cannot fit in a 32-bit integer, if the port driver does not support synchronous control operations, or if the port driver so decides for any reason (probably something wrong with \fIOperation\fR\& or \fIData\fR\&)\&.
.RE
.LP
.nf

.B
erlang:port_call(Port, Operation, Data) -> term()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Operation = integer()
.br
Data = term()
.br
.RE
.RE
.RS
.LP
Performs a synchronous call to a port\&. The meaning of \fIOperation\fR\& and \fIData\fR\& depends on the port, i\&.e\&., on the port driver\&. Not all port drivers support this feature\&.
.LP
\fIPort\fR\& is a port identifier, referring to a driver\&.
.LP
\fIOperation\fR\& is an integer, which is passed on to the driver\&.
.LP
\fIData\fR\& is any Erlang term\&. This data is converted to binary term format and sent to the port\&.
.LP
Returns: a term from the driver\&. The meaning of the returned data also depends on the port driver\&.
.LP
Failures:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
 If \fIPort\fR\& is not an identifier of an open port, or the registered name of an open port\&. If the calling process was linked to the previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to this exception\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If \fIOperation\fR\& does not fit in a 32-bit integer\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If the port driver does not support synchronous control operations\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If the port driver so decides for any reason (probably something wrong with \fIOperation\fR\&, or \fIData\fR\&)\&. 
.RE
.RE
.LP
.nf

.B
erlang:port_info(Port) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
ResultItem = {registered_name, RegisteredName :: atom()}
.br
           | {id, Index :: integer() >= 0}
.br
           | {connected, Pid :: pid()}
.br
           | {links, Pids :: [pid()]}
.br
           | {name, String :: string()}
.br
           | {input, Bytes :: integer() >= 0}
.br
           | {output, Bytes :: integer() >= 0}
.br
           | {os_pid, OsPid :: integer() >= 0 | undefined}
.br
Result = [ResultItem] | undefined
.br
.RE
.RE
.RS
.LP
Returns a list containing tuples with information about the \fIPort\fR\&, or \fIundefined\fR\& if the port is not open\&. The order of the tuples is not defined, nor are all the tuples mandatory\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/1\fR\&\&.
.LP
Currently the result will containt information about the following \fIItem\fR\&s: \fIregistered_name\fR\& (if the port has a registered name), \fIid\fR\&, \fIconnected\fR\&, \fIlinks\fR\&, \fIname\fR\&, \fIinput\fR\&, and \fIoutput\fR\&\&. For more information about the different \fIItem\fR\&s, see \fBport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: connected) ->
.B
                    {connected, Pid} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Pid = pid()
.br
.RE
.RE
.RS
.LP
\fIPid\fR\& is the process identifier of the process connected to the port\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: id) -> {id, Index} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Index = integer() >= 0
.br
.RE
.RE
.RS
.LP
\fIIndex\fR\& is the internal index of the port\&. This index may be used to separate ports\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: input) ->
.B
                    {input, Bytes} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Bytes = integer() >= 0
.br
.RE
.RE
.RS
.LP
\fIBytes\fR\& is the total number of bytes read from the port\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: links) -> {links, Pids} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Pids = [pid()]
.br
.RE
.RE
.RS
.LP
\fIPids\fR\& is a list of the process identifiers of the processes that the port is linked to\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: locking) ->
.B
                    {locking, Locking} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Locking = false | port_level | driver_level
.br
.RE
.RE
.RS
.LP
\fILocking\fR\& is currently either \fIfalse\fR\& (emulator without SMP support), \fIport_level\fR\& (port specific locking), or \fIdriver_level\fR\& (driver specific locking)\&. Note that these results are highly implementation specific and might change in the future\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: memory) ->
.B
                    {memory, Bytes} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Bytes = integer() >= 0
.br
.RE
.RE
.RS
.LP
\fIBytes\fR\& is the total amount of memory, in bytes, allocated for this port by the runtime system\&. Note that the port itself might have allocated memory which is not included in \fIBytes\fR\&\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: monitors) ->
.B
                    {monitors, Monitors} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Monitors = [{process, pid()}]
.br
.RE
.RE
.RS
.LP
\fIMonitors\fR\& represent processes that this port is monitoring\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: name) -> {name, Name} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Name = string()
.br
.RE
.RE
.RS
.LP
\fIName\fR\& is the command name set by \fBopen_port/2\fR\&\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: os_pid) ->
.B
                    {os_pid, OsPid} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
OsPid = integer() >= 0 | undefined
.br
.RE
.RE
.RS
.LP
\fIOsPid\fR\& is the process identifier (or equivalent) of an OS process created with \fBopen_port({spawn | spawn_executable, Command}, Options)\fR\&\&. If the port is not the result of spawning an OS process, the value is \fIundefined\fR\&\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: output) ->
.B
                    {output, Bytes} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Bytes = integer() >= 0
.br
.RE
.RE
.RS
.LP
\fIBytes\fR\& is the total number of bytes written to the port from Erlang processes using either \fBport_command/2\fR\&, \fBport_command/3\fR\&, or \fIPort ! {Owner, {command, Data}\fR\&\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: parallelism) ->
.B
                    {parallelism, Boolean} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Boolean = boolean()
.br
.RE
.RE
.RS
.LP
\fIBoolean\fR\& corresponds to the port parallelism hint being used by this port\&. For more information see the \fBparallelism\fR\& option of \fBopen_port/2\fR\&\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: queue_size) ->
.B
                    {queue_size, Bytes} | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
Bytes = integer() >= 0
.br
.RE
.RE
.RS
.LP
\fIBytes\fR\& is the total amount of data, in bytes, queued by the port using the ERTS driver queue implementation\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_info(Port, Item :: registered_name) ->
.B
                    {registered_name, RegisteredName} |
.B
                    [] |
.B
                    undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port() | atom()
.br
RegisteredName = atom()
.br
.RE
.RE
.RS
.LP
\fIRegisteredName\fR\& is the registered name of the port\&. If the port has no registered name, \fI[]\fR\& is returned\&.
.LP
If the port identified by \fIPort\fR\& is not open, \fIundefined\fR\& is returned\&. If \fIundefined\fR\& is returned and the calling process was linked to a previously open port identified by \fIPort\fR\&, an exit signal due to this link was received by the process prior to the return from \fIport_info/2\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPort\fR\& is not a local port identifier, or an atom\&.
.RE
.LP
.nf

.B
erlang:port_to_list(Port) -> string()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Port = port()
.br
.RE
.RE
.RS
.LP
Returns a string which corresponds to the text representation of the port identifier \fIPort\fR\&\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for debugging and for use in the Erlang operating system\&. It should not be used in application programs\&.

.RE
.LP
.nf

.B
erlang:ports() -> [port()]
.br
.fi
.br
.RS
.LP
Returns a list of port identifiers corresponding to all the ports currently existing on the local node\&.
.LP
Note that a port that is exiting, exists but is not open\&.
.RE
.LP
.nf

.B
pre_loaded() -> [module()]
.br
.fi
.br
.RS
.LP
Returns a list of Erlang modules which are pre-loaded in the system\&. As all loading of code is done through the file system, the file system must have been loaded previously\&. Hence, at least the module \fIinit\fR\& must be pre-loaded\&.
.RE
.LP
.nf

.B
erlang:process_display(Pid, Type) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid()
.br
Type = backtrace
.br
.RE
.RE
.RS
.LP
Writes information about the local process \fIPid\fR\& on standard error\&. The currently allowed value for the atom \fIType\fR\& is \fIbacktrace\fR\&, which shows the contents of the call stack, including information about the call chain, with the current function printed first\&. The format of the output is not further defined\&.
.RE
.LP
.nf

.B
process_flag(Flag :: trap_exit, Boolean) -> OldBoolean
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Boolean = OldBoolean = boolean()
.br
.RE
.RE
.RS
.LP
When \fItrap_exit\fR\& is set to \fItrue\fR\&, exit signals arriving to a process are converted to \fI{\&'EXIT\&', From, Reason}\fR\& messages, which can be received as ordinary messages\&. If \fItrap_exit\fR\& is set to \fIfalse\fR\&, the process exits if it receives an exit signal other than \fInormal\fR\& and the exit signal is propagated to its linked processes\&. Application processes should normally not trap exits\&.
.LP
Returns the old value of the flag\&.
.LP
See also \fBexit/2\fR\&\&.
.RE
.LP
.nf

.B
process_flag(Flag :: error_handler, Module) -> OldModule
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = OldModule = atom()
.br
.RE
.RE
.RS
.LP
This is used by a process to redefine the error handler for undefined function calls and undefined registered processes\&. Inexperienced users should not use this flag since code auto-loading is dependent on the correct operation of the error handling module\&.
.LP
Returns the old value of the flag\&.
.RE
.LP
.nf

.B
process_flag(Flag :: min_heap_size, MinHeapSize) -> OldMinHeapSize
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MinHeapSize = OldMinHeapSize = integer() >= 0
.br
.RE
.RE
.RS
.LP
This changes the minimum heap size for the calling process\&.
.LP
Returns the old value of the flag\&.
.RE
.LP
.nf

.B
process_flag(Flag :: min_bin_vheap_size, MinBinVHeapSize) ->
.B
                OldMinBinVHeapSize
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MinBinVHeapSize = OldMinBinVHeapSize = integer() >= 0
.br
.RE
.RE
.RS
.LP
This changes the minimum binary virtual heap size for the calling process\&.
.LP
Returns the old value of the flag\&.
.RE
.LP
.nf

.B
process_flag(Flag :: priority, Level) -> OldLevel
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Level = OldLevel = \fBpriority_level()\fR\&
.br
.nf
\fBpriority_level()\fR\& = low | normal | high | max
.fi
.br
.RE
.RE
.RS
.LP
This sets the process priority\&. \fILevel\fR\& is an atom\&. There are currently four priority levels: \fIlow\fR\&, \fInormal\fR\&, \fIhigh\fR\&, and \fImax\fR\&\&. The default priority level is \fInormal\fR\&\&. \fINOTE\fR\&: The \fImax\fR\& priority level is reserved for internal use in the Erlang runtime system, and should \fInot\fR\& be used by others\&.
.LP
Internally in each priority level processes are scheduled in a round robin fashion\&.
.LP
Execution of processes on priority \fInormal\fR\& and priority \fIlow\fR\& will be interleaved\&. Processes on priority \fIlow\fR\& will be selected for execution less frequently than processes on priority \fInormal\fR\&\&.
.LP
When there are runnable processes on priority \fIhigh\fR\& no processes on priority \fIlow\fR\&, or \fInormal\fR\& will be selected for execution\&. Note, however, that this does \fInot\fR\& mean that no processes on priority \fIlow\fR\&, or \fInormal\fR\& will be able to run when there are processes on priority \fIhigh\fR\& running\&. On the runtime system with SMP support there might be more processes running in parallel than processes on priority \fIhigh\fR\&, i\&.e\&., a \fIlow\fR\&, and a \fIhigh\fR\& priority process might execute at the same time\&.
.LP
When there are runnable processes on priority \fImax\fR\& no processes on priority \fIlow\fR\&, \fInormal\fR\&, or \fIhigh\fR\& will be selected for execution\&. As with the \fIhigh\fR\& priority, processes on lower priorities might execute in parallel with processes on priority \fImax\fR\&\&.
.LP
Scheduling is preemptive\&. Regardless of priority, a process is preempted when it has consumed more than a certain amount of reductions since the last time it was selected for execution\&.
.LP
\fINOTE\fR\&: You should not depend on the scheduling to remain exactly as it is today\&. Scheduling, at least on the runtime system with SMP support, is very likely to be modified in the future in order to better utilize available processor cores\&.
.LP
There is currently \fIno\fR\& automatic mechanism for avoiding priority inversion, such as priority inheritance, or priority ceilings\&. When using priorities you have to take this into account and handle such scenarios by yourself\&.
.LP
Making calls from a \fIhigh\fR\& priority process into code that you don\&'t have control over may cause the \fIhigh\fR\& priority process to wait for a processes with lower priority, i\&.e\&., effectively decreasing the priority of the \fIhigh\fR\& priority process during the call\&. Even if this isn\&'t the case with one version of the code that you don\&'t have under your control, it might be the case in a future version of it\&. This might, for example, happen if a \fIhigh\fR\& priority process triggers code loading, since the code server runs on priority \fInormal\fR\&\&.
.LP
Other priorities than \fInormal\fR\& are normally not needed\&. When other priorities are used, they need to be used with care, especially the \fIhigh\fR\& priority \fImust\fR\& be used with care\&. A process on \fIhigh\fR\& priority should only perform work for short periods of time\&. Busy looping for long periods of time in a \fIhigh\fR\& priority process will most likely cause problems, since there are important servers in OTP running on priority \fInormal\fR\&\&.
.LP
Returns the old value of the flag\&.
.RE
.LP
.nf

.B
process_flag(Flag :: save_calls, N) -> OldN
.br
.fi
.br
.RS
.LP
Types:

.RS 3
N = OldN = 0\&.\&.10000
.br
.RE
.RE
.RS
.LP
\fIN\fR\& must be an integer in the interval 0\&.\&.10000\&. If \fIN\fR\& > 0, call saving is made active for the process, which means that information about the \fIN\fR\& most recent global function calls, BIF calls, sends and receives made by the process are saved in a list, which can be retrieved with \fIprocess_info(Pid, last_calls)\fR\&\&. A global function call is one in which the module of the function is explicitly mentioned\&. Only a fixed amount of information is saved: a tuple \fI{Module, Function, Arity}\fR\& for function calls, and the mere atoms \fIsend\fR\&, \fI\&'receive\&'\fR\& and \fItimeout\fR\& for sends and receives (\fI\&'receive\&'\fR\& when a message is received and \fItimeout\fR\& when a receive times out)\&. If \fIN\fR\& = 0, call saving is disabled for the process, which is the default\&. Whenever the size of the call saving list is set, its contents are reset\&.
.LP
Returns the old value of the flag\&.
.RE
.LP
.nf

.B
process_flag(Flag :: sensitive, Boolean) -> OldBoolean
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Boolean = OldBoolean = boolean()
.br
.RE
.RE
.RS
.LP
Set or clear the \fIsensitive\fR\& flag for the current process\&. When a process has been marked as sensitive by calling \fIprocess_flag(sensitive, true)\fR\&, features in the run-time system that can be used for examining the data and/or inner working of the process are silently disabled\&.
.LP
Features that are disabled include (but are not limited to) the following:
.LP
Tracing: Trace flags can still be set for the process, but no trace messages of any kind will be generated\&. (If the \fIsensitive\fR\& flag is turned off, trace messages will again be generated if there are any trace flags set\&.)
.LP
Sequential tracing: The sequential trace token will be propagated as usual, but no sequential trace messages will be generated\&.
.LP
\fIprocess_info/1,2\fR\& cannot be used to read out the message queue or the process dictionary (both will be returned as empty lists)\&.
.LP
Stack back-traces cannot be displayed for the process\&.
.LP
In crash dumps, the stack, messages, and the process dictionary will be omitted\&.
.LP
If \fI{save_calls,N}\fR\& has been set for the process, no function calls will be saved to the call saving list\&. (The call saving list will not be cleared; furthermore, send, receive, and timeout events will still be added to the list\&.)
.LP
Returns the old value of the flag\&.
.RE
.LP
.nf

.B
process_flag(Pid, Flag, Value) -> OldValue
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid()
.br
Flag = save_calls
.br
Value = OldValue = integer() >= 0
.br
.RE
.RE
.RS
.LP
Sets certain flags for the process \fIPid\fR\&, in the same manner as \fBprocess_flag/2\fR\&\&. Returns the old value of the flag\&. The allowed values for \fIFlag\fR\& are only a subset of those allowed in \fIprocess_flag/2\fR\&, namely: \fIsave_calls\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fIPid\fR\& is not a local process\&.
.RE
.LP
.nf

.B
process_info(Pid) -> Info
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid()
.br
Info = [InfoTuple] | undefined
.br
InfoTuple = \fBprocess_info_result_item()\fR\&
.br
.nf
\fBprocess_info_result_item()\fR\& = {backtrace, Bin :: binary()}
.br
                           | {binary,
.br
                              BinInfo ::
.br
                                  [{integer() >= 0,
.br
                                    integer() >= 0,
.br
                                    integer() >= 0}]}
.br
                           | {catchlevel,
.br
                              CatchLevel :: integer() >= 0}
.br
                           | {current_function,
.br
                              {Module :: module(),
.br
                               Function :: atom(),
.br
                               Arity :: arity()}}
.br
                           | {current_location,
.br
                              {Module :: module(),
.br
                               Function :: atom(),
.br
                               Arity :: arity(),
.br
                               Location ::
.br
                                   [{file,
.br
                                     Filename :: string()} |
.br
                                    {line,
.br
                                     Line :: integer() >= 1}]}}
.br
                           | {current_stacktrace,
.br
                              Stack :: [\fBstack_item()\fR\&]}
.br
                           | {dictionary,
.br
                              Dictionary ::
.br
                                  [{Key :: term(),
.br
                                    Value :: term()}]}
.br
                           | {error_handler,
.br
                              Module :: module()}
.br
                           | {garbage_collection,
.br
                              GCInfo ::
.br
                                  [{atom(), integer() >= 0}]}
.br
                           | {group_leader,
.br
                              GroupLeader :: pid()}
.br
                           | {heap_size,
.br
                              Size :: integer() >= 0}
.br
                           | {initial_call, mfa()}
.br
                           | {links,
.br
                              PidsAndPorts :: [pid() | port()]}
.br
                           | {last_calls,
.br
                              false | (Calls :: [mfa()])}
.br
                           | {memory,
.br
                              Size :: integer() >= 0}
.br
                           | {message_queue_len,
.br
                              MessageQueueLen ::
.br
                                  integer() >= 0}
.br
                           | {messages,
.br
                              MessageQueue :: [term()]}
.br
                           | {min_heap_size,
.br
                              MinHeapSize :: integer() >= 0}
.br
                           | {min_bin_vheap_size,
.br
                              MinBinVHeapSize ::
.br
                                  integer() >= 0}
.br
                           | {monitored_by, Pids :: [pid()]}
.br
                           | {monitors,
.br
                              Monitors ::
.br
                                  [{process,
.br
                                    Pid :: pid()
.br
                                         | {RegName :: atom(),
.br
                                            Node :: node()}}]}
.br
                           | {priority,
.br
                              Level :: \fBpriority_level()\fR\&}
.br
                           | {reductions,
.br
                              Number :: integer() >= 0}
.br
                           | {registered_name, Atom :: atom()}
.br
                           | {sequential_trace_token,
.br
                              [] |
.br
                              (SequentialTraceToken :: term())}
.br
                           | {stack_size,
.br
                              Size :: integer() >= 0}
.br
                           | {status,
.br
                              Status :: exiting
.br
                                      | garbage_collecting
.br
                                      | waiting
.br
                                      | running
.br
                                      | runnable
.br
                                      | suspended}
.br
                           | {suspending,
.br
                              SuspendeeList ::
.br
                                  [{Suspendee :: pid(),
.br
                                    ActiveSuspendCount ::
.br
                                        integer() >= 0,
.br
                                    OutstandingSuspendCount ::
.br
                                        integer() >= 0}]}
.br
                           | {total_heap_size,
.br
                              Size :: integer() >= 0}
.br
                           | {trace,
.br
                              InternalTraceFlags ::
.br
                                  integer() >= 0}
.br
                           | {trap_exit, Boolean :: boolean()}
.fi
.br
.nf
\fBpriority_level()\fR\& = low | normal | high | max
.fi
.br
.nf
\fBstack_item()\fR\& = 
.br
    {Module :: module(),
.br
     Function :: atom(),
.br
     Arity :: arity() | (Args :: [term()]),
.br
     Location ::
.br
         [{file, Filename :: string()} |
.br
          {line, Line :: integer() >= 1}]}
.fi
.br
.RE
.RE
.RS
.LP
Returns a list containing \fIInfoTuple\fR\&s with miscellaneous information about the process identified by \fIPid\fR\&, or \fIundefined\fR\& if the process is not alive\&.
.LP
The order of the \fIInfoTuple\fR\&s is not defined, nor are all the \fIInfoTuple\fR\&s mandatory\&. The \fIInfoTuple\fR\&s part of the result may be changed without prior notice\&. Currently \fIInfoTuple\fR\&s with the following items are part of the result: \fIcurrent_function\fR\&, \fIinitial_call\fR\&, \fIstatus\fR\&, \fImessage_queue_len\fR\&, \fImessages\fR\&, \fIlinks\fR\&, \fIdictionary\fR\&, \fItrap_exit\fR\&, \fIerror_handler\fR\&, \fIpriority\fR\&, \fIgroup_leader\fR\&, \fItotal_heap_size\fR\&, \fIheap_size\fR\&, \fIstack_size\fR\&, \fIreductions\fR\&, and \fIgarbage_collection\fR\&\&. If the process identified by \fIPid\fR\& has a registered name also an \fIInfoTuple\fR\& with the item \fIregistered_name\fR\& will appear\&.
.LP
See \fBprocess_info/2\fR\& for information about specific \fIInfoTuple\fR\&s\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for \fIdebugging only\fR\&, use \fBprocess_info/2\fR\& for all other purposes\&.

.LP
Failure: \fIbadarg\fR\& if \fIPid\fR\& is not a local process\&.
.RE
.LP
.nf

.B
process_info(Pid, Item) -> InfoTuple | [] | undefined
.br
.fi
.br
.nf

.B
process_info(Pid, ItemList) -> InfoTupleList | [] | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pid = pid()
.br
ItemList = [Item]
.br
Item = \fBprocess_info_item()\fR\&
.br
InfoTupleList = [InfoTuple]
.br
InfoTuple = \fBprocess_info_result_item()\fR\&
.br
.nf
\fBprocess_info_item()\fR\& = backtrace
.br
                    | binary
.br
                    | catchlevel
.br
                    | current_function
.br
                    | current_location
.br
                    | current_stacktrace
.br
                    | dictionary
.br
                    | error_handler
.br
                    | garbage_collection
.br
                    | group_leader
.br
                    | heap_size
.br
                    | initial_call
.br
                    | links
.br
                    | last_calls
.br
                    | memory
.br
                    | message_queue_len
.br
                    | messages
.br
                    | min_heap_size
.br
                    | min_bin_vheap_size
.br
                    | monitored_by
.br
                    | monitors
.br
                    | priority
.br
                    | reductions
.br
                    | registered_name
.br
                    | sequential_trace_token
.br
                    | stack_size
.br
                    | status
.br
                    | suspending
.br
                    | total_heap_size
.br
                    | trace
.br
                    | trap_exit
.fi
.br
.nf
\fBprocess_info_result_item()\fR\& = {backtrace, Bin :: binary()}
.br
                           | {binary,
.br
                              BinInfo ::
.br
                                  [{integer() >= 0,
.br
                                    integer() >= 0,
.br
                                    integer() >= 0}]}
.br
                           | {catchlevel,
.br
                              CatchLevel :: integer() >= 0}
.br
                           | {current_function,
.br
                              {Module :: module(),
.br
                               Function :: atom(),
.br
                               Arity :: arity()}}
.br
                           | {current_location,
.br
                              {Module :: module(),
.br
                               Function :: atom(),
.br
                               Arity :: arity(),
.br
                               Location ::
.br
                                   [{file,
.br
                                     Filename :: string()} |
.br
                                    {line,
.br
                                     Line :: integer() >= 1}]}}
.br
                           | {current_stacktrace,
.br
                              Stack :: [\fBstack_item()\fR\&]}
.br
                           | {dictionary,
.br
                              Dictionary ::
.br
                                  [{Key :: term(),
.br
                                    Value :: term()}]}
.br
                           | {error_handler,
.br
                              Module :: module()}
.br
                           | {garbage_collection,
.br
                              GCInfo ::
.br
                                  [{atom(), integer() >= 0}]}
.br
                           | {group_leader,
.br
                              GroupLeader :: pid()}
.br
                           | {heap_size,
.br
                              Size :: integer() >= 0}
.br
                           | {initial_call, mfa()}
.br
                           | {links,
.br
                              PidsAndPorts :: [pid() | port()]}
.br
                           | {last_calls,
.br
                              false | (Calls :: [mfa()])}
.br
                           | {memory,
.br
                              Size :: integer() >= 0}
.br
                           | {message_queue_len,
.br
                              MessageQueueLen ::
.br
                                  integer() >= 0}
.br
                           | {messages,
.br
                              MessageQueue :: [term()]}
.br
                           | {min_heap_size,
.br
                              MinHeapSize :: integer() >= 0}
.br
                           | {min_bin_vheap_size,
.br
                              MinBinVHeapSize ::
.br
                                  integer() >= 0}
.br
                           | {monitored_by, Pids :: [pid()]}
.br
                           | {monitors,
.br
                              Monitors ::
.br
                                  [{process,
.br
                                    Pid :: pid()
.br
                                         | {RegName :: atom(),
.br
                                            Node :: node()}}]}
.br
                           | {priority,
.br
                              Level :: \fBpriority_level()\fR\&}
.br
                           | {reductions,
.br
                              Number :: integer() >= 0}
.br
                           | {registered_name, Atom :: atom()}
.br
                           | {sequential_trace_token,
.br
                              [] |
.br
                              (SequentialTraceToken :: term())}
.br
                           | {stack_size,
.br
                              Size :: integer() >= 0}
.br
                           | {status,
.br
                              Status :: exiting
.br
                                      | garbage_collecting
.br
                                      | waiting
.br
                                      | running
.br
                                      | runnable
.br
                                      | suspended}
.br
                           | {suspending,
.br
                              SuspendeeList ::
.br
                                  [{Suspendee :: pid(),
.br
                                    ActiveSuspendCount ::
.br
                                        integer() >= 0,
.br
                                    OutstandingSuspendCount ::
.br
                                        integer() >= 0}]}
.br
                           | {total_heap_size,
.br
                              Size :: integer() >= 0}
.br
                           | {trace,
.br
                              InternalTraceFlags ::
.br
                                  integer() >= 0}
.br
                           | {trap_exit, Boolean :: boolean()}
.fi
.br
.nf
\fBstack_item()\fR\& = 
.br
    {Module :: module(),
.br
     Function :: atom(),
.br
     Arity :: arity() | (Args :: [term()]),
.br
     Location ::
.br
         [{file, Filename :: string()} |
.br
          {line, Line :: integer() >= 1}]}
.fi
.br
.nf
\fBpriority_level()\fR\& = low | normal | high | max
.fi
.br
.RE
.RE
.RS
.LP
Returns information about the process identified by \fIPid\fR\& as specified by the \fIItem\fR\& or the \fIItemList\fR\&, or \fIundefined\fR\& if the process is not alive\&.
.LP
If the process is alive and a single \fIItem\fR\& is given, the returned value is the corresponding \fIInfoTuple\fR\& unless \fIItem =:= registered_name\fR\& and the process has no registered name\&. In this case \fI[]\fR\& is returned\&. This strange behavior is due to historical reasons, and is kept for backward compatibility\&.
.LP
If an \fIItemList\fR\& is given, the result is an \fIInfoTupleList\fR\&\&. The \fIInfoTuple\fR\&s in the \fIInfoTupleList\fR\& will appear with the corresponding \fIItem\fR\&s in the same order as the \fIItem\fR\&s appeared in the \fIItemList\fR\&\&. Valid \fIItem\fR\&s may appear multiple times in the \fIItemList\fR\&\&.
.LP

.RS -4
.B
Note:
.RE
If \fIregistered_name\fR\& is part of an \fIItemList\fR\& and the process has no name registered a \fI{registered_name, []}\fR\& \fIInfoTuple\fR\& \fIwill\fR\& appear in the resulting \fIInfoTupleList\fR\&\&. This behavior is different than when a single \fIItem =:= registered_name\fR\& is given, and than when \fIprocess_info/1\fR\& is used\&.

.LP
Currently the following \fIInfoTuple\fR\&s with corresponding \fIItem\fR\&s are valid:
.RS 2
.TP 2
.B
\fI{backtrace, Bin}\fR\&:
The binary \fIBin\fR\& contains the same information as the output from \fIerlang:process_display(Pid, backtrace)\fR\&\&. Use \fIbinary_to_list/1\fR\& to obtain the string of characters from the binary\&.
.TP 2
.B
\fI{binary, BinInfo}\fR\&:
\fIBinInfo\fR\& is a list containing miscellaneous information about binaries currently being referred to by this process\&. This \fIInfoTuple\fR\& may be changed or removed without prior notice\&.
.TP 2
.B
\fI{catchlevel, CatchLevel}\fR\&:
\fICatchLevel\fR\& is the number of currently active catches in this process\&. This \fIInfoTuple\fR\& may be changed or removed without prior notice\&.
.TP 2
.B
\fI{current_function, {Module, Function, Arity}}\fR\&:
\fIModule\fR\&, \fIFunction\fR\&, \fIArity\fR\& is the current function call of the process\&.
.TP 2
.B
\fI{current_location, {Module, Function, Arity, Location}}\fR\&:
\fIModule\fR\&, \fIFunction\fR\&, \fIArity\fR\& is the current function call of the process\&. \fILocation\fR\& is a list of two-tuples that describes the location in the source code\&.
.TP 2
.B
\fI{current_stacktrace, Stack}\fR\&:
Return the current call stack back-trace (\fIstacktrace\fR\&) of the process\&. The stack has the same format as returned by \fBerlang:get_stacktrace/0\fR\&\&.
.TP 2
.B
\fI{dictionary, Dictionary}\fR\&:
\fIDictionary\fR\& is the dictionary of the process\&.
.TP 2
.B
\fI{error_handler, Module}\fR\&:
\fIModule\fR\& is the error handler module used by the process (for undefined function calls, for example)\&.
.TP 2
.B
\fI{garbage_collection, GCInfo}\fR\&:
\fIGCInfo\fR\& is a list which contains miscellaneous information about garbage collection for this process\&. The content of \fIGCInfo\fR\& may be changed without prior notice\&.
.TP 2
.B
\fI{group_leader, GroupLeader}\fR\&:
\fIGroupLeader\fR\& is group leader for the IO of the process\&.
.TP 2
.B
\fI{heap_size, Size}\fR\&:
\fISize\fR\& is the size in words of youngest heap generation of the process\&. This generation currently include the stack of the process\&. This information is highly implementation dependent, and may change if the implementation change\&.
.TP 2
.B
\fI{initial_call, {Module, Function, Arity}}\fR\&:
\fIModule\fR\&, \fIFunction\fR\&, \fIArity\fR\& is the initial function call with which the process was spawned\&.
.TP 2
.B
\fI{links, PidsAndPorts}\fR\&:
\fIPidsAndPorts\fR\& is a list of pids and port identifiers, with processes or ports to which the process has a link\&.
.TP 2
.B
\fI{last_calls, false|Calls}\fR\&:
The value is \fIfalse\fR\& if call saving is not active for the process (see \fBprocess_flag/3\fR\&)\&. If call saving is active, a list is returned, in which the last element is the most recent called\&.
.TP 2
.B
\fI{memory, Size}\fR\&:
\fISize\fR\& is the size in bytes of the process\&. This includes call stack, heap and internal structures\&.
.TP 2
.B
\fI{message_queue_len, MessageQueueLen}\fR\&:
\fIMessageQueueLen\fR\& is the number of messages currently in the message queue of the process\&. This is the length of the list \fIMessageQueue\fR\& returned as the info item \fImessages\fR\& (see below)\&.
.TP 2
.B
\fI{messages, MessageQueue}\fR\&:
\fIMessageQueue\fR\& is a list of the messages to the process, which have not yet been processed\&.
.TP 2
.B
\fI{min_heap_size, MinHeapSize}\fR\&:
\fIMinHeapSize\fR\& is the minimum heap size for the process\&.
.TP 2
.B
\fI{min_bin_vheap_size, MinBinVHeapSize}\fR\&:
\fIMinBinVHeapSize\fR\& is the minimum binary virtual heap size for the process\&.
.TP 2
.B
\fI{monitored_by, Pids}\fR\&:
A list of pids that are monitoring the process (with \fImonitor/2\fR\&)\&.
.TP 2
.B
\fI{monitors, Monitors}\fR\&:
A list of monitors (started by \fImonitor/2\fR\&) that are active for the process\&. For a local process monitor or a remote process monitor by pid, the list item is \fI{process, Pid}\fR\&, and for a remote process monitor by name, the list item is \fI{process, {RegName, Node}}\fR\&\&.
.TP 2
.B
\fI{priority, Level}\fR\&:
\fILevel\fR\& is the current priority level for the process\&. For more information on priorities see \fBprocess_flag(priority, Level)\fR\&\&.
.TP 2
.B
\fI{reductions, Number}\fR\&:
\fINumber\fR\& is the number of reductions executed by the process\&.
.TP 2
.B
\fI{registered_name, Atom}\fR\&:
\fIAtom\fR\& is the registered name of the process\&. If the process has no registered name, this tuple is not present in the list\&.
.TP 2
.B
\fI{sequential_trace_token, [] | SequentialTraceToken}\fR\&:
\fISequentialTraceToken\fR\& the sequential trace token for the process\&. This \fIInfoTuple\fR\& may be changed or removed without prior notice\&.
.TP 2
.B
\fI{stack_size, Size}\fR\&:
\fISize\fR\& is the stack size of the process in words\&.
.TP 2
.B
\fI{status, Status}\fR\&:
\fIStatus\fR\& is the status of the process\&. \fIStatus\fR\& is \fIexiting\fR\&, \fIgarbage_collecting\fR\&, \fIwaiting\fR\& (for a message), \fIrunning\fR\&, \fIrunnable\fR\& (ready to run, but another process is running), or \fIsuspended\fR\& (suspended on a "busy" port or by the \fIerlang:suspend_process/[1,2]\fR\& BIF)\&.
.TP 2
.B
\fI{suspending, SuspendeeList}\fR\&:
\fISuspendeeList\fR\& is a list of \fI{Suspendee, ActiveSuspendCount, OutstandingSuspendCount}\fR\& tuples\&. \fISuspendee\fR\& is the pid of a process that have been or is to be suspended by the process identified by \fIPid\fR\& via the \fBerlang:suspend_process/2\fR\& BIF, or the \fBerlang:suspend_process/1\fR\& BIF\&. \fIActiveSuspendCount\fR\& is the number of times the \fISuspendee\fR\& has been suspended by \fIPid\fR\&\&. \fIOutstandingSuspendCount\fR\& is the number of not yet completed suspend requests sent by \fIPid\fR\&\&. That is, if \fIActiveSuspendCount =/= 0\fR\&, \fISuspendee\fR\& is currently in the suspended state, and if \fIOutstandingSuspendCount =/= 0\fR\& the \fIasynchronous\fR\& option of \fIerlang:suspend_process/2\fR\& has been used and the suspendee has not yet been suspended by \fIPid\fR\&\&. Note that the \fIActiveSuspendCount\fR\& and \fIOutstandingSuspendCount\fR\& are not the total suspend count on \fISuspendee\fR\&, only the parts contributed by \fIPid\fR\&\&.
.TP 2
.B
\fI{total_heap_size, Size}\fR\&:
\fISize\fR\& is the total size in words of all heap fragments of the process\&. This currently include the stack of the process\&.
.TP 2
.B
\fI{trace, InternalTraceFlags}\fR\&:
\fIInternalTraceFlags\fR\& is an integer representing internal trace flag for this process\&. This \fIInfoTuple\fR\& may be changed or removed without prior notice\&.
.TP 2
.B
\fI{trap_exit, Boolean}\fR\&:
\fIBoolean\fR\& is \fItrue\fR\& if the process is trapping exits, otherwise it is \fIfalse\fR\&\&.
.RE
.LP
Note however, that not all implementations support every one of the above \fIItem\fR\&s\&.
.LP
Failure: \fIbadarg\fR\& if \fIPid\fR\& is not a local process, or if \fIItem\fR\& is not a valid \fIItem\fR\&\&.
.RE
.LP
.nf

.B
processes() -> [pid()]
.br
.fi
.br
.RS
.LP
Returns a list of process identifiers corresponding to all the processes currently existing on the local node\&.
.LP
Note that a process that is exiting, exists but is not alive, i\&.e\&., \fIis_process_alive/1\fR\& will return \fIfalse\fR\& for a process that is exiting, but its process identifier will be part of the result returned from \fIprocesses/0\fR\&\&.
.LP
.nf

> processes()\&.
[<0.0.0>,<0.2.0>,<0.4.0>,<0.5.0>,<0.7.0>,<0.8.0>]
.fi
.RE
.LP
.nf

.B
purge_module(Module) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = atom()
.br
.RE
.RE
.RS
.LP
Removes old code for \fIModule\fR\&\&. Before this BIF is used, \fIerlang:check_process_code/2\fR\& should be called to check that no processes are executing old code in the module\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for the code server (see \fBcode(3)\fR\&) and should not be used elsewhere\&.

.LP
Failure: \fIbadarg\fR\& if there is no old code for \fIModule\fR\&\&.
.RE
.LP
.nf

.B
put(Key, Val) -> term()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Val = term()
.br
.RE
.RE
.RS
.LP
Adds a new \fIKey\fR\& to the process dictionary, associated with the value \fIVal\fR\&, and returns \fIundefined\fR\&\&. If \fIKey\fR\& already exists, the old value is deleted and replaced by \fIVal\fR\& and the function returns the old value\&.
.LP

.RS -4
.B
Note:
.RE
The values stored when \fIput\fR\& is evaluated within the scope of a \fIcatch\fR\& will not be retracted if a \fIthrow\fR\& is evaluated, or if an error occurs\&.

.LP
.nf

> X = put(name, walrus), Y = put(name, carpenter),
Z = get(name),
{X, Y, Z}\&.
{undefined,walrus,carpenter}
.fi
.RE
.LP
.nf

.B
erlang:raise(Class, Reason, Stacktrace) -> no_return()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Class = error | exit | throw
.br
Reason = term()
.br
Stacktrace = \fBraise_stacktrace()\fR\&
.br
.nf
\fBraise_stacktrace()\fR\& = [{module(), atom(), arity() | [term()]} |
.br
                      {function(), [term()]}]
.br
                   | [{module(),
.br
                       atom(),
.br
                       arity() | [term()],
.br
                       [{atom(), term()}]} |
.br
                      {function(),
.br
                       [term()],
.br
                       [{atom(), term()}]}]
.fi
.br
.RE
.RE
.RS
.LP
Stops the execution of the calling process with an exception of given class, reason and call stack backtrace (\fIstacktrace\fR\&)\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for debugging and for use in the Erlang operating system\&. In general, it should be avoided in applications, unless you know very well what you are doing\&.

.LP
\fIClass\fR\& is one of \fIerror\fR\&, \fIexit\fR\& or \fIthrow\fR\&, so if it were not for the stacktrace \fIerlang:raise(Class, Reason, Stacktrace)\fR\& is equivalent to \fIerlang:Class(Reason)\fR\&\&. \fIReason\fR\& is any term and \fIStacktrace\fR\& is a list as returned from \fIget_stacktrace()\fR\&, that is a list of 4-tuples \fI{Module, Function, Arity | Args, Location}\fR\& where \fIModule\fR\& and \fIFunction\fR\& are atoms and the third element is an integer arity or an argument list\&. The stacktrace may also contain \fI{Fun, Args, Location}\fR\& tuples where \fIFun\fR\& is a local fun and \fIArgs\fR\& is an argument list\&.
.LP
The \fILocation\fR\& element at the end is optional\&. Omitting it is equivalent to specifying an empty list\&.
.LP
The stacktrace is used as the exception stacktrace for the calling process; it will be truncated to the current maximum stacktrace depth\&.
.LP
Because evaluating this function causes the process to terminate, it has no return value - unless the arguments are invalid, in which case the function \fIreturns the error reason\fR\&, that is \fIbadarg\fR\&\&. If you want to be really sure not to return you can call \fIerror(erlang:raise(Class, Reason, Stacktrace))\fR\& and hope to distinguish exceptions later\&.
.RE
.LP
.nf

.B
erlang:read_timer(TimerRef) -> integer() >= 0 | false
.br
.fi
.br
.RS
.LP
Types:

.RS 3
TimerRef = reference()
.br
.RE
.RE
.RS
.LP
\fITimerRef\fR\& is a timer reference returned by \fBerlang:send_after/3\fR\& or \fBerlang:start_timer/3\fR\&\&. If the timer is active, the function returns the time in milliseconds left until the timer will expire, otherwise \fIfalse\fR\& (which means that \fITimerRef\fR\& was never a timer, that it has been cancelled, or that it has already delivered its message)\&.
.LP
See also \fBerlang:send_after/3\fR\&, \fBerlang:start_timer/3\fR\&, and \fBerlang:cancel_timer/1\fR\&\&.
.RE
.LP
.nf

.B
erlang:ref_to_list(Ref) -> string()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Ref = reference()
.br
.RE
.RE
.RS
.LP
Returns a string which corresponds to the text representation of \fIRef\fR\&\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for debugging and for use in the Erlang operating system\&. It should not be used in application programs\&.

.RE
.LP
.nf

.B
register(RegName, PidOrPort) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
RegName = atom()
.br
PidOrPort = port() | pid()
.br
.RE
.RE
.RS
.LP
Associates the name \fIRegName\fR\& with a pid or a port identifier\&. \fIRegName\fR\&, which must be an atom, can be used instead of the pid / port identifier in the send operator (\fIRegName ! Message\fR\&)\&.
.LP
.nf

> register(db, Pid)\&.
true
.fi
.LP
Failure: \fIbadarg\fR\& if \fIPidOrPort\fR\& is not an existing, local process or port, if \fIRegName\fR\& is already in use, if the process or port is already registered (already has a name), or if \fIRegName\fR\& is the atom \fIundefined\fR\&\&.
.RE
.LP
.nf

.B
registered() -> [RegName]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
RegName = atom()
.br
.RE
.RE
.RS
.LP
Returns a list of names which have been registered using \fBregister/2\fR\&\&.
.LP
.nf

> registered()\&.
[code_server, file_server, init, user, my_db]
.fi
.RE
.LP
.nf

.B
erlang:resume_process(Suspendee) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Suspendee = pid()
.br
.RE
.RE
.RS
.LP
Decreases the suspend count on the process identified by \fISuspendee\fR\&\&. \fISuspendee\fR\& should previously have been suspended via \fBerlang:suspend_process/2\fR\&, or \fBerlang:suspend_process/1\fR\& by the process calling \fIerlang:resume_process(Suspendee)\fR\&\&. When the suspend count on \fISuspendee\fR\& reach zero, \fISuspendee\fR\& will be resumed, i\&.e\&., the state of the \fISuspendee\fR\& is changed from suspended into the state \fISuspendee\fR\& was in before it was suspended\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for debugging only\&.

.LP
Failures:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
 If \fISuspendee\fR\& isn\&'t a process identifier\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If the process calling \fIerlang:resume_process/1\fR\& had not previously increased the suspend count on the process identified by \fISuspendee\fR\&\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If the process identified by \fISuspendee\fR\& is not alive\&. 
.RE
.RE
.LP
.nf

.B
round(Number) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Number = number()
.br
.RE
.RE
.RS
.LP
Returns an integer by rounding \fINumber\fR\&\&.
.LP
.nf

> round(5\&.5)\&.
6
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
self() -> pid()
.br
.fi
.br
.RS
.LP
Returns the pid (process identifier) of the calling process\&.
.LP
.nf

> self()\&.
<0.26.0>
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
erlang:send(Dest, Msg) -> Msg
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Dest = \fBdst()\fR\&
.br
Msg = term()
.br
.nf
\fBdst()\fR\& = pid()
.br
      | port()
.br
      | (RegName :: atom())
.br
      | {RegName :: atom(), Node :: node()}
.fi
.br
.RE
.RE
.RS
.LP
Sends a message and returns \fIMsg\fR\&\&. This is the same as \fIDest ! Msg\fR\&\&.
.LP
\fIDest\fR\& may be a remote or local pid, a (local) port, a locally registered name, or a tuple \fI{RegName, Node}\fR\& for a registered name at another node\&.
.RE
.LP
.nf

.B
erlang:send(Dest, Msg, Options) -> Res
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Dest = \fBdst()\fR\&
.br
Msg = term()
.br
Options = [nosuspend | noconnect]
.br
Res = ok | nosuspend | noconnect
.br
.nf
\fBdst()\fR\& = pid()
.br
      | port()
.br
      | (RegName :: atom())
.br
      | {RegName :: atom(), Node :: node()}
.fi
.br
.RE
.RE
.RS
.LP
Sends a message and returns \fIok\fR\&, or does not send the message but returns something else (see below)\&. Otherwise the same as \fBerlang:send/2\fR\&\&. See also \fBerlang:send_nosuspend/2,3\fR\&\&. for more detailed explanation and warnings\&.
.LP
The possible options are:
.RS 2
.TP 2
.B
\fInosuspend\fR\&:
If the sender would have to be suspended to do the send, \fInosuspend\fR\& is returned instead\&.
.TP 2
.B
\fInoconnect\fR\&:
If the destination node would have to be auto-connected before doing the send, \fInoconnect\fR\& is returned instead\&.
.RE
.LP

.RS -4
.B
Warning:
.RE
As with \fIerlang:send_nosuspend/2,3\fR\&: Use with extreme care!

.RE
.LP
.nf

.B
erlang:send_after(Time, Dest, Msg) -> TimerRef
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Time = integer() >= 0
.br
.RS 2
0 <= Time <= 4294967295
.RE
Dest = pid() | atom()
.br
Msg = term()
.br
TimerRef = reference()
.br
.RE
.RE
.RS
.LP
Starts a timer which will send the message \fIMsg\fR\& to \fIDest\fR\& after \fITime\fR\& milliseconds\&.
.LP
If \fIDest\fR\& is a \fIpid()\fR\& it has to be a \fIpid()\fR\& of a local process, dead or alive\&.
.LP
The \fITime\fR\& value can, in the current implementation, not be greater than 4294967295\&.
.LP
If \fIDest\fR\& is an \fIatom()\fR\&, it is supposed to be the name of a registered process\&. The process referred to by the name is looked up at the time of delivery\&. No error is given if the name does not refer to a process\&.
.LP
If \fIDest\fR\& is a \fIpid()\fR\&, the timer will be automatically canceled if the process referred to by the \fIpid()\fR\& is not alive, or when the process exits\&. This feature was introduced in erts version 5\&.4\&.11\&. Note that timers will not be automatically canceled when \fIDest\fR\& is an \fIatom\fR\&\&.
.LP
See also \fBerlang:start_timer/3\fR\&, \fBerlang:cancel_timer/1\fR\&, and \fBerlang:read_timer/1\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if the arguments does not satisfy the requirements specified above\&.
.RE
.LP
.nf

.B
erlang:send_nosuspend(Dest, Msg) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Dest = \fBdst()\fR\&
.br
Msg = term()
.br
.nf
\fBdst()\fR\& = pid()
.br
      | port()
.br
      | (RegName :: atom())
.br
      | {RegName :: atom(), Node :: node()}
.fi
.br
.RE
.RE
.RS
.LP
The same as \fBerlang:send(Dest, Msg, [nosuspend])\fR\&, but returns \fItrue\fR\& if the message was sent and \fIfalse\fR\& if the message was not sent because the sender would have had to be suspended\&.
.LP
This function is intended for send operations towards an unreliable remote node without ever blocking the sending (Erlang) process\&. If the connection to the remote node (usually not a real Erlang node, but a node written in C or Java) is overloaded, this function \fIwill not send the message\fR\& but return \fIfalse\fR\& instead\&.
.LP
The same happens, if \fIDest\fR\& refers to a local port that is busy\&. For all other destinations (allowed for the ordinary send operator \fI\&'!\&'\fR\&) this function sends the message and returns \fItrue\fR\&\&.
.LP
This function is only to be used in very rare circumstances where a process communicates with Erlang nodes that can disappear without any trace causing the TCP buffers and the drivers queue to be over-full before the node will actually be shut down (due to tick timeouts) by \fInet_kernel\fR\&\&. The normal reaction to take when this happens is some kind of premature shutdown of the other node\&.
.LP
Note that ignoring the return value from this function would result in \fIunreliable\fR\& message passing, which is contradictory to the Erlang programming model\&. The message is \fInot\fR\& sent if this function returns \fIfalse\fR\&\&.
.LP
Note also that in many systems, transient states of overloaded queues are normal\&. The fact that this function returns \fIfalse\fR\& does not in any way mean that the other node is guaranteed to be non-responsive, it could be a temporary overload\&. Also a return value of \fItrue\fR\& does only mean that the message could be sent on the (TCP) channel without blocking, the message is not guaranteed to have arrived at the remote node\&. Also in the case of a disconnected non-responsive node, the return value is \fItrue\fR\& (mimics the behaviour of the \fI!\fR\& operator)\&. The expected behaviour as well as the actions to take when the function returns \fIfalse\fR\& are application and hardware specific\&.
.LP

.RS -4
.B
Warning:
.RE
Use with extreme care!

.RE
.LP
.nf

.B
erlang:send_nosuspend(Dest, Msg, Options) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Dest = \fBdst()\fR\&
.br
Msg = term()
.br
Options = [noconnect]
.br
.nf
\fBdst()\fR\& = pid()
.br
      | port()
.br
      | (RegName :: atom())
.br
      | {RegName :: atom(), Node :: node()}
.fi
.br
.RE
.RE
.RS
.LP
The same as \fBerlang:send(Dest, Msg, [nosuspend | Options])\fR\&, but with boolean return value\&.
.LP
This function behaves like \fBerlang:send_nosuspend/2)\fR\&, but takes a third parameter, a list of options\&. The only currently implemented option is \fInoconnect\fR\&\&. The option \fInoconnect\fR\& makes the function return \fIfalse\fR\& if the remote node is not currently reachable by the local node\&. The normal behaviour is to try to connect to the node, which may stall the process for a shorter period\&. The use of the \fInoconnect\fR\& option makes it possible to be absolutely sure not to get even the slightest delay when sending to a remote process\&. This is especially useful when communicating with nodes who expect to always be the connecting part (i\&.e\&. nodes written in C or Java)\&.
.LP
Whenever the function returns \fIfalse\fR\& (either when a suspend would occur or when \fInoconnect\fR\& was specified and the node was not already connected), the message is guaranteed \fInot\fR\& to have been sent\&.
.LP

.RS -4
.B
Warning:
.RE
Use with extreme care!

.RE
.LP
.nf

.B
erlang:set_cookie(Node, Cookie) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
Cookie = atom()
.br
.RE
.RE
.RS
.LP
Sets the magic cookie of \fINode\fR\& to the atom \fICookie\fR\&\&. If \fINode\fR\& is the local node, the function also sets the cookie of all other unknown nodes to \fICookie\fR\& (see \fBDistributed Erlang\fR\& in the Erlang Reference Manual)\&.
.LP
Failure: \fIfunction_clause\fR\& if the local node is not alive\&.
.RE
.LP
.nf

.B
setelement(Index, Tuple1, Value) -> Tuple2
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Index = integer() >= 1
.br
.RS 2
1\&.\&.tuple_size(Tuple1)
.RE
Tuple1 = Tuple2 = tuple()
.br
Value = term()
.br
.RE
.RE
.RS
.LP
Returns a tuple which is a copy of the argument \fITuple1\fR\& with the element given by the integer argument \fIIndex\fR\& (the first element is the element with index 1) replaced by the argument \fIValue\fR\&\&.
.LP
.nf

> setelement(2, {10, green, bottles}, red)\&.
{10,red,bottles}
.fi
.RE
.LP
.nf

.B
size(Item) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Item = tuple() | binary()
.br
.RE
.RE
.RS
.LP
Returns an integer which is the size of the argument \fIItem\fR\&, which must be either a tuple or a binary\&.
.LP
.nf

> size({morni, mulle, bwange})\&.
3
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
spawn(Fun) -> pid()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Fun = function()
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIFun\fR\& to the empty list \fI[]\fR\&\&. Otherwise works like \fBspawn/3\fR\&\&.
.RE
.LP
.nf

.B
spawn(Node, Fun) -> pid()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
Fun = function()
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIFun\fR\& to the empty list \fI[]\fR\& on \fINode\fR\&\&. If \fINode\fR\& does not exist, a useless pid is returned\&. Otherwise works like \fBspawn/3\fR\&\&.
.RE
.LP
.nf

.B
spawn(Module, Function, Args) -> pid()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Function = atom()
.br
Args = [term()]
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIModule:Function\fR\& to \fIArgs\fR\&\&. The new process created will be placed in the system scheduler queue and be run some time later\&.
.LP
\fIerror_handler:undefined_function(Module, Function, Args)\fR\& is evaluated by the new process if \fIModule:Function/Arity\fR\& does not exist (where \fIArity\fR\& is the length of \fIArgs\fR\&)\&. The error handler can be redefined (see \fBprocess_flag/2\fR\&)\&. If \fIerror_handler\fR\& is undefined, or the user has redefined the default \fIerror_handler\fR\& its replacement is undefined, a failure with the reason \fIundef\fR\& will occur\&.
.LP
.nf

> spawn(speed, regulator, [high_speed, thin_cut])\&.
<0.13.1>
.fi
.RE
.LP
.nf

.B
spawn(Node, Module, Function, Args) -> pid()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
Module = module()
.br
Function = atom()
.br
Args = [term()]
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIModule:Function\fR\& to \fIArgs\fR\& on \fINode\fR\&\&. If \fINode\fR\& does not exists, a useless pid is returned\&. Otherwise works like \fBspawn/3\fR\&\&.
.RE
.LP
.nf

.B
spawn_link(Fun) -> pid()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Fun = function()
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIFun\fR\& to the empty list []\&. A link is created between the calling process and the new process, atomically\&. Otherwise works like \fBspawn/3\fR\&\&.
.RE
.LP
.nf

.B
spawn_link(Node, Fun) -> pid()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
Fun = function()
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIFun\fR\& to the empty list [] on \fINode\fR\&\&. A link is created between the calling process and the new process, atomically\&. If \fINode\fR\& does not exist, a useless pid is returned (and due to the link, an exit signal with exit reason \fInoconnection\fR\& will be received)\&. Otherwise works like \fBspawn/3\fR\&\&.
.RE
.LP
.nf

.B
spawn_link(Module, Function, Args) -> pid()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Function = atom()
.br
Args = [term()]
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIModule:Function\fR\& to \fIArgs\fR\&\&. A link is created between the calling process and the new process, atomically\&. Otherwise works like \fBspawn/3\fR\&\&.
.RE
.LP
.nf

.B
spawn_link(Node, Module, Function, Args) -> pid()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
Module = module()
.br
Function = atom()
.br
Args = [term()]
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIModule:Function\fR\& to \fIArgs\fR\& on \fINode\fR\&\&. A link is created between the calling process and the new process, atomically\&. If \fINode\fR\& does not exist, a useless pid is returned (and due to the link, an exit signal with exit reason \fInoconnection\fR\& will be received)\&. Otherwise works like \fBspawn/3\fR\&\&.
.RE
.LP
.nf

.B
spawn_monitor(Fun) -> {pid(), reference()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Fun = function()
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIFun\fR\& to the empty list [] and reference for a monitor created to the new process\&. Otherwise works like \fBspawn/3\fR\&\&.
.RE
.LP
.nf

.B
spawn_monitor(Module, Function, Args) -> {pid(), reference()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Function = atom()
.br
Args = [term()]
.br
.RE
.RE
.RS
.LP
A new process is started by the application of \fIModule:Function\fR\& to \fIArgs\fR\&, and the process is monitored at the same time\&. Returns the pid and a reference for the monitor\&. Otherwise works like \fBspawn/3\fR\&\&.
.RE
.LP
.nf

.B
spawn_opt(Fun, Options) -> pid() | {pid(), reference()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Fun = function()
.br
Options = [Option]
.br
Option = link
.br
       | monitor
.br
       | {priority, Level :: \fBpriority_level()\fR\&}
.br
       | {fullsweep_after, Number :: integer() >= 0}
.br
       | {min_heap_size, Size :: integer() >= 0}
.br
       | {min_bin_vheap_size, VSize :: integer() >= 0}
.br
.nf
\fBpriority_level()\fR\& = low | normal | high | max
.fi
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIFun\fR\& to the empty list \fI[]\fR\&\&. Otherwise works like \fBspawn_opt/4\fR\&\&.
.LP
If the option \fImonitor\fR\& is given, the newly created process will be monitored and both the pid and reference for the monitor will be returned\&.
.RE
.LP
.nf

.B
spawn_opt(Node, Fun, Options) -> pid() | {pid(), reference()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
Fun = function()
.br
Options = [Option]
.br
Option = link
.br
       | monitor
.br
       | {priority, Level :: \fBpriority_level()\fR\&}
.br
       | {fullsweep_after, Number :: integer() >= 0}
.br
       | {min_heap_size, Size :: integer() >= 0}
.br
       | {min_bin_vheap_size, VSize :: integer() >= 0}
.br
.nf
\fBpriority_level()\fR\& = low | normal | high | max
.fi
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIFun\fR\& to the empty list \fI[]\fR\& on \fINode\fR\&\&. If \fINode\fR\& does not exist, a useless pid is returned\&. Otherwise works like \fBspawn_opt/4\fR\&\&.
.RE
.LP
.nf

.B
spawn_opt(Module, Function, Args, Options) ->
.B
             pid() | {pid(), reference()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Function = atom()
.br
Args = [term()]
.br
Options = [Option]
.br
Option = link
.br
       | monitor
.br
       | {priority, Level :: \fBpriority_level()\fR\&}
.br
       | {fullsweep_after, Number :: integer() >= 0}
.br
       | {min_heap_size, Size :: integer() >= 0}
.br
       | {min_bin_vheap_size, VSize :: integer() >= 0}
.br
.nf
\fBpriority_level()\fR\& = low | normal | high | max
.fi
.br
.RE
.RE
.RS
.LP
Works exactly like \fBspawn/3\fR\&, except that an extra option list is given when creating the process\&.
.LP
If the option \fImonitor\fR\& is given, the newly created process will be monitored and both the pid and reference for the monitor will be returned\&.
.RS 2
.TP 2
.B
\fIlink\fR\&:
Sets a link to the parent process (like \fIspawn_link/3\fR\& does)\&.
.TP 2
.B
\fImonitor\fR\&:
Monitor the new process (just like \fBmonitor/2\fR\& does)\&.
.TP 2
.B
\fI{priority, Level}\fR\&:
Sets the priority of the new process\&. Equivalent to executing \fBprocess_flag(priority, Level)\fR\& in the start function of the new process, except that the priority will be set before the process is selected for execution for the first time\&. For more information on priorities see \fBprocess_flag(priority, Level)\fR\&\&.
.TP 2
.B
\fI{fullsweep_after, Number}\fR\&:
This option is only useful for performance tuning\&. In general, you should not use this option unless you know that there is problem with execution times and/or memory consumption, and you should measure to make sure that the option improved matters\&.
.RS 2
.LP
The Erlang runtime system uses a generational garbage collection scheme, using an "old heap" for data that has survived at least one garbage collection\&. When there is no more room on the old heap, a fullsweep garbage collection will be done\&.
.RE
.RS 2
.LP
The \fIfullsweep_after\fR\& option makes it possible to specify the maximum number of generational collections before forcing a fullsweep even if there is still room on the old heap\&. Setting the number to zero effectively disables the general collection algorithm, meaning that all live data is copied at every garbage collection\&.
.RE
.RS 2
.LP
Here are a few cases when it could be useful to change \fIfullsweep_after\fR\&\&. Firstly, if binaries that are no longer used should be thrown away as soon as possible\&. (Set \fINumber\fR\& to zero\&.) Secondly, a process that mostly have short-lived data will be fullsweeped seldom or never, meaning that the old heap will contain mostly garbage\&. To ensure a fullsweep once in a while, set \fINumber\fR\& to a suitable value such as 10 or 20\&. Thirdly, in embedded systems with limited amount of RAM and no virtual memory, one might want to preserve memory by setting \fINumber\fR\& to zero\&. (The value may be set globally, see \fBerlang:system_flag/2\fR\&\&.)
.RE
.TP 2
.B
\fI{min_heap_size, Size}\fR\&:
This option is only useful for performance tuning\&. In general, you should not use this option unless you know that there is problem with execution times and/or memory consumption, and you should measure to make sure that the option improved matters\&.
.RS 2
.LP
Gives a minimum heap size in words\&. Setting this value higher than the system default might speed up some processes because less garbage collection is done\&. Setting too high value, however, might waste memory and slow down the system due to worse data locality\&. Therefore, it is recommended to use this option only for fine-tuning an application and to measure the execution time with various \fISize\fR\& values\&.
.RE
.TP 2
.B
\fI{min_bin_vheap_size, VSize}\fR\&:
This option is only useful for performance tuning\&. In general, you should not use this option unless you know that there is problem with execution times and/or memory consumption, and you should measure to make sure that the option improved matters\&.
.RS 2
.LP
Gives a minimum binary virtual heap size in words\&. Setting this value higher than the system default might speed up some processes because less garbage collection is done\&. Setting too high value, however, might waste memory\&. Therefore, it is recommended to use this option only for fine-tuning an application and to measure the execution time with various \fIVSize\fR\& values\&.
.RE
.RE
.RE
.LP
.nf

.B
spawn_opt(Node, Module, Function, Args, Options) ->
.B
             pid() | {pid(), reference()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Node = node()
.br
Module = module()
.br
Function = atom()
.br
Args = [term()]
.br
Options = [Option]
.br
Option = link
.br
       | monitor
.br
       | {priority, Level :: \fBpriority_level()\fR\&}
.br
       | {fullsweep_after, Number :: integer() >= 0}
.br
       | {min_heap_size, Size :: integer() >= 0}
.br
       | {min_bin_vheap_size, VSize :: integer() >= 0}
.br
.nf
\fBpriority_level()\fR\& = low | normal | high | max
.fi
.br
.RE
.RE
.RS
.LP
Returns the pid of a new process started by the application of \fIModule:Function\fR\& to \fIArgs\fR\& on \fINode\fR\&\&. If \fINode\fR\& does not exist, a useless pid is returned\&. Otherwise works like \fBspawn_opt/4\fR\&\&.
.RE
.LP
.nf

.B
split_binary(Bin, Pos) -> {binary(), binary()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Bin = binary()
.br
Pos = integer() >= 0
.br
.RS 2
0\&.\&.byte_size(Bin)
.RE
.RE
.RE
.RS
.LP
Returns a tuple containing the binaries which are the result of splitting \fIBin\fR\& into two parts at position \fIPos\fR\&\&. This is not a destructive operation\&. After the operation, there will be three binaries altogether\&.
.LP
.nf

> B = list_to_binary("0123456789")\&.
<<"0123456789">>
> byte_size(B)\&.
10
> {B1, B2} = split_binary(B,3)\&.
{<<"012">>,<<"3456789">>}
> byte_size(B1)\&.
3
> byte_size(B2)\&.
7
.fi
.RE
.LP
.nf

.B
erlang:start_timer(Time, Dest, Msg) -> TimerRef
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Time = integer() >= 0
.br
.RS 2
0 <= Time <= 4294967295
.RE
Dest = pid() | atom()
.br
Msg = term()
.br
TimerRef = reference()
.br
.RE
.RE
.RS
.LP
Starts a timer which will send the message \fI{timeout, TimerRef, Msg}\fR\& to \fIDest\fR\& after \fITime\fR\& milliseconds\&.
.LP
If \fIDest\fR\& is a \fIpid()\fR\& it has to be a \fIpid()\fR\& of a local process, dead or alive\&.
.LP
The \fITime\fR\& value can, in the current implementation, not be greater than 4294967295\&.
.LP
If \fIDest\fR\& is an \fIatom()\fR\&, it is supposed to be the name of a registered process\&. The process referred to by the name is looked up at the time of delivery\&. No error is given if the name does not refer to a process\&.
.LP
If \fIDest\fR\& is a \fIpid()\fR\&, the timer will be automatically canceled if the process referred to by the \fIpid()\fR\& is not alive, or when the process exits\&. This feature was introduced in erts version 5\&.4\&.11\&. Note that timers will not be automatically canceled when \fIDest\fR\& is an \fIatom()\fR\&\&.
.LP
See also \fBerlang:send_after/3\fR\&, \fBerlang:cancel_timer/1\fR\&, and \fBerlang:read_timer/1\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if the arguments does not satisfy the requirements specified above\&.
.RE
.LP
.nf

.B
statistics(Item :: context_switches) -> {ContextSwitches, 0}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
ContextSwitches = integer() >= 0
.br
.RE
.RE
.RS
.LP
\fIContextSwitches\fR\& is the total number of context switches since the system started\&.
.RE
.LP
.nf

.B
statistics(Item :: exact_reductions) ->
.B
              {Total_Exact_Reductions,
.B
               Exact_Reductions_Since_Last_Call}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Total_Exact_Reductions = Exact_Reductions_Since_Last_Call = integer() >= 0
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Note:
.RE
\fIstatistics(exact_reductions)\fR\& is a more expensive operation than \fBstatistics(reductions)\fR\& especially on an Erlang machine with SMP support\&.

.RE
.LP
.nf

.B
statistics(Item :: garbage_collection) ->
.B
              {Number_of_GCs, Words_Reclaimed, 0}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Number_of_GCs = Words_Reclaimed = integer() >= 0
.br
.RE
.RE
.RS
.LP
This information may not be valid for all implementations\&.
.LP
.nf

> statistics(garbage_collection)\&.
{85,23961,0}

.fi
.RE
.LP
.nf

.B
statistics(Item :: io) -> {{input, Input}, {output, Output}}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Input = Output = integer() >= 0
.br
.RE
.RE
.RS
.LP
\fIInput\fR\& is the total number of bytes received through ports, and \fIOutput\fR\& is the total number of bytes output to ports\&.
.RE
.LP
.nf

.B
statistics(Item :: reductions) ->
.B
              {Total_Reductions, Reductions_Since_Last_Call}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Total_Reductions = Reductions_Since_Last_Call = integer() >= 0
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Note:
.RE
Since erts-5\&.5 (OTP release R11B) this value does not include reductions performed in current time slices of currently scheduled processes\&. If an exact value is wanted, use \fBstatistics(exact_reductions)\fR\&\&.

.LP
.nf

> statistics(reductions)\&.
{2046,11}

.fi
.RE
.LP
.nf

.B
statistics(Item :: run_queue) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Returns the total length of the run queues, that is, the number of processes that are ready to run on all available run queues\&.
.RE
.LP
.nf

.B
statistics(Item :: runtime) ->
.B
              {Total_Run_Time, Time_Since_Last_Call}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Total_Run_Time = Time_Since_Last_Call = integer() >= 0
.br
.RE
.RE
.RS
.LP
Note that the run-time is the sum of the run-time for all threads in the Erlang run-time system and may therefore be greater than the wall-clock time\&.
.LP
.nf

> statistics(runtime)\&.
{1690,1620}

.fi
.RE
.LP
.nf

.B
statistics(Item :: scheduler_wall_time) ->
.B
              [{SchedulerId, ActiveTime, TotalTime}] | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
SchedulerId = integer() >= 1
.br
ActiveTime = TotalTime = integer() >= 0
.br
.RE
.RE
.RS
.LP
Returns a list of tuples with \fI{SchedulerId, ActiveTime, TotalTime}\fR\&, where \fISchedulerId\fR\& is an integer id of the scheduler, \fIActiveTime\fR\& is the duration the scheduler has been busy, \fITotalTime\fR\& is the total time duration since \fBscheduler_wall_time\fR\& activation\&. The time unit is not defined and may be subject to change between releases, operating systems and system restarts\&. \fIscheduler_wall_time\fR\& should only be used to calculate relative values for scheduler-utilization\&. \fIActiveTime\fR\& can never exceed \fITotalTime\fR\&\&.
.LP
The definition of a busy scheduler is when it is not idle or not scheduling (selecting) a process or port, meaning; executing process code, executing linked-in-driver or NIF code, executing built-in-functions or any other runtime handling, garbage collecting or handling any other memory management\&. Note, a scheduler may also be busy even if the operating system has scheduled out the scheduler thread\&.
.LP
Returns \fIundefined\fR\& if the system flag \fBscheduler_wall_time\fR\& is turned off\&.
.LP
The list of scheduler information is unsorted and may appear in different order between calls\&.
.LP
Using \fIscheduler_wall_time\fR\& to calculate scheduler utilization\&.
.LP
.nf

> erlang:system_flag(scheduler_wall_time, true)\&.
false
> Ts0 = lists:sort(erlang:statistics(scheduler_wall_time)), ok\&.
ok

.fi
.LP
Some time later we will take another snapshot and calculate scheduler-utilization per scheduler\&.
.LP
.nf

> Ts1 = lists:sort(erlang:statistics(scheduler_wall_time)), ok\&.
ok
> lists:map(fun({{I, A0, T0}, {I, A1, T1}}) -> {I, (A1 - A0)/(T1 - T0)} end, lists:zip(Ts0,Ts1))\&.
[{1,0.9743474730177548},
 {2,0.9744843782751444},
 {3,0.9995902361669045},
 {4,0.9738012596572161},
 {5,0.9717956667018103},
 {6,0.9739235846420741},
 {7,0.973237033077876},
 {8,0.9741297293248656}]

.fi
.LP
Using the same snapshots to calculate a total scheduler-utilization\&.
.LP
.nf

> {A, T} = lists:foldl(fun({{_, A0, T0}, {_, A1, T1}}, {Ai,Ti}) -> {Ai + (A1 - A0), Ti + (T1 - T0)} end, {0, 0}, lists:zip(Ts0,Ts1)), A/T\&.
0.9769136803764825

.fi
.LP

.RS -4
.B
Note:
.RE
\fIscheduler_wall_time\fR\& is by default disabled\&. Use \fIerlang:system_flag(scheduler_wall_time, true)\fR\& to enable it\&.

.RE
.LP
.nf

.B
statistics(Item :: wall_clock) ->
.B
              {Total_Wallclock_Time,
.B
               Wallclock_Time_Since_Last_Call}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Total_Wallclock_Time = Wallclock_Time_Since_Last_Call = integer() >= 0
.br
.RE
.RE
.RS
.LP
\fIwall_clock\fR\& can be used in the same manner as \fIruntime\fR\&, except that real time is measured as opposed to runtime or CPU time\&.
.RE
.LP
.nf

.B
erlang:suspend_process(Suspendee, OptList) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Suspendee = pid()
.br
OptList = [Opt]
.br
Opt = unless_suspending | asynchronous
.br
.RE
.RE
.RS
.LP
Increases the suspend count on the process identified by \fISuspendee\fR\& and puts it in the suspended state if it isn\&'t already in the suspended state\&. A suspended process will not be scheduled for execution until the process has been resumed\&.
.LP
A process can be suspended by multiple processes and can be suspended multiple times by a single process\&. A suspended process will not leave the suspended state until its suspend count reach zero\&. The suspend count of \fISuspendee\fR\& is decreased when \fBerlang:resume_process(Suspendee)\fR\& is called by the same process that called \fIerlang:suspend_process(Suspendee)\fR\&\&. All increased suspend counts on other processes acquired by a process will automatically be decreased when the process terminates\&.
.LP
Currently the following options (\fIOpt\fR\&s) are available:
.RS 2
.TP 2
.B
\fIasynchronous\fR\&:
 A suspend request is sent to the process identified by \fISuspendee\fR\&\&. \fISuspendee\fR\& will eventually suspend unless it is resumed before it was able to suspend\&. The caller of \fIerlang:suspend_process/2\fR\& will return immediately, regardless of whether the \fISuspendee\fR\& has suspended yet or not\&. Note that the point in time when the \fISuspendee\fR\& will actually suspend cannot be deduced from other events in the system\&. The only guarantee given is that the \fISuspendee\fR\& will \fIeventually\fR\& suspend (unless it is resumed)\&. If the \fIasynchronous\fR\& option has \fInot\fR\& been passed, the caller of \fIerlang:suspend_process/2\fR\& will be blocked until the \fISuspendee\fR\& has actually suspended\&. 
.TP 2
.B
\fIunless_suspending\fR\&:
 The process identified by \fISuspendee\fR\& will be suspended unless the calling process already is suspending the \fISuspendee\fR\&\&. If \fIunless_suspending\fR\& is combined with the \fIasynchronous\fR\& option, a suspend request will be sent unless the calling process already is suspending the \fISuspendee\fR\& or if a suspend request already has been sent and is in transit\&. If the calling process already is suspending the \fISuspendee\fR\&, or if combined with the \fIasynchronous\fR\& option and a send request already is in transit, \fIfalse\fR\& is returned and the suspend count on \fISuspendee\fR\& will remain unchanged\&. 
.RE
.LP
If the suspend count on the process identified by \fISuspendee\fR\& was increased, \fItrue\fR\& is returned; otherwise, \fIfalse\fR\& is returned\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for debugging only\&.

.LP
Failures:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
 If \fISuspendee\fR\& isn\&'t a process identifier\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If the process identified by \fISuspendee\fR\& is same the process as the process calling \fIerlang:suspend_process/2\fR\&\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If the process identified by \fISuspendee\fR\& is not alive\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If the process identified by \fISuspendee\fR\& resides on another node\&. 
.TP 2
.B
\fIbadarg\fR\&:
 If \fIOptList\fR\& isn\&'t a proper list of valid \fIOpt\fR\&s\&. 
.TP 2
.B
\fIsystem_limit\fR\&:
 If the process identified by \fISuspendee\fR\& has been suspended more times by the calling process than can be represented by the currently used internal data structures\&. The current system limit is larger than 2 000 000 000 suspends, and it will never be less than that\&. 
.RE
.RE
.LP
.nf

.B
erlang:suspend_process(Suspendee) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Suspendee = pid()
.br
.RE
.RE
.RS
.LP
Suspends the process identified by \fISuspendee\fR\&\&. The same as calling \fBerlang:suspend_process(Suspendee, [])\fR\&\&. For more information see the documentation of \fBerlang:suspend_process/2\fR\&\&.
.LP

.RS -4
.B
Warning:
.RE
This BIF is intended for debugging only\&.

.RE
.LP
.nf

.B
erlang:system_flag(Flag :: backtrace_depth, Depth) -> OldDepth
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Depth = OldDepth = integer() >= 0
.br
.RE
.RE
.RS
.LP
Sets the maximum depth of call stack back-traces in the exit reason element of \fI\&'EXIT\&'\fR\& tuples\&.
.LP
Returns the old value of the flag\&.
.RE
.LP
.nf

.B
erlang:system_flag(Flag :: cpu_topology, CpuTopology) ->
.B
                      OldCpuTopology
.br
.fi
.br
.RS
.LP
Types:

.RS 3
CpuTopology = OldCpuTopology = \fBcpu_topology()\fR\&
.br
.nf
\fBcpu_topology()\fR\& = [LevelEntry :: \fBlevel_entry()\fR\&] | undefined
.fi
.br
.nf
\fBlevel_entry()\fR\& = {LevelTag :: \fBlevel_tag()\fR\&,
.br
                 SubLevel :: \fBsub_level()\fR\&}
.br
              | {LevelTag :: \fBlevel_tag()\fR\&,
.br
                 InfoList :: \fBinfo_list()\fR\&,
.br
                 SubLevel :: \fBsub_level()\fR\&}
.fi
.br
.nf
\fBlevel_tag()\fR\& = core | node | processor | thread
.fi
.br
.nf
\fBsub_level()\fR\& = [LevelEntry :: \fBlevel_entry()\fR\&]
.br
            | (LogicalCpuId :: {logical, integer() >= 0})
.fi
.br
.nf
\fBinfo_list()\fR\& = []
.fi
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Warning:
.RE
This argument is \fIdeprecated\fR\& and scheduled for removal in erts-5\&.10/OTP-R16\&. Instead of using this argument you are advised to use the \fIerl\fR\& command line argument \fB+sct\fR\&\&. When this argument has been removed a final CPU topology to use will be determined at emulator boot time\&.

.LP
Sets the user defined \fICpuTopology\fR\&\&. The user defined CPU topology will override any automatically detected CPU topology\&. By passing \fIundefined\fR\& as \fICpuTopology\fR\& the system will revert back to the CPU topology automatically detected\&. The returned value equals the value returned from \fIerlang:system_info(cpu_topology)\fR\& before the change was made\&.
.LP
Returns the old value of the flag\&.
.LP
The CPU topology is used when binding schedulers to logical processors\&. If schedulers are already bound when the CPU topology is changed, the schedulers will be sent a request to rebind according to the new CPU topology\&.
.LP
The user defined CPU topology can also be set by passing the \fB+sct\fR\& command line argument to \fIerl\fR\&\&.
.LP
For information on the \fICpuTopology\fR\& type and more, see the documentation of \fBerlang:system_info(cpu_topology)\fR\&, and the \fIerl\fR\& \fB+sct\fR\& and \fB+sbt\fR\& command line flags\&.
.RE
.LP
.nf

.B
erlang:system_flag(Flag :: dirty_cpu_schedulers_online,
.B
                   DirtyCPUSchedulersOnline) ->
.B
                      OldDirtyCPUSchedulersOnline
.br
.fi
.br
.RS
.LP
Types:

.RS 3
DirtyCPUSchedulersOnline = OldDirtyCPUSchedulersOnline = integer() >= 1
.br
.RE
.RE
.RS
.LP
Sets the amount of dirty CPU schedulers online\&. Valid range is 1 <= DirtyCPUSchedulersOnline <= N where \fIN\fR\& is the lesser of the return values of \fIerlang:system_info(dirty_cpu_schedulers)\fR\& and \fIerlang:system_info(schedulers_online)\fR\&\&.
.LP
Returns the old value of the flag\&.
.LP
Note that the number of dirty CPU schedulers online may change if the number of schedulers online changes\&. For example, if there are 12 schedulers and all are online, and 6 dirty CPU schedulers, all online as well, and \fIsystem_flag/2\fR\& is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3\&. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online\&.
.LP
\fINote that the dirty schedulers functionality is experimental\fR\&, and that you have to enable support for dirty schedulers when building OTP in order to try out the functionality\&.
.LP
For more information see \fBerlang:system_info(dirty_cpu_schedulers)\fR\& and \fBerlang:system_info(dirty_cpu_schedulers_online)\fR\&\&.
.RE
.LP
.nf

.B
erlang:system_flag(Flag :: fullsweep_after, Number) -> OldNumber
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Number = OldNumber = integer() >= 0
.br
.RE
.RE
.RS
.LP
\fINumber\fR\& is a non-negative integer which indicates how many times generational garbage collections can be done without forcing a fullsweep collection\&. The value applies to new processes; processes already running are not affected\&.
.LP
Returns the old value of the flag\&.
.LP
In low-memory systems (especially without virtual memory), setting the value to 0 can help to conserve memory\&.
.LP
An alternative way to set this value is through the (operating system) environment variable \fIERL_FULLSWEEP_AFTER\fR\&\&.
.RE
.LP
.nf

.B
erlang:system_flag(Flag :: min_heap_size, MinHeapSize) ->
.B
                      OldMinHeapSize
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MinHeapSize = OldMinHeapSize = integer() >= 0
.br
.RE
.RE
.RS
.LP
Sets the default minimum heap size for processes\&. The size is given in words\&. The new \fImin_heap_size\fR\& only effects processes spawned after the change of \fImin_heap_size\fR\& has been made\&. The \fImin_heap_size\fR\& can be set for individual processes by use of \fBspawn_opt/N\fR\& or \fBprocess_flag/2\fR\&\&.
.LP
Returns the old value of the flag\&.
.RE
.LP
.nf

.B
erlang:system_flag(Flag :: min_bin_vheap_size, MinBinVHeapSize) ->
.B
                      OldMinBinVHeapSize
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MinBinVHeapSize = OldMinBinVHeapSize = integer() >= 0
.br
.RE
.RE
.RS
.LP
Sets the default minimum binary virtual heap size for processes\&. The size is given in words\&. The new \fImin_bin_vhheap_size\fR\& only effects processes spawned after the change of \fImin_bin_vhheap_size\fR\& has been made\&. The \fImin_bin_vheap_size\fR\& can be set for individual processes by use of \fBspawn_opt/N\fR\& or \fBprocess_flag/2\fR\&\&.
.LP
Returns the old value of the flag\&.
.RE
.LP
.nf

.B
erlang:system_flag(Flag :: multi_scheduling, BlockState) ->
.B
                      OldBlockState
.br
.fi
.br
.RS
.LP
Types:

.RS 3
BlockState = block | unblock
.br
OldBlockState = block | unblock | enabled
.br
.RE
.RE
.RS
.LP
If multi-scheduling is enabled, more than one scheduler thread is used by the emulator\&. Multi-scheduling can be blocked\&. When multi-scheduling has been blocked, only one scheduler thread will schedule Erlang processes\&.
.LP
If \fIBlockState =:= block\fR\&, multi-scheduling will be blocked\&. If \fIBlockState =:= unblock\fR\& and no-one else is blocking multi-scheduling and this process has only blocked one time, multi-scheduling will be unblocked\&. One process can block multi-scheduling multiple times\&. If a process has blocked multiple times, it has to unblock exactly as many times as it has blocked before it has released its multi-scheduling block\&. If a process that has blocked multi-scheduling exits, it will release its blocking of multi-scheduling\&.
.LP
The return values are \fIdisabled\fR\&, \fIblocked\fR\&, or \fIenabled\fR\&\&. The returned value describes the state just after the call to \fIerlang:system_flag(multi_scheduling, BlockState)\fR\& has been made\&. The return values are described in the documentation of \fBerlang:system_info(multi_scheduling)\fR\&\&.
.LP
\fINOTE\fR\&: Blocking of multi-scheduling should normally not be needed\&. If you feel that you need to block multi-scheduling, think through the problem at least a couple of times again\&. Blocking multi-scheduling should only be used as a last resort since it will most likely be a \fIvery inefficient\fR\& way to solve the problem\&.
.LP
See also \fBerlang:system_info(multi_scheduling)\fR\&, \fBerlang:system_info(multi_scheduling_blockers)\fR\&, and \fBerlang:system_info(schedulers)\fR\&\&.
.RE
.LP
.nf

.B
erlang:system_flag(Flag :: scheduler_bind_type, How) ->
.B
                      OldBindType
.br
.fi
.br
.RS
.LP
Types:

.RS 3
How = \fBscheduler_bind_type()\fR\& | default_bind
.br
OldBindType = \fBscheduler_bind_type()\fR\&
.br
.nf
\fBscheduler_bind_type()\fR\& = no_node_processor_spread
.br
                      | no_node_thread_spread
.br
                      | no_spread
.br
                      | processor_spread
.br
                      | spread
.br
                      | thread_spread
.br
                      | thread_no_node_processor_spread
.br
                      | unbound
.fi
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Warning:
.RE
This argument is \fIdeprecated\fR\& and scheduled for removal in erts-5\&.10/OTP-R16\&. Instead of using this argument you are advised to use the \fIerl\fR\& command line argument \fB+sbt\fR\&\&. When this argument has been removed a final scheduler bind type to use will be determined at emulator boot time\&.

.LP
Controls if and how schedulers are bound to logical processors\&.
.LP
When \fIerlang:system_flag(scheduler_bind_type, How)\fR\& is called, an asynchronous signal is sent to all schedulers online which causes them to try to bind or unbind as requested\&. \fINOTE:\fR\& If a scheduler fails to bind, this will often be silently ignored\&. This since it isn\&'t always possible to verify valid logical processor identifiers\&. If an error is reported, it will be reported to the \fIerror_logger\fR\&\&. If you want to verify that the schedulers actually have bound as requested, call \fBerlang:system_info(scheduler_bindings)\fR\&\&.
.LP
Schedulers can currently only be bound on newer Linux, Solaris, FreeBSD, and Windows systems, but more systems will be supported in the future\&.
.LP
In order for the runtime system to be able to bind schedulers, the CPU topology needs to be known\&. If the runtime system fails to automatically detect the CPU topology, it can be defined\&. For more information on how to define the CPU topology, see the \fIerl\fR\& \fB+sct\fR\& command line flag\&.
.LP
The runtime system will by default \fInot\fR\& bind schedulers to logical processors\&.
.LP
\fINOTE:\fR\& If the Erlang runtime system is the only operating system process that binds threads to logical processors, this improves the performance of the runtime system\&. However, if other operating system processes (as for example another Erlang runtime system) also bind threads to logical processors, there might be a performance penalty instead\&. In some cases this performance penalty might be severe\&. If this is the case, you are advised to not bind the schedulers\&.
.LP
Schedulers can be bound in different ways\&. The \fIHow\fR\& argument determines how schedulers are bound\&. \fIHow\fR\& can currently be one of:
.RS 2
.TP 2
.B
\fIunbound\fR\&:
Same as the \fIerl\fR\& command line argument \fB+sbt u\fR\&\&.
.TP 2
.B
\fIno_spread\fR\&:
Same as the \fIerl\fR\& command line argument \fB+sbt ns\fR\&\&.
.TP 2
.B
\fIthread_spread\fR\&:
Same as the \fIerl\fR\& command line argument \fB+sbt ts\fR\&\&.
.TP 2
.B
\fIprocessor_spread\fR\&:
Same as the \fIerl\fR\& command line argument \fB+sbt ps\fR\&\&.
.TP 2
.B
\fIspread\fR\&:
Same as the \fIerl\fR\& command line argument \fB+sbt s\fR\&\&.
.TP 2
.B
\fIno_node_thread_spread\fR\&:
Same as the \fIerl\fR\& command line argument \fB+sbt nnts\fR\&\&.
.TP 2
.B
\fIno_node_processor_spread\fR\&:
Same as the \fIerl\fR\& command line argument \fB+sbt nnps\fR\&\&.
.TP 2
.B
\fIthread_no_node_processor_spread\fR\&:
Same as the \fIerl\fR\& command line argument \fB+sbt tnnps\fR\&\&.
.TP 2
.B
\fIdefault_bind\fR\&:
Same as the \fIerl\fR\& command line argument \fB+sbt db\fR\&\&.
.RE
.LP
The value returned equals \fIHow\fR\& before the \fIscheduler_bind_type\fR\& flag was changed\&.
.LP
Failure:
.RS 2
.TP 2
.B
\fInotsup\fR\&:
If binding of schedulers is not supported\&.
.TP 2
.B
\fIbadarg\fR\&:
If \fIHow\fR\& isn\&'t one of the documented alternatives\&.
.TP 2
.B
\fIbadarg\fR\&:
If no CPU topology information is available\&.
.RE
.LP
The scheduler bind type can also be set by passing the \fB+sbt\fR\& command line argument to \fIerl\fR\&\&.
.LP
For more information, see \fBerlang:system_info(scheduler_bind_type)\fR\&, \fBerlang:system_info(scheduler_bindings)\fR\&, the \fIerl\fR\& \fB+sbt\fR\& and \fB+sct\fR\& command line flags\&.
.RE
.LP
.nf

.B
erlang:system_flag(Flag :: scheduler_wall_time, Boolean) ->
.B
                      OldBoolean
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Boolean = OldBoolean = boolean()
.br
.RE
.RE
.RS
.LP
Turns on/off scheduler wall time measurements\&.
.LP
For more information see, \fBerlang:statistics(scheduler_wall_time)\fR\&\&.
.RE
.LP
.nf

.B
erlang:system_flag(Flag :: schedulers_online, SchedulersOnline) ->
.B
                      OldSchedulersOnline
.br
.fi
.br
.RS
.LP
Types:

.RS 3
SchedulersOnline = OldSchedulersOnline = integer() >= 1
.br
.RE
.RE
.RS
.LP
Sets the amount of schedulers online\&. Valid range is 1 <= SchedulersOnline <= erlang:system_info(schedulers)\&.
.LP
Returns the old value of the flag\&.
.LP
Note that if the emulator was built with support for \fBdirty schedulers\fR\&, changing the number of schedulers online can also change the number of dirty CPU schedulers online\&. For example, if there are 12 schedulers and all are online, and 6 dirty CPU schedulers, all online as well, and \fIsystem_flag/2\fR\& is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3\&. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online\&.
.LP
For more information see, \fBerlang:system_info(schedulers)\fR\&, and \fBerlang:system_info(schedulers_online)\fR\&\&.
.RE
.LP
.nf

.B
erlang:system_flag(Flag :: trace_control_word, TCW) -> OldTCW
.br
.fi
.br
.RS
.LP
Types:

.RS 3
TCW = OldTCW = integer() >= 0
.br
.RE
.RE
.RS
.LP
Sets the value of the node\&'s trace control word to \fITCW\fR\&\&. \fITCW\fR\& should be an unsigned integer\&. For more information see documentation of the \fBset_tcw\fR\& function in the match specification documentation in the ERTS User\&'s Guide\&.
.LP
Returns the old value of the flag\&.
.RE
.LP
.nf

.B
erlang:system_info(Item :: allocated_areas) -> [tuple()]
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: allocator) ->
.B
                      {Allocator, Version, Features, Settings}
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: alloc_util_allocators) -> [Alloc]
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: {allocator, Alloc}) -> [term()]
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: {allocator_sizes, Alloc}) -> [term()]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Allocator = undefined | glibc
.br
Version = [integer() >= 0]
.br
Features = [atom()]
.br
Settings = 
.br
    [{Subsystem :: atom(),
.br
      [{Parameter :: atom(), Value :: term()}]}]
.br
Alloc = atom()
.br
.RE
.RE
.RS
.LP
Returns various information about the \fBallocators\fR\& of the current system (emulator) as specified by \fIItem\fR\&:
.RS 2
.TP 2
.B
\fB\fIallocated_areas\fR\&\fR\&:
Returns a list of tuples with information about miscellaneous allocated memory areas\&.
.RS 2
.LP
Each tuple contains an atom describing type of memory as first element and amount of allocated memory in bytes as second element\&. In those cases when there is information present about allocated and used memory, a third element is present\&. This third element contains the amount of used memory in bytes\&.
.RE
.RS 2
.LP
\fIerlang:system_info(allocated_areas)\fR\& is intended for debugging, and the content is highly implementation dependent\&. The content of the results will therefore change when needed without prior notice\&.
.RE
.RS 2
.LP
\fINote:\fR\& The sum of these values is \fInot\fR\& the total amount of memory allocated by the emulator\&. Some values are part of other values, and some memory areas are not part of the result\&. If you are interested in the total amount of memory allocated by the emulator see \fBerlang:memory/0,1\fR\&\&.
.RE
.TP 2
.B
\fB\fIallocator\fR\&\fR\&:
Returns \fI{Allocator, Version, Features, Settings}\&.\fR\&
.RS 2
.LP
Explanation:
.RE
.RS 2
.TP 2
*
\fIAllocator\fR\& corresponds to the \fImalloc()\fR\& implementation used\&. If \fIAllocator\fR\& equals \fIundefined\fR\&, the \fImalloc()\fR\& implementation used could not be identified\&. Currently \fIglibc\fR\& can be identified\&.
.LP
.TP 2
*
\fIVersion\fR\& is a list of integers (but not a string) representing the version of the \fImalloc()\fR\& implementation used\&.
.LP
.TP 2
*
\fIFeatures\fR\& is a list of atoms representing allocation features used\&.
.LP
.TP 2
*
\fISettings\fR\& is a list of subsystems, their configurable parameters, and used values\&. Settings may differ between different combinations of platforms, allocators, and allocation features\&. Memory sizes are given in bytes\&.
.LP
.RE

.RS 2
.LP
See also "System Flags Effecting erts_alloc" in \fBerts_alloc(3)\fR\&\&.
.RE
.TP 2
.B
\fB\fIalloc_util_allocators\fR\&\fR\&:
Returns a list of the names of all allocators using the ERTS internal \fIalloc_util\fR\& framework as atoms\&. For more information see the \fB"the alloc_util framework" section in the erts_alloc(3)\fR\& documentation\&.
.TP 2
.B
\fB\fI{allocator, Alloc}\fR\&\fR\&:
Returns information about the specified allocator\&. As of erts version 5\&.6\&.1 the return value is a list of \fI{instance, InstanceNo, InstanceInfo}\fR\& tuples where \fIInstanceInfo\fR\& contains information about a specific instance of the allocator\&. As of erts version 5\&.10\&.4 the returned list when calling \fIerlang:system_info({allocator, mseg_alloc})\fR\& also include an \fI{erts_mmap, _}\fR\& tuple as one element in the list\&. If \fIAlloc\fR\& is not a recognized allocator, \fIundefined\fR\& is returned\&. If \fIAlloc\fR\& is disabled, \fIfalse\fR\& is returned\&.
.RS 2
.LP
\fINote:\fR\& The information returned is highly implementation dependent and may be changed, or removed at any time without prior notice\&. It was initially intended as a tool when developing new allocators, but since it might be of interest for others it has been briefly documented\&.
.RE
.RS 2
.LP
The recognized allocators are listed in \fBerts_alloc(3)\fR\&\&. After reading the \fIerts_alloc(3)\fR\& documentation, the returned information should more or less speak for itself\&. But it can be worth explaining some things\&. Call counts are presented by two values\&. The first value is giga calls, and the second value is calls\&. \fImbcs\fR\&, and \fIsbcs\fR\& are abbreviations for, respectively, multi-block carriers, and single-block carriers\&. Sizes are presented in bytes\&. When it is not a size that is presented, it is the amount of something\&. Sizes and amounts are often presented by three values, the first is current value, the second is maximum value since the last call to \fIerlang:system_info({allocator, Alloc})\fR\&, and the third is maximum value since the emulator was started\&. If only one value is present, it is the current value\&. \fIfix_alloc\fR\& memory block types are presented by two values\&. The first value is memory pool size and the second value used memory size\&.
.RE
.TP 2
.B
\fB\fI{allocator_sizes, Alloc}\fR\&\fR\&:
Returns various size information for the specified allocator\&. The information returned is a subset of the information returned by \fBerlang:system_info({allocator, Alloc})\fR\&\&.
.RE
.RE
.LP
.nf

.B
erlang:system_info(Item :: cpu_topology) -> CpuTopology
.br
.fi
.br
.nf

.B
erlang:system_info(Item ::
.B
                       {cpu_topology, defined | detected | used}) ->
.B
                      CpuTopology
.br
.fi
.br
.RS
.LP
Types:

.RS 3
CpuTopology = \fBcpu_topology()\fR\&
.br
.nf
\fBcpu_topology()\fR\& = [LevelEntry :: \fBlevel_entry()\fR\&] | undefined
.fi
.br
.RS 2
 All \fILevelEntry\fR\&s of a list must contain the same \fILevelTag\fR\&, except on the top level where both \fInode\fR\& and \fIprocessor\fR\&\fILevelTag\fR\&s may co-exist\&. 
.RE
.nf
\fBlevel_entry()\fR\& = {LevelTag :: \fBlevel_tag()\fR\&,
.br
                 SubLevel :: \fBsub_level()\fR\&}
.br
              | {LevelTag :: \fBlevel_tag()\fR\&,
.br
                 InfoList :: \fBinfo_list()\fR\&,
.br
                 SubLevel :: \fBsub_level()\fR\&}
.fi
.br
.RS 2
\fI{LevelTag, SubLevel} == {LevelTag, [], SubLevel}\fR\&
.RE
.nf
\fBlevel_tag()\fR\& = core | node | processor | thread
.fi
.br
.RS 2
 More \fILevelTag\fR\&s may be introduced in the future\&. 
.RE
.nf
\fBsub_level()\fR\& = [LevelEntry :: \fBlevel_entry()\fR\&]
.br
            | (LogicalCpuId :: {logical, integer() >= 0})
.fi
.br
.nf
\fBinfo_list()\fR\& = []
.fi
.br
.RS 2
 The \fIinfo_list()\fR\& may be extended in the future\&. 
.RE
.RE
.RE
.RS
.LP
Returns various information about the \fBCPU topology\fR\& of the current system (emulator) as specified by \fIItem\fR\&:
.RS 2
.TP 2
.B
\fIcpu_topology\fR\&:
Returns the \fICpuTopology\fR\& which currently is used by the emulator\&. The CPU topology is used when binding schedulers to logical processors\&. The CPU topology used is the \fBuser defined CPU topology\fR\& if such exists; otherwise, the \fBautomatically detected CPU topology\fR\& if such exists\&. If no CPU topology exists, \fIundefined\fR\& is returned\&.
.RS 2
.LP
\fInode\fR\& refers to NUMA (non-uniform memory access) nodes, and \fIthread\fR\& refers to hardware threads (e\&.g\&. Intels hyper-threads)\&.
.RE
.RS 2
.LP
A level in the \fICpuTopology\fR\& term can be omitted if only one entry exists and the \fIInfoList\fR\& is empty\&.
.RE
.RS 2
.LP
\fIthread\fR\& can only be a sub level to \fIcore\fR\&\&. \fIcore\fR\& can be a sub level to either \fIprocessor\fR\& or \fInode\fR\&\&. \fIprocessor\fR\& can either be on the top level or a sub level to \fInode\fR\&\&. \fInode\fR\& can either be on the top level or a sub level to \fIprocessor\fR\&\&. That is, NUMA nodes can be processor internal or processor external\&. A CPU topology can consist of a mix of processor internal and external NUMA nodes, as long as each logical CPU belongs to one and only one NUMA node\&. Cache hierarchy is not part of the \fICpuTopology\fR\& type yet, but will be in the future\&. Other things may also make it into the CPU topology in the future\&. In other words, expect the \fICpuTopology\fR\& type to change\&.
.RE
.TP 2
.B
\fB\fI{cpu_topology, defined}\fR\&\fR\&:
Returns the user defined \fICpuTopology\fR\&\&. For more information see the documentation of the \fIerl\fR\& \fB+sct\fR\& command line flag, and the documentation of the \fBcpu_topology\fR\& argument\&.
.TP 2
.B
\fB\fI{cpu_topology, detected}\fR\&\fR\&:
Returns the automatically detected \fICpuTopology\fR\&\&. The emulator currently only detects the CPU topology on some newer Linux, Solaris, FreeBSD, and Windows systems\&. On Windows system with more than 32 logical processors the CPU topology is not detected\&.
.RS 2
.LP
For more information see the documentation of the \fBcpu_topology\fR\& argument\&.
.RE
.TP 2
.B
\fI{cpu_topology, used}\fR\&:
Returns the \fICpuTopology\fR\& which is used by the emulator\&. For more information see the documentation of the \fBcpu_topology\fR\& argument\&.
.RE
.RE
.LP
.nf

.B
erlang:system_info(Item :: build_type) ->
.B
                      opt |
.B
                      debug |
.B
                      purify |
.B
                      quantify |
.B
                      purecov |
.B
                      gcov |
.B
                      valgrind |
.B
                      gprof |
.B
                      lcnt |
.B
                      frmptr
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: c_compiler_used) -> {atom(), term()}
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: check_io) -> [term()]
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: compat_rel) -> integer()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: creation) -> integer()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: debug_compiled) -> boolean()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: dirty_cpu_schedulers) ->
.B
                      integer() >= 0
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: dirty_cpu_schedulers_online) ->
.B
                      integer() >= 0
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: dirty_io_schedulers) ->
.B
                      integer() >= 0
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: dist) -> binary()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: dist_buf_busy_limit) ->
.B
                      integer() >= 0
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: dist_ctrl) ->
.B
                      {Node :: node(),
.B
                       ControllingEntity :: port() | pid()}
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: driver_version) -> string()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: dynamic_trace) ->
.B
                      none | dtrace | systemtap
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: dynamic_trace_probes) -> boolean()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: elib_malloc) -> false
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: ets_limit) -> integer() >= 1
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: fullsweep_after) ->
.B
                      {fullsweep_after, integer() >= 0}
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: garbage_collection) ->
.B
                      [{atom(), integer()}]
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: heap_sizes) -> [integer() >= 0]
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: heap_type) -> private
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: info) -> binary()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: kernel_poll) -> boolean()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: loaded) -> binary()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: logical_processors
.B
                         | logical_processors_available
.B
                         | logical_processors_online) ->
.B
                      unknown | integer() >= 1
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: machine) -> string()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: min_heap_size) ->
.B
                      {min_heap_size,
.B
                       MinHeapSize :: integer() >= 1}
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: min_bin_vheap_size) ->
.B
                      {min_bin_vheap_size,
.B
                       MinBinVHeapSize :: integer() >= 1}
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: modified_timing_level) ->
.B
                      integer() | undefined
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: multi_scheduling) ->
.B
                      disabled | blocked | enabled
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: multi_scheduling_blockers) ->
.B
                      [PID :: pid()]
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: otp_correction_package) -> string()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: otp_release) -> string()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: port_count) -> integer() >= 0
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: port_limit) -> integer() >= 1
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: process_count) -> integer() >= 1
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: process_limit) -> integer() >= 1
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: procs) -> binary()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: scheduler_bind_type) ->
.B
                      spread |
.B
                      processor_spread |
.B
                      thread_spread |
.B
                      thread_no_node_processor_spread |
.B
                      no_node_processor_spread |
.B
                      no_node_thread_spread |
.B
                      no_spread |
.B
                      unbound
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: scheduler_bindings) -> tuple()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: scheduler_id) ->
.B
                      SchedulerId :: integer() >= 1
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: schedulers | schedulers_online) ->
.B
                      integer() >= 1
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: smp_support) -> boolean()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: system_version) -> string()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: system_architecture) -> string()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: threads) -> boolean()
.br
.fi
.br
.nf

.B
erlang:system_info(Item :: thread_pool_size) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Returns various information about the current system (emulator) as specified by \fIItem\fR\&:
.RS 2
.TP 2
.B
\fIallocated_areas\fR\&, \fIallocator\fR\&, \fIalloc_util_allocators\fR\&, \fIallocator_sizes\fR\&:
See \fBabove\fR\&\&.
.TP 2
.B
\fIbuild_type\fR\&:
Returns an atom describing the build type of the runtime system\&. This is normally the atom \fIopt\fR\& for optimized\&. Other possible return values are \fIdebug\fR\&, \fIpurify\fR\&, \fIquantify\fR\&, \fIpurecov\fR\&, \fIgcov\fR\&, \fIvalgrind\fR\&, \fIgprof\fR\&, and \fIlcnt\fR\&\&. Possible return values may be added and/or removed at any time without prior notice\&.
.TP 2
.B
\fIc_compiler_used\fR\&:
Returns a two-tuple describing the C compiler used when compiling the runtime system\&. The first element is an atom describing the name of the compiler, or \fIundefined\fR\& if unknown\&. The second element is a term describing the version of the compiler, or \fIundefined\fR\& if unknown\&.
.TP 2
.B
\fIcheck_io\fR\&:
Returns a list containing miscellaneous information regarding the emulators internal I/O checking\&. Note, the content of the returned list may vary between platforms and over time\&. The only thing guaranteed is that a list is returned\&.
.TP 2
.B
\fIcompat_rel\fR\&:
Returns the compatibility mode of the local node as an integer\&. The integer returned represents the Erlang/OTP release which the current emulator has been set to be backward compatible with\&. The compatibility mode can be configured at startup by using the command line flag \fI+R\fR\&, see \fBerl(1)\fR\&\&.
.TP 2
.B
\fIcpu_topology\fR\&:
See \fBabove\fR\&\&.
.TP 2
.B
\fIcreation\fR\&:
Returns the creation of the local node as an integer\&. The creation is changed when a node is restarted\&. The creation of a node is stored in process identifiers, port identifiers, and references\&. This makes it (to some extent) possible to distinguish between identifiers from different incarnations of a node\&. Currently valid creations are integers in the range 1\&.\&.3, but this may (probably will) change in the future\&. If the node is not alive, 0 is returned\&.
.TP 2
.B
\fIdebug_compiled\fR\&:
Returns \fItrue\fR\& if the emulator has been debug compiled; otherwise, \fIfalse\fR\&\&.
.TP 2
.B
\fB\fIdirty_cpu_schedulers\fR\&\fR\&:
Returns the number of dirty CPU scheduler threads used by the emulator\&. Dirty CPU schedulers execute CPU-bound native functions such as NIFs, linked-in driver code, and BIFs that cannot be managed cleanly by the emulator\&'s normal schedulers\&.
.RS 2
.LP
The number of dirty CPU scheduler threads is determined at emulator boot time and cannot be changed after that\&. The number of dirty CPU scheduler threads online can however be changed at any time\&. The number of dirty CPU schedulers can be set on startup by passing the \fB+SDcpu\fR\& or \fB+SDPcpu\fR\& command line flags, see \fBerl(1)\fR\&\&.
.RE
.RS 2
.LP
\fINote that the dirty schedulers functionality is experimental\fR\&, and that you have to enable support for dirty schedulers when building OTP in order to try out the functionality\&.
.RE
.RS 2
.LP
See also \fBerlang:system_flag(dirty_cpu_schedulers_online, DirtyCPUSchedulersOnline)\fR\&, \fBerlang:system_info(dirty_cpu_schedulers_online)\fR\&, \fBerlang:system_info(dirty_io_schedulers)\fR\&, \fBerlang:system_info(schedulers)\fR\&, \fBerlang:system_info(schedulers_online)\fR\&, and \fBerlang:system_flag(schedulers_online, SchedulersOnline)\fR\&\&.
.RE
.TP 2
.B
\fB\fIdirty_cpu_schedulers_online\fR\&\fR\&:
Returns the number of dirty CPU schedulers online\&. The return value satisfies the following relationship: \fI1 <= DirtyCPUSchedulersOnline <= N\fR\&, where \fIN\fR\& is the lesser of the return values of \fIerlang:system_info(dirty_cpu_schedulers)\fR\& and \fIerlang:system_info(schedulers_online)\fR\&\&.
.RS 2
.LP
The number of dirty CPU schedulers online can be set on startup by passing the \fB+SDcpu\fR\& command line flag, see \fBerl(1)\fR\&\&.
.RE
.RS 2
.LP
\fINote that the dirty schedulers functionality is experimental\fR\&, and that you have to enable support for dirty schedulers when building OTP in order to try out the functionality\&.
.RE
.RS 2
.LP
For more information, see \fBerlang:system_info(dirty_cpu_schedulers)\fR\&, \fBerlang:system_info(dirty_io_schedulers)\fR\&, \fBerlang:system_info(schedulers_online)\fR\&, and \fBerlang:system_flag(dirty_cpu_schedulers_online, DirtyCPUSchedulersOnline)\fR\&\&.
.RE
.TP 2
.B
\fB\fIdirty_io_schedulers\fR\&\fR\&:
Returns the number of dirty I/O schedulers as an integer\&. Dirty I/O schedulers execute I/O-bound native functions such as NIFs and linked-in driver code that cannot be managed cleanly by the emulator\&'s normal schedulers\&.
.RS 2
.LP
This value can be set on startup by passing the \fB+SDio\fR\& command line flag, see \fBerl(1)\fR\&\&.
.RE
.RS 2
.LP
\fINote that the dirty schedulers functionality is experimental\fR\&, and that you have to enable support for dirty schedulers when building OTP in order to try out the functionality\&.
.RE
.RS 2
.LP
For more information, see \fBerlang:system_info(dirty_cpu_schedulers)\fR\&, \fBerlang:system_info(dirty_cpu_schedulers_online)\fR\&, and \fBerlang:system_flag(dirty_cpu_schedulers_online, DirtyCPUSchedulersOnline)\fR\&\&.
.RE
.TP 2
.B
\fIdist\fR\&:
Returns a binary containing a string of distribution information formatted as in Erlang crash dumps\&. For more information see the \fB"How to interpret the Erlang crash dumps"\fR\& chapter in the ERTS User\&'s Guide\&.
.TP 2
.B
\fB\fIdist_buf_busy_limit\fR\&\fR\&:
Returns the value of the distribution buffer busy limit in bytes\&. This limit can be set on startup by passing the \fB+zdbbl\fR\& command line flag to \fIerl\fR\&\&.
.TP 2
.B
\fIdist_ctrl\fR\&:
Returns a list of tuples \fI{Node, ControllingEntity}\fR\&, one entry for each connected remote node\&. The \fINode\fR\& is the name of the node and the \fIControllingEntity\fR\& is the port or pid responsible for the communication to that node\&. More specifically, the \fIControllingEntity\fR\& for nodes connected via TCP/IP (the normal case) is the socket actually used in communication with the specific node\&.
.TP 2
.B
\fIdriver_version\fR\&:
Returns a string containing the erlang driver version used by the runtime system\&. It will be on the form \fB"<major ver>\&.<minor ver>"\fR\&\&.
.TP 2
.B
\fIdynamic_trace\fR\&:
Returns an atom describing the dynamic trace framework compiled into the virtual machine\&. It can currently be either \fIdtrace\fR\&, \fIsystemtap\fR\& or \fInone\fR\&\&. For a commercial or standard build, this is always \fInone\fR\&, the other return values indicate a custom configuration (e\&.g\&. \fI\&./configure --with-dynamic-trace=dtrace\fR\&)\&. See the \fBdyntrace \fR\& manual page and the \fIREADME\&.dtrace\fR\&/\fIREADME\&.systemtap\fR\& files in the Erlang source code top directory for more information about dynamic tracing\&.
.TP 2
.B
\fIdynamic_trace_probes\fR\&:
Returns a \fIboolean()\fR\& indicating if dynamic trace probes (either dtrace or systemtap) are built into the emulator\&. This can only be \fItrue\fR\& if the virtual machine was built for dynamic tracing (i\&.e\&. \fIsystem_info(dynamic_trace)\fR\& returns \fIdtrace\fR\& or \fIsystemtap\fR\&)\&.
.TP 2
.B
\fIelib_malloc\fR\&:
This option will be removed in a future release\&. The return value will always be \fIfalse\fR\& since the elib_malloc allocator has been removed\&.
.TP 2
.B
\fIets_limit\fR\&:
Returns the maximum number of ETS tables allowed\&. This limit can be increased on startup by passing the \fB+e\fR\& command line flag to \fIerl\fR\& or by setting the environment variable \fIERL_MAX_ETS_TABLES\fR\& before starting the Erlang runtime system\&.
.TP 2
.B
\fIfullsweep_after\fR\&:
Returns \fI{fullsweep_after, integer() >= 0}\fR\& which is the \fIfullsweep_after\fR\& garbage collection setting used by default\&. For more information see \fIgarbage_collection\fR\& described below\&.
.TP 2
.B
\fIgarbage_collection\fR\&:
Returns a list describing the default garbage collection settings\&. A process spawned on the local node by a \fIspawn\fR\& or \fIspawn_link\fR\& will use these garbage collection settings\&. The default settings can be changed by use of \fBsystem_flag/2\fR\&\&. \fBspawn_opt/4\fR\& can spawn a process that does not use the default settings\&.
.TP 2
.B
\fIheap_sizes\fR\&:
Returns a list of integers representing valid heap sizes in words\&. All Erlang heaps are sized from sizes in this list\&.
.TP 2
.B
\fIheap_type\fR\&:
Returns the heap type used by the current emulator\&. Currently only the following heap type exists:
.RS 2
.TP 2
.B
\fIprivate\fR\&:
Each process has a heap reserved for its use and no references between heaps of different processes are allowed\&. Messages passed between processes are copied between heaps\&.
.RE
.TP 2
.B
\fIinfo\fR\&:
Returns a binary containing a string of miscellaneous system information formatted as in Erlang crash dumps\&. For more information see the \fB"How to interpret the Erlang crash dumps"\fR\& chapter in the ERTS User\&'s Guide\&.
.TP 2
.B
\fIkernel_poll\fR\&:
Returns \fItrue\fR\& if the emulator uses some kind of kernel-poll implementation; otherwise, \fIfalse\fR\&\&.
.TP 2
.B
\fIloaded\fR\&:
Returns a binary containing a string of loaded module information formatted as in Erlang crash dumps\&. For more information see the \fB"How to interpret the Erlang crash dumps"\fR\& chapter in the ERTS User\&'s Guide\&.
.TP 2
.B
\fB\fIlogical_processors\fR\&\fR\&:
Returns the detected number of logical processors configured on the system\&. The return value is either an integer, or the atom \fIunknown\fR\& if the emulator wasn\&'t able to detect logical processors configured\&.
.TP 2
.B
\fB\fIlogical_processors_available\fR\&\fR\&:
Returns the detected number of logical processors available to the Erlang runtime system\&. The return value is either an integer, or the atom \fIunknown\fR\& if the emulator wasn\&'t able to detect logical processors available\&. The number of logical processors available is less than or equal to the number of \fBlogical processors online\fR\&\&.
.TP 2
.B
\fB\fIlogical_processors_online\fR\&\fR\&:
Returns the detected number of logical processors online on the system\&. The return value is either an integer, or the atom \fIunknown\fR\& if the emulator wasn\&'t able to detect logical processors online\&. The number of logical processors online is less than or equal to the number of \fBlogical processors configured\fR\&\&.
.TP 2
.B
\fImachine\fR\&:
Returns a string containing the Erlang machine name\&.
.TP 2
.B
\fImin_heap_size\fR\&:
Returns \fI{min_heap_size, MinHeapSize}\fR\& where \fIMinHeapSize\fR\& is the current system wide minimum heap size for spawned processes\&.
.TP 2
.B
\fImin_bin_vheap_size\fR\&:
Returns \fI{min_bin_vheap_size, MinBinVHeapSize}\fR\& where \fIMinBinVHeapSize\fR\& is the current system wide minimum binary virtual heap size for spawned processes\&.
.TP 2
.B
\fImodified_timing_level\fR\&:
Returns the modified timing level (an integer) if modified timing has been enabled; otherwise, \fIundefined\fR\&\&. See the \fI+T\fR\& command line flag in the documentation of the \fBerl(1)\fR\& command for more information on modified timing\&.
.TP 2
.B
\fB\fImulti_scheduling\fR\&\fR\&:
Returns \fIdisabled\fR\&, \fIblocked\fR\&, or \fIenabled\fR\&\&. A description of the return values:
.RS 2
.TP 2
.B
\fIdisabled\fR\&:
The emulator has only one scheduler thread\&. The emulator does not have SMP support, or have been started with only one scheduler thread\&.
.TP 2
.B
\fIblocked\fR\&:
The emulator has more than one scheduler thread, but all scheduler threads but one have been blocked, i\&.e\&., only one scheduler thread will schedule Erlang processes and execute Erlang code\&.
.TP 2
.B
\fIenabled\fR\&:
The emulator has more than one scheduler thread, and no scheduler threads have been blocked, i\&.e\&., all available scheduler threads will schedule Erlang processes and execute Erlang code\&.
.RE
.RS 2
.LP
See also \fBerlang:system_flag(multi_scheduling, BlockState)\fR\&, \fBerlang:system_info(multi_scheduling_blockers)\fR\&, and \fBerlang:system_info(schedulers)\fR\&\&.
.RE
.TP 2
.B
\fB\fImulti_scheduling_blockers\fR\&\fR\&:
Returns a list of \fIPID\fR\&s when multi-scheduling is blocked; otherwise, the empty list\&. The \fIPID\fR\&s in the list is \fIPID\fR\&s of the processes currently blocking multi-scheduling\&. A \fIPID\fR\& will only be present once in the list, even if the corresponding process has blocked multiple times\&.
.RS 2
.LP
See also \fBerlang:system_flag(multi_scheduling, BlockState)\fR\&, \fBerlang:system_info(multi_scheduling)\fR\&, and \fBerlang:system_info(schedulers)\fR\&\&.
.RE
.TP 2
.B
\fB\fIotp_release\fR\&\fR\&:
Returns a string containing the OTP release number of the OTP release that the currently executing ERTS application is part of\&.
.RS 2
.LP
As of OTP release 17, the OTP release number corresponds to the major OTP version number\&. There is no \fIerlang:system_info()\fR\& argument giving the exact OTP version\&. This since the exact OTP version in the general case is hard to determine\&. For more information see \fBthe documentation of versions in the system principles guide\fR\&\&.
.RE
.TP 2
.B
\fB\fIport_parallelism\fR\&\fR\&:
Returns the default port parallelism scheduling hint used\&. For more information see the \fB+spp\fR\& command line argument of \fBerl(1)\fR\&\&.
.TP 2
.B
\fIport_count\fR\&:
Returns the number of ports currently existing at the local node as an integer\&. The same value as \fIlength(erlang:ports())\fR\& returns, but more efficient\&.
.TP 2
.B
\fB\fIport_limit\fR\&\fR\&:
Returns the maximum number of simultaneously existing ports at the local node as an integer\&. This limit can be configured at startup by using the \fB+Q\fR\& command line flag of \fBerl(1)\fR\&\&.
.TP 2
.B
\fIprocess_count\fR\&:
Returns the number of processes currently existing at the local node as an integer\&. The same value as \fIlength(processes())\fR\& returns, but more efficient\&.
.TP 2
.B
\fB\fIprocess_limit\fR\&\fR\&:
Returns the maximum number of simultaneously existing processes at the local node as an integer\&. This limit can be configured at startup by using the \fB+P\fR\& command line flag of \fBerl(1)\fR\&\&.
.TP 2
.B
\fIprocs\fR\&:
Returns a binary containing a string of process and port information formatted as in Erlang crash dumps\&. For more information see the \fB"How to interpret the Erlang crash dumps"\fR\& chapter in the ERTS User\&'s Guide\&.
.TP 2
.B
\fB\fIscheduler_bind_type\fR\&\fR\&:
Returns information on how user has requested schedulers to be bound or not bound\&.
.RS 2
.LP
\fINOTE:\fR\& Even though user has requested schedulers to be bound, they might have silently failed to bind\&. In order to inspect actual scheduler bindings call \fBerlang:system_info(scheduler_bindings)\fR\&\&.
.RE
.RS 2
.LP
For more information, see the \fIerl\fR\& \fB+sbt\fR\& command line argument, and \fBerlang:system_info(scheduler_bindings)\fR\&\&.
.RE
.TP 2
.B
\fB\fIscheduler_bindings\fR\&\fR\&:
Returns information on currently used scheduler bindings\&.
.RS 2
.LP
A tuple of a size equal to \fBerlang:system_info(schedulers)\fR\& is returned\&. The elements of the tuple are integers or the atom \fIunbound\fR\&\&. Logical processor identifiers are represented as integers\&. The \fIN\fR\&th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to \fIN\fR\&\&. E\&.g\&., if the schedulers have been bound, \fIelement(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))\fR\& will return the identifier of the logical processor that the calling process is executing on\&.
.RE
.RS 2
.LP
Note that only schedulers online can be bound to logical processors\&.
.RE
.RS 2
.LP
For more information, see the \fIerl\fR\& \fB+sbt\fR\& command line argument, \fBerlang:system_info(schedulers_online)\fR\&\&.
.RE
.TP 2
.B
\fB\fIscheduler_id\fR\&\fR\&:
Returns the scheduler id (\fISchedulerId\fR\&) of the scheduler thread that the calling process is executing on\&. \fISchedulerId\fR\& is a positive integer; where \fI1 <= SchedulerId <= erlang:system_info(schedulers)\fR\&\&. See also \fBerlang:system_info(schedulers)\fR\&\&.
.TP 2
.B
\fB\fIschedulers\fR\&\fR\&:
Returns the number of scheduler threads used by the emulator\&. Scheduler threads online schedules Erlang processes and Erlang ports, and execute Erlang code and Erlang linked in driver code\&.
.RS 2
.LP
The number of scheduler threads is determined at emulator boot time and cannot be changed after that\&. The amount of schedulers online can however be changed at any time\&.
.RE
.RS 2
.LP
See also \fBerlang:system_flag(schedulers_online, SchedulersOnline)\fR\&, \fBerlang:system_info(schedulers_online)\fR\&, \fBerlang:system_info(scheduler_id)\fR\&, \fBerlang:system_flag(multi_scheduling, BlockState)\fR\&, \fBerlang:system_info(multi_scheduling)\fR\&, and and \fBerlang:system_info(multi_scheduling_blockers)\fR\&\&.
.RE
.TP 2
.B
\fB\fIschedulers_online\fR\&\fR\&:
Returns the amount of schedulers online\&. The scheduler identifiers of schedulers online satisfy the following relationship: \fI1 <= SchedulerId <= erlang:system_info(schedulers_online)\fR\&\&.
.RS 2
.LP
For more information, see \fBerlang:system_info(schedulers)\fR\&, and \fBerlang:system_flag(schedulers_online, SchedulersOnline)\fR\&\&.
.RE
.nf

.B
erlang:system_info(Item :: schedulers | schedulers_online) ->
.B
                      integer() >= 1
.br
.fi
.br
.TP 2
.B
\fIsmp_support\fR\&:
Returns \fItrue\fR\& if the emulator has been compiled with smp support; otherwise, \fIfalse\fR\&\&.
.TP 2
.B
\fIsystem_version\fR\&:
Returns a string containing version number and some important properties such as the number of schedulers\&.
.TP 2
.B
\fIsystem_architecture\fR\&:
Returns a string containing the processor and OS architecture the emulator is built for\&.
.TP 2
.B
\fIthreads\fR\&:
Returns \fItrue\fR\& if the emulator has been compiled with thread support; otherwise, \fIfalse\fR\& is returned\&.
.TP 2
.B
\fB\fIthread_pool_size\fR\&\fR\&:
Returns the number of async threads in the async thread pool used for asynchronous driver calls (\fBdriver_async()\fR\&) as an integer\&.
.TP 2
.B
\fItrace_control_word\fR\&:
Returns the value of the node\&'s trace control word\&. For more information see documentation of the function \fIget_tcw\fR\& in "Match Specifications in Erlang", \fBERTS User\&'s Guide\fR\&\&.
.TP 2
.B
\fB\fIupdate_cpu_info\fR\&\fR\&:
The runtime system rereads the CPU information available and updates its internally stored information about the \fBdetected CPU topology\fR\& and the amount of logical processors \fBconfigured\fR\&, \fBonline\fR\&, and \fBavailable\fR\&\&. If the CPU information has changed since the last time it was read, the atom \fIchanged\fR\& is returned; otherwise, the atom \fIunchanged\fR\& is returned\&. If the CPU information has changed you probably want to \fBadjust the amount of schedulers online\fR\&\&. You typically want to have as many schedulers online as \fBlogical processors available\fR\&\&.
.TP 2
.B
\fB\fIversion\fR\&\fR\&:
Returns a string containing the version number of the emulator\&.
.TP 2
.B
\fIwordsize\fR\&:
Same as \fI{wordsize, internal}\&.\fR\&
.TP 2
.B
\fI{wordsize, internal}\fR\&:
Returns the size of Erlang term words in bytes as an integer, i\&.e\&. on a 32-bit architecture 4 is returned, and on a pure 64-bit architecture 8 is returned\&. On a halfword 64-bit emulator, 4 is returned, as the Erlang terms are stored using a virtual wordsize of half the system\&'s wordsize\&.
.TP 2
.B
\fI{wordsize, external}\fR\&:
Returns the true wordsize of the emulator, i\&.e\&. the size of a pointer, in bytes as an integer\&. On a pure 32-bit architecture 4 is returned, on both a halfword and pure 64-bit architecture, 8 is returned\&.
.RE
.LP

.RS -4
.B
Note:
.RE
The \fIscheduler\fR\& argument has changed name to \fIscheduler_id\fR\&\&. This in order to avoid mixup with the \fIschedulers\fR\& argument\&. The \fIscheduler\fR\& argument was introduced in ERTS version 5\&.5 and renamed in ERTS version 5\&.5\&.1\&.

.RE
.LP
.nf

.B
erlang:system_monitor() -> MonSettings
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MonSettings = undefined | {MonitorPid, Options}
.br
MonitorPid = pid()
.br
Options = [\fBsystem_monitor_option()\fR\&]
.br
.nf
\fBsystem_monitor_option()\fR\& = busy_port
.br
                        | busy_dist_port
.br
                        | {long_gc, integer() >= 0}
.br
                        | {long_schedule, integer() >= 0}
.br
                        | {large_heap, integer() >= 0}
.fi
.br
.RE
.RE
.RS
.LP
Returns the current system monitoring settings set by \fBerlang:system_monitor/2\fR\& as \fI{MonitorPid, Options}\fR\&, or \fIundefined\fR\& if there are no settings\&. The order of the options may be different from the one that was set\&.
.RE
.LP
.nf

.B
erlang:system_monitor(Arg) -> MonSettings
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Arg = MonSettings = undefined | {MonitorPid, Options}
.br
MonitorPid = pid()
.br
Options = [\fBsystem_monitor_option()\fR\&]
.br
.nf
\fBsystem_monitor_option()\fR\& = busy_port
.br
                        | busy_dist_port
.br
                        | {long_gc, integer() >= 0}
.br
                        | {long_schedule, integer() >= 0}
.br
                        | {large_heap, integer() >= 0}
.fi
.br
.RE
.RE
.RS
.LP
When called with the argument \fIundefined\fR\&, all system performance monitoring settings are cleared\&.
.LP
Calling the function with \fI{MonitorPid, Options}\fR\& as argument, is the same as calling \fBerlang:system_monitor(MonitorPid, Options)\fR\&\&.
.LP
Returns the previous system monitor settings just like \fBerlang:system_monitor/0\fR\&\&.
.RE
.LP
.nf

.B
erlang:system_monitor(MonitorPid, Options) -> MonSettings
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MonitorPid = pid()
.br
Options = [\fBsystem_monitor_option()\fR\&]
.br
MonSettings = undefined | {OldMonitorPid, OldOptions}
.br
OldMonitorPid = pid()
.br
OldOptions = [\fBsystem_monitor_option()\fR\&]
.br
.nf
\fBsystem_monitor_option()\fR\& = busy_port
.br
                        | busy_dist_port
.br
                        | {long_gc, integer() >= 0}
.br
                        | {long_schedule, integer() >= 0}
.br
                        | {large_heap, integer() >= 0}
.fi
.br
.RE
.RE
.RS
.LP
Sets system performance monitoring options\&. \fIMonitorPid\fR\& is a local pid that will receive system monitor messages, and the second argument is a list of monitoring options:
.RS 2
.TP 2
.B
\fI{long_gc, Time}\fR\&:
If a garbage collection in the system takes at least \fITime\fR\& wallclock milliseconds, a message \fI{monitor, GcPid, long_gc, Info}\fR\& is sent to \fIMonitorPid\fR\&\&. \fIGcPid\fR\& is the pid that was garbage collected and \fIInfo\fR\& is a list of two-element tuples describing the result of the garbage collection\&. One of the tuples is \fI{timeout, GcTime}\fR\& where \fIGcTime\fR\& is the actual time for the garbage collection in milliseconds\&. The other tuples are tagged with \fIheap_size\fR\&, \fIheap_block_size\fR\&, \fIstack_size\fR\&, \fImbuf_size\fR\&, \fIold_heap_size\fR\&, and \fIold_heap_block_size\fR\&\&. These tuples are explained in the documentation of the \fBgc_start\fR\& trace message (see \fBerlang:trace/3\fR\&)\&. New tuples may be added, and the order of the tuples in the \fIInfo\fR\& list may be changed at any time without prior notice\&.
.TP 2
.B
\fI{long_schedule, Time}\fR\&:
If a process or port in the system runs uninterrupted for at least \fITime\fR\& wall clock milliseconds, a message \fI{monitor, PidOrPort, long_schedule, Info}\fR\& is sent to \fIMonitorPid\fR\&\&. \fIPidOrPort\fR\& is the process or port that was running and \fIInfo\fR\& is a list of two-element tuples describing the event\&. In case of a \fIpid()\fR\&, the tuples \fI{timeout, Millis}\fR\&, \fI{in, Location}\fR\& and \fI{out, Location}\fR\& will be present, where \fILocation\fR\& is either an MFA (\fI{Module, Function, Arity}\fR\&) describing the function where the process was scheduled in/out, or the atom \fIundefined\fR\&\&. In case of a \fIport()\fR\&, the tuples \fI{timeout, Millis}\fR\& and \fI{port_op,Op}\fR\& will be present\&. \fIOp\fR\& will be one of \fIproc_sig\fR\&, \fItimeout\fR\&, \fIinput\fR\&, \fIoutput\fR\&, \fIevent\fR\& or \fIdist_cmd\fR\&, depending on which driver callback was executing\&. \fIproc_sig\fR\& is an internal operation and should never appear, while the others represent the corresponding driver callbacks \fItimeout\fR\&, \fIready_input\fR\&, \fIready_output\fR\&, \fIevent\fR\& and finally \fIoutputv\fR\& (when the port is used by distribution)\&. The \fIMillis\fR\& value in the \fItimeout\fR\& tuple will tell you the actual uninterrupted execution time of the process or port, which will always be \fI>=\fR\& the \fITime\fR\& value supplied when starting the trace\&. New tuples may be added to the \fIInfo\fR\& list in the future, and the order of the tuples in the list may be changed at any time without prior notice\&.
.RS 2
.LP
This can be used to detect problems with NIF\&'s or drivers that take too long to execute\&. Generally, 1 ms is considered a good maximum time for a driver callback or a NIF\&. However, a time sharing system should usually consider everything below 100 ms as "possible" and fairly "normal"\&. Schedule times above that might however indicate swapping or a NIF/driver that is misbehaving\&. Misbehaving NIF\&'s and drivers could cause bad resource utilization and bad overall performance of the system\&.
.RE
.TP 2
.B
\fI{large_heap, Size}\fR\&:
If a garbage collection in the system results in the allocated size of a heap being at least \fISize\fR\& words, a message \fI{monitor, GcPid, large_heap, Info}\fR\& is sent to \fIMonitorPid\fR\&\&. \fIGcPid\fR\& and \fIInfo\fR\& are the same as for \fIlong_gc\fR\& above, except that the tuple tagged with \fItimeout\fR\& is not present\&. \fINote\fR\&: As of erts version 5\&.6 the monitor message is sent if the sum of the sizes of all memory blocks allocated for all heap generations is equal to or larger than \fISize\fR\&\&. Previously the monitor message was sent if the memory block allocated for the youngest generation was equal to or larger than \fISize\fR\&\&.
.TP 2
.B
\fIbusy_port\fR\&:
If a process in the system gets suspended because it sends to a busy port, a message \fI{monitor, SusPid, busy_port, Port}\fR\& is sent to \fIMonitorPid\fR\&\&. \fISusPid\fR\& is the pid that got suspended when sending to \fIPort\fR\&\&.
.TP 2
.B
\fIbusy_dist_port\fR\&:
If a process in the system gets suspended because it sends to a process on a remote node whose inter-node communication was handled by a busy port, a message \fI{monitor, SusPid, busy_dist_port, Port}\fR\& is sent to \fIMonitorPid\fR\&\&. \fISusPid\fR\& is the pid that got suspended when sending through the inter-node communication port \fIPort\fR\&\&.
.RE
.LP
Returns the previous system monitor settings just like \fBerlang:system_monitor/0\fR\&\&.
.LP

.RS -4
.B
Note:
.RE
If a monitoring process gets so large that it itself starts to cause system monitor messages when garbage collecting, the messages will enlarge the process\&'s message queue and probably make the problem worse\&.
.LP
Keep the monitoring process neat and do not set the system monitor limits too tight\&.

.LP
Failure: \fIbadarg\fR\& if \fIMonitorPid\fR\& does not exist or is not a local process\&.
.RE
.LP
.nf

.B
erlang:system_profile() -> ProfilerSettings
.br
.fi
.br
.RS
.LP
Types:

.RS 3
ProfilerSettings = undefined | {ProfilerPid, Options}
.br
ProfilerPid = pid() | port()
.br
Options = [\fBsystem_profile_option()\fR\&]
.br
.nf
\fBsystem_profile_option()\fR\& = exclusive
.br
                        | runnable_ports
.br
                        | runnable_procs
.br
                        | scheduler
.fi
.br
.RE
.RE
.RS
.LP
Returns the current system profiling settings set by \fBerlang:system_profile/2\fR\& as \fI{ProfilerPid, Options}\fR\&, or \fIundefined\fR\& if there are no settings\&. The order of the options may be different from the one that was set\&.
.RE
.LP
.nf

.B
erlang:system_profile(ProfilerPid, Options) -> ProfilerSettings
.br
.fi
.br
.RS
.LP
Types:

.RS 3
ProfilerPid = pid() | port() | undefined
.br
Options = [\fBsystem_profile_option()\fR\&]
.br
ProfilerSettings = undefined
.br
                 | {pid() | port(), [\fBsystem_profile_option()\fR\&]}
.br
.nf
\fBsystem_profile_option()\fR\& = exclusive
.br
                        | runnable_ports
.br
                        | runnable_procs
.br
                        | scheduler
.fi
.br
.RE
.RE
.RS
.LP
Sets system profiler options\&. \fIProfilerPid\fR\& is a local pid or port that will receive profiling messages\&. The receiver is excluded from all profiling\&. The second argument is a list of profiling options:
.RS 2
.TP 2
.B
\fIexclusive\fR\&:
If a synchronous call to a port from a process is done, the calling process is considered not runnable during the call runtime to the port\&. The calling process is notified as \fIinactive\fR\& and subsequently \fIactive\fR\& when the port callback returns\&.
.TP 2
.B
\fIrunnable_procs\fR\&:
If a process is put into or removed from the run queue a message, \fI{profile, Pid, State, Mfa, Ts}\fR\&, is sent to \fIProfilerPid\fR\&\&. Running processes that is reinserted into the run queue after having been preemptively scheduled out will not trigger this message\&.
.TP 2
.B
\fIrunnable_ports\fR\&:
If a port is put into or removed from the run queue a message, \fI{profile, Port, State, 0, Ts}\fR\&, is sent to \fIProfilerPid\fR\&\&.
.TP 2
.B
\fIscheduler\fR\&:
If a scheduler is put to sleep or awoken a message, \fI{profile, scheduler, Id, State, NoScheds, Ts}\fR\&, is sent to \fIProfilerPid\fR\&\&.
.RE
.LP

.RS -4
.B
Note:
.RE
\fIerlang:system_profile\fR\& is considered experimental and its behaviour may change in the future\&.

.RE
.LP
.nf

.B
term_to_binary(Term) -> ext_binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
.RE
.RE
.RS
.LP
Returns a binary data object which is the result of encoding \fITerm\fR\& according to the Erlang external term format\&.
.LP
This can be used for a variety of purposes, for example writing a term to a file in an efficient way, or sending an Erlang term to some type of communications channel not supported by distributed Erlang\&.
.LP
See also \fBbinary_to_term/1\fR\&\&.
.RE
.LP
.nf

.B
term_to_binary(Term, Options) -> ext_binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Term = term()
.br
Options = 
.br
    [compressed |
.br
     {compressed, Level :: 0\&.\&.9} |
.br
     {minor_version, Version :: 0\&.\&.1}]
.br
.RE
.RE
.RS
.LP
Returns a binary data object which is the result of encoding \fITerm\fR\& according to the Erlang external term format\&.
.LP
If the option \fIcompressed\fR\& is provided, the external term format will be compressed\&. The compressed format is automatically recognized by \fIbinary_to_term/1\fR\& in R7B and later\&.
.LP
It is also possible to specify a compression level by giving the option \fI{compressed, Level}\fR\&, where \fILevel\fR\& is an integer from 0 through 9\&. \fI0\fR\& means that no compression will be done (it is the same as not giving any \fIcompressed\fR\& option); \fI1\fR\& will take the least time but may not compress as well as the higher levels; \fI9\fR\& will take the most time and may produce a smaller result\&. Note the "mays" in the preceding sentence; depending on the input term, level 9 compression may or may not produce a smaller result than level 1 compression\&.
.LP
Currently, \fIcompressed\fR\& gives the same result as \fI{compressed, 6}\fR\&\&.
.LP
The option \fI{minor_version, Version}\fR\& can be use to control some details of the encoding\&. This option was introduced in R11B-4\&. Currently, the allowed values for \fIVersion\fR\& are \fI0\fR\& and \fI1\fR\&\&.
.LP
\fI{minor_version, 1}\fR\& is since 17\&.0 the default, it forces any floats in the term to be encoded in a more space-efficient and exact way (namely in the 64-bit IEEE format, rather than converted to a textual representation)\&. \fIbinary_to_term/1\fR\& in R11B-4 and later is able decode this representation\&.
.LP
\fI{minor_version, 0}\fR\& meaning that floats will be encoded using a textual representation; this option is useful if you want to ensure that releases prior to R11B-4 can decode resulting binary\&.
.LP
See also \fBbinary_to_term/1\fR\&\&.
.RE
.LP
.nf

.B
throw(Any) -> no_return()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Any = term()
.br
.RE
.RE
.RS
.LP
A non-local return from a function\&. If evaluated within a \fIcatch\fR\&, \fIcatch\fR\& will return the value \fIAny\fR\&\&.
.LP
.nf

> catch throw({hello, there})\&.
{hello,there}
.fi
.LP
Failure: \fInocatch\fR\& if not evaluated within a catch\&.
.RE
.LP
.nf

.B
time() -> Time
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Time = \fBcalendar:time()\fR\&
.br
.RE
.RE
.RS
.LP
Returns the current time as \fI{Hour, Minute, Second}\fR\&\&.
.LP
The time zone and daylight saving time correction depend on the underlying OS\&.
.LP
.nf

> time()\&.
{9,42,44}
.fi
.RE
.LP
.nf

.B
tl(List) -> term()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
List = [term(), \&.\&.\&.]
.br
.RE
.RE
.RS
.LP
Returns the tail of \fIList\fR\&, that is, the list minus the first element\&.
.LP
.nf

> tl([geesties, guilies, beasties])\&.
[guilies, beasties]
.fi
.LP
Allowed in guard tests\&.
.LP
Failure: \fIbadarg\fR\& if \fIList\fR\& is the empty list []\&.
.RE
.LP
.nf

.B
erlang:trace(PidSpec, How, FlagList) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
PidSpec = pid() | existing | new | all
.br
How = boolean()
.br
FlagList = [\fBtrace_flag()\fR\&]
.br
.nf
\fBtrace_flag()\fR\& = all
.br
             | send
.br
             | \&'receive\&'
.br
             | procs
.br
             | call
.br
             | silent
.br
             | return_to
.br
             | running
.br
             | exiting
.br
             | garbage_collection
.br
             | timestamp
.br
             | cpu_timestamp
.br
             | arity
.br
             | set_on_spawn
.br
             | set_on_first_spawn
.br
             | set_on_link
.br
             | set_on_first_link
.br
             | {tracer, pid() | port()}
.fi
.br
.RE
.RE
.RS
.LP
Turns on (if \fIHow == true\fR\&) or off (if \fIHow == false\fR\&) the trace flags in \fIFlagList\fR\& for the process or processes represented by \fIPidSpec\fR\&\&.
.LP
\fIPidSpec\fR\& is either a pid for a local process, or one of the following atoms:
.RS 2
.TP 2
.B
\fIexisting\fR\&:
All processes currently existing\&.
.TP 2
.B
\fInew\fR\&:
All processes that will be created in the future\&.
.TP 2
.B
\fIall\fR\&:
All currently existing processes and all processes that will be created in the future\&.
.RE
.LP
\fIFlagList\fR\& can contain any number of the following flags (the "message tags" refers to the list of messages following below):
.RS 2
.TP 2
.B
\fIall\fR\&:
Set all trace flags except \fI{tracer, Tracer}\fR\& and \fIcpu_timestamp\fR\& that are in their nature different than the others\&.
.TP 2
.B
\fIsend\fR\&:
Trace sending of messages\&.
.RS 2
.LP
Message tags: \fIsend\fR\&, \fIsend_to_non_existing_process\fR\&\&.
.RE
.TP 2
.B
\fI\&'receive\&'\fR\&:
Trace receiving of messages\&.
.RS 2
.LP
Message tags: \fI\&'receive\&'\fR\&\&.
.RE
.TP 2
.B
\fIprocs\fR\&:
Trace process related events\&.
.RS 2
.LP
Message tags: \fIspawn\fR\&, \fIexit\fR\&, \fIregister\fR\&, \fIunregister\fR\&, \fIlink\fR\&, \fIunlink\fR\&, \fIgetting_linked\fR\&, \fIgetting_unlinked\fR\&\&.
.RE
.TP 2
.B
\fIcall\fR\&:
Trace certain function calls\&. Specify which function calls to trace by calling \fBerlang:trace_pattern/3\fR\&\&.
.RS 2
.LP
Message tags: \fIcall\fR\&, \fIreturn_from\fR\&\&.
.RE
.TP 2
.B
\fIsilent\fR\&:
Used in conjunction with the \fIcall\fR\& trace flag\&. The \fIcall\fR\&, \fIreturn_from\fR\& and \fIreturn_to\fR\& trace messages are inhibited if this flag is set, but if there are match specs they are executed as normal\&.
.RS 2
.LP
Silent mode is inhibited by executing \fIerlang:trace(_, false, [silent|_])\fR\&, or by a match spec executing the \fI{silent, false}\fR\& function\&.
.RE
.RS 2
.LP
The \fIsilent\fR\& trace flag facilitates setting up a trace on many or even all processes in the system\&. Then the interesting trace can be activated and deactivated using the \fI{silent,Bool}\fR\& match spec function, giving a high degree of control of which functions with which arguments that triggers the trace\&.
.RE
.RS 2
.LP
Message tags: \fIcall\fR\&, \fIreturn_from\fR\&, \fIreturn_to\fR\&\&. Or rather, the absence of\&.
.RE
.TP 2
.B
\fIreturn_to\fR\&:
Used in conjunction with the \fIcall\fR\& trace flag\&. Trace the actual return from a traced function back to its caller\&. Only works for functions traced with the \fIlocal\fR\& option to \fBerlang:trace_pattern/3\fR\&\&.
.RS 2
.LP
The semantics is that a trace message is sent when a call traced function actually returns, that is, when a chain of tail recursive calls is ended\&. There will be only one trace message sent per chain of tail recursive calls, why the properties of tail recursiveness for function calls are kept while tracing with this flag\&. Using \fIcall\fR\& and \fIreturn_to\fR\& trace together makes it possible to know exactly in which function a process executes at any time\&.
.RE
.RS 2
.LP
To get trace messages containing return values from functions, use the \fI{return_trace}\fR\& match_spec action instead\&.
.RE
.RS 2
.LP
Message tags: \fIreturn_to\fR\&\&.
.RE
.TP 2
.B
\fIrunning\fR\&:
Trace scheduling of processes\&.
.RS 2
.LP
Message tags: \fIin\fR\&, and \fIout\fR\&\&.
.RE
.TP 2
.B
\fIexiting\fR\&:
Trace scheduling of an exiting processes\&.
.RS 2
.LP
Message tags: \fIin_exiting\fR\&, \fIout_exiting\fR\&, and \fIout_exited\fR\&\&.
.RE
.TP 2
.B
\fIgarbage_collection\fR\&:
Trace garbage collections of processes\&.
.RS 2
.LP
Message tags: \fIgc_start\fR\&, \fIgc_end\fR\&\&.
.RE
.TP 2
.B
\fItimestamp\fR\&:
Include a time stamp in all trace messages\&. The time stamp (Ts) is of the same form as returned by \fIerlang:now()\fR\&\&.
.TP 2
.B
\fIcpu_timestamp\fR\&:
A global trace flag for the Erlang node that makes all trace timestamps be in CPU time, not wallclock\&. It is only allowed with \fIPidSpec==all\fR\&\&. If the host machine operating system does not support high resolution CPU time measurements, \fItrace/3\fR\& exits with \fIbadarg\fR\&\&.
.TP 2
.B
\fIarity\fR\&:
Used in conjunction with the \fIcall\fR\& trace flag\&. \fI{M, F, Arity}\fR\& will be specified instead of \fI{M, F, Args}\fR\& in call trace messages\&.
.TP 2
.B
\fIset_on_spawn\fR\&:
Makes any process created by a traced process inherit its trace flags, including the \fIset_on_spawn\fR\& flag\&.
.TP 2
.B
\fIset_on_first_spawn\fR\&:
Makes the first process created by a traced process inherit its trace flags, excluding the \fIset_on_first_spawn\fR\& flag\&.
.TP 2
.B
\fIset_on_link\fR\&:
Makes any process linked by a traced process inherit its trace flags, including the \fIset_on_link\fR\& flag\&.
.TP 2
.B
\fIset_on_first_link\fR\&:
Makes the first process linked to by a traced process inherit its trace flags, excluding the \fIset_on_first_link\fR\& flag\&.
.TP 2
.B
\fI{tracer, Tracer}\fR\&:
Specify where to send the trace messages\&. \fITracer\fR\& must be the pid of a local process or the port identifier of a local port\&. If this flag is not given, trace messages will be sent to the process that called \fIerlang:trace/3\fR\&\&.
.RE
.LP
The effect of combining \fIset_on_first_link\fR\& with \fIset_on_link\fR\& is the same as having \fIset_on_first_link\fR\& alone\&. Likewise for \fIset_on_spawn\fR\& and \fIset_on_first_spawn\fR\&\&.
.LP
If the \fItimestamp\fR\& flag is not given, the tracing process will receive the trace messages described below\&. \fIPid\fR\& is the pid of the traced process in which the traced event has occurred\&. The third element of the tuple is the message tag\&.
.LP
If the \fItimestamp\fR\& flag is given, the first element of the tuple will be \fItrace_ts\fR\& instead and the timestamp is added last in the tuple\&.
.RS 2
.TP 2
.B
\fI{trace, Pid, \&'receive\&', Msg}\fR\&:
When \fIPid\fR\& receives the message \fIMsg\fR\&\&.
.TP 2
.B
\fI{trace, Pid, send, Msg, To}\fR\&:
When \fIPid\fR\& sends the message \fIMsg\fR\& to the process \fITo\fR\&\&.
.TP 2
.B
\fI{trace, Pid, send_to_non_existing_process, Msg, To}\fR\&:
When \fIPid\fR\& sends the message \fIMsg\fR\& to the non-existing process \fITo\fR\&\&.
.TP 2
.B
\fI{trace, Pid, call, {M, F, Args}}\fR\&:
When \fIPid\fR\& calls a traced function\&. The return values of calls are never supplied, only the call and its arguments\&.
.RS 2
.LP
Note that the trace flag \fIarity\fR\& can be used to change the contents of this message, so that \fIArity\fR\& is specified instead of \fIArgs\fR\&\&.
.RE
.TP 2
.B
\fI{trace, Pid, return_to, {M, F, Arity}}\fR\&:
When \fIPid\fR\& returns \fIto\fR\& the specified function\&. This trace message is sent if both the \fIcall\fR\& and the \fIreturn_to\fR\& flags are set, and the function is set to be traced on \fIlocal\fR\& function calls\&. The message is only sent when returning from a chain of tail recursive function calls where at least one call generated a \fIcall\fR\& trace message (that is, the functions match specification matched and \fI{message, false}\fR\& was not an action)\&.
.TP 2
.B
\fI{trace, Pid, return_from, {M, F, Arity}, ReturnValue}\fR\&:
When \fIPid\fR\& returns \fIfrom\fR\& the specified function\&. This trace message is sent if the \fIcall\fR\& flag is set, and the function has a match specification with a \fIreturn_trace\fR\& or \fIexception_trace\fR\& action\&.
.TP 2
.B
\fI{trace, Pid, exception_from, {M, F, Arity}, {Class, Value}}\fR\&:
When \fIPid\fR\& exits \fIfrom\fR\& the specified function due to an exception\&. This trace message is sent if the \fIcall\fR\& flag is set, and the function has a match specification with an \fIexception_trace\fR\& action\&.
.TP 2
.B
\fI{trace, Pid, spawn, Pid2, {M, F, Args}}\fR\&:
When \fIPid\fR\& spawns a new process \fIPid2\fR\& with the specified function call as entry point\&.
.RS 2
.LP
Note that \fIArgs\fR\& is supposed to be the argument list, but may be any term in the case of an erroneous spawn\&.
.RE
.TP 2
.B
\fI{trace, Pid, exit, Reason}\fR\&:
When \fIPid\fR\& exits with reason \fIReason\fR\&\&.
.TP 2
.B
\fI{trace, Pid, link, Pid2}\fR\&:
When \fIPid\fR\& links to a process \fIPid2\fR\&\&.
.TP 2
.B
\fI{trace, Pid, unlink, Pid2}\fR\&:
When \fIPid\fR\& removes the link from a process \fIPid2\fR\&\&.
.TP 2
.B
\fI{trace, Pid, getting_linked, Pid2}\fR\&:
When \fIPid\fR\& gets linked to a process \fIPid2\fR\&\&.
.TP 2
.B
\fI{trace, Pid, getting_unlinked, Pid2}\fR\&:
When \fIPid\fR\& gets unlinked from a process \fIPid2\fR\&\&.
.TP 2
.B
\fI{trace, Pid, register, RegName}\fR\&:
When \fIPid\fR\& gets the name \fIRegName\fR\& registered\&.
.TP 2
.B
\fI{trace, Pid, unregister, RegName}\fR\&:
When \fIPid\fR\& gets the name \fIRegName\fR\& unregistered\&. Note that this is done automatically when a registered process exits\&.
.TP 2
.B
\fI{trace, Pid, in, {M, F, Arity} | 0}\fR\&:
When \fIPid\fR\& is scheduled to run\&. The process will run in function \fI{M, F, Arity}\fR\&\&. On some rare occasions the current function cannot be determined, then the last element \fIArity\fR\& is 0\&.
.TP 2
.B
\fI{trace, Pid, out, {M, F, Arity} | 0}\fR\&:
When \fIPid\fR\& is scheduled out\&. The process was running in function {M, F, Arity}\&. On some rare occasions the current function cannot be determined, then the last element \fIArity\fR\& is 0\&.
.TP 2
.B
\fB\fI{trace, Pid, gc_start, Info}\fR\&\fR\&:
Sent when garbage collection is about to be started\&. \fIInfo\fR\& is a list of two-element tuples, where the first element is a key, and the second is the value\&. You should not depend on the tuples have any defined order\&. Currently, the following keys are defined:
.RS 2
.TP 2
.B
\fIheap_size\fR\&:
The size of the used part of the heap\&.
.TP 2
.B
\fIheap_block_size\fR\&:
The size of the memory block used for storing the heap and the stack\&.
.TP 2
.B
\fIold_heap_size\fR\&:
The size of the used part of the old heap\&.
.TP 2
.B
\fIold_heap_block_size\fR\&:
The size of the memory block used for storing the old heap\&.
.TP 2
.B
\fIstack_size\fR\&:
The actual size of the stack\&.
.TP 2
.B
\fIrecent_size\fR\&:
The size of the data that survived the previous garbage collection\&.
.TP 2
.B
\fImbuf_size\fR\&:
The combined size of message buffers associated with the process\&.
.TP 2
.B
\fIbin_vheap_size\fR\&:
The total size of unique off-heap binaries referenced from the process heap\&.
.TP 2
.B
\fIbin_vheap_block_size\fR\&:
The total size of binaries, in words, allowed in the virtual heap in the process before doing a garbage collection\&. 
.TP 2
.B
\fIbin_old_vheap_size\fR\&:
The total size of unique off-heap binaries referenced from the process old heap\&.
.TP 2
.B
\fIbin_vheap_block_size\fR\&:
The total size of binaries, in words, allowed in the virtual old heap in the process before doing a garbage collection\&. 
.RE
.RS 2
.LP
All sizes are in words\&.
.RE
.TP 2
.B
\fI{trace, Pid, gc_end, Info}\fR\&:
Sent when garbage collection is finished\&. \fIInfo\fR\& contains the same kind of list as in the \fIgc_start\fR\& message, but the sizes reflect the new sizes after garbage collection\&.
.RE
.LP
If the tracing process dies, the flags will be silently removed\&.
.LP
Only one process can trace a particular process\&. For this reason, attempts to trace an already traced process will fail\&.
.LP
Returns: A number indicating the number of processes that matched \fIPidSpec\fR\&\&. If \fIPidSpec\fR\& is a pid, the return value will be \fI1\fR\&\&. If \fIPidSpec\fR\& is \fIall\fR\& or \fIexisting\fR\& the return value will be the number of processes running, excluding tracer processes\&. If \fIPidSpec\fR\& is \fInew\fR\&, the return value will be \fI0\fR\&\&.
.LP
Failure: If specified arguments are not supported\&. For example \fIcpu_timestamp\fR\& is not supported on all platforms\&.
.RE
.LP
.nf

.B
erlang:trace_delivered(Tracee) -> Ref
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tracee = pid() | all
.br
Ref = reference()
.br
.RE
.RE
.RS
.LP
The delivery of trace messages is dislocated on the time-line compared to other events in the system\&. If you know that the \fITracee\fR\& has passed some specific point in its execution, and you want to know when at least all trace messages corresponding to events up to this point have reached the tracer you can use \fIerlang:trace_delivered(Tracee)\fR\&\&. A \fI{trace_delivered, Tracee, Ref}\fR\& message is sent to the caller of \fIerlang:trace_delivered(Tracee)\fR\& when it is guaranteed that all trace messages have been delivered to the tracer up to the point that the \fITracee\fR\& had reached at the time of the call to \fIerlang:trace_delivered(Tracee)\fR\&\&.
.LP
Note that the \fItrace_delivered\fR\& message does \fInot\fR\& imply that trace messages have been delivered; instead, it implies that all trace messages that \fIshould\fR\& be delivered have been delivered\&. It is not an error if \fITracee\fR\& isn\&'t, and hasn\&'t been traced by someone, but if this is the case, \fIno\fR\& trace messages will have been delivered when the \fItrace_delivered\fR\& message arrives\&.
.LP
Note that \fITracee\fR\& has to refer to a process currently, or previously existing on the same node as the caller of \fIerlang:trace_delivered(Tracee)\fR\& resides on\&. The special \fITracee\fR\& atom \fIall\fR\& denotes all processes that currently are traced in the node\&.
.LP
An example: Process \fIA\fR\& is \fITracee\fR\&, port \fIB\fR\& is tracer, and process \fIC\fR\& is the port owner of \fIB\fR\&\&. \fIC\fR\& wants to close \fIB\fR\& when \fIA\fR\& exits\&. \fIC\fR\& can ensure that the trace isn\&'t truncated by calling \fIerlang:trace_delivered(A)\fR\& when \fIA\fR\& exits and wait for the \fI{trace_delivered, A, Ref}\fR\& message before closing \fIB\fR\&\&.
.LP
Failure: \fIbadarg\fR\& if \fITracee\fR\& does not refer to a process (dead or alive) on the same node as the caller of \fIerlang:trace_delivered(Tracee)\fR\& resides on\&.
.RE
.LP
.nf

.B
erlang:trace_info(PidOrFunc, Item) -> Res
.br
.fi
.br
.RS
.LP
Types:

.RS 3
PidOrFunc = pid() | new | {Module, Function, Arity} | on_load
.br
Module = module()
.br
Function = atom()
.br
Arity = arity()
.br
Item = flags
.br
     | tracer
.br
     | traced
.br
     | match_spec
.br
     | meta
.br
     | meta_match_spec
.br
     | call_count
.br
     | call_time
.br
     | all
.br
Res = \fBtrace_info_return()\fR\&
.br
.nf
\fBtrace_info_return()\fR\& = undefined
.br
                    | {flags, [\fBtrace_info_flag()\fR\&]}
.br
                    | {tracer, pid() | port() | []}
.br
                    | \fBtrace_info_item_result()\fR\&
.br
                    | {all,
.br
                       [\fBtrace_info_item_result()\fR\&] |
.br
                       false |
.br
                       undefined}
.fi
.br
.nf
\fBtrace_info_item_result()\fR\& = {traced,
.br
                            global | local | false | undefined}
.br
                         | {match_spec,
.br
                            \fBtrace_match_spec()\fR\& |
.br
                            false |
.br
                            undefined}
.br
                         | {meta,
.br
                            pid() |
.br
                            port() |
.br
                            false |
.br
                            undefined |
.br
                            []}
.br
                         | {meta_match_spec,
.br
                            \fBtrace_match_spec()\fR\& |
.br
                            false |
.br
                            undefined}
.br
                         | {call_count,
.br
                            integer() >= 0 |
.br
                            boolean() |
.br
                            undefined}
.br
                         | {call_time,
.br
                            [{pid(),
.br
                              integer() >= 0,
.br
                              integer() >= 0,
.br
                              integer() >= 0}] |
.br
                            boolean() |
.br
                            undefined}
.fi
.br
.nf
\fBtrace_info_flag()\fR\& = send
.br
                  | \&'receive\&'
.br
                  | set_on_spawn
.br
                  | call
.br
                  | return_to
.br
                  | procs
.br
                  | set_on_first_spawn
.br
                  | set_on_link
.br
                  | running
.br
                  | garbage_collection
.br
                  | timestamp
.br
                  | arity
.fi
.br
.nf
\fBtrace_match_spec()\fR\& = [{[term()] | \&'_\&', [term()], [term()]}]
.fi
.br
.RE
.RE
.RS
.LP
Returns trace information about a process or function\&.
.LP
To get information about a process, \fIPidOrFunc\fR\& should be a pid or the atom \fInew\fR\&\&. The atom \fInew\fR\& means that the default trace state for processes to be created will be returned\&. \fIItem\fR\& must have one of the following values:
.RS 2
.TP 2
.B
\fIflags\fR\&:
Return a list of atoms indicating what kind of traces is enabled for the process\&. The list will be empty if no traces are enabled, and one or more of the followings atoms if traces are enabled: \fIsend\fR\&, \fI\&'receive\&'\fR\&, \fIset_on_spawn\fR\&, \fIcall\fR\&, \fIreturn_to\fR\&, \fIprocs\fR\&, \fIset_on_first_spawn\fR\&, \fIset_on_link\fR\&, \fIrunning\fR\&, \fIgarbage_collection\fR\&, \fItimestamp\fR\&, and \fIarity\fR\&\&. The order is arbitrary\&.
.TP 2
.B
\fItracer\fR\&:
Return the identifier for process or port tracing this process\&. If this process is not being traced, the return value will be \fI[]\fR\&\&.
.RE
.LP
To get information about a function, \fIPidOrFunc\fR\& should be a three-element tuple: \fI{Module, Function, Arity}\fR\& or the atom \fIon_load\fR\&\&. No wildcards are allowed\&. Returns \fIundefined\fR\& if the function does not exist or \fIfalse\fR\& if the function is not traced at all\&. \fIItem\fR\& must have one of the following values:
.RS 2
.TP 2
.B
\fItraced\fR\&:
Return \fIglobal\fR\& if this function is traced on global function calls, \fIlocal\fR\& if this function is traced on local function calls (i\&.e local and global function calls), and \fIfalse\fR\& if neither local nor global function calls are traced\&.
.TP 2
.B
\fImatch_spec\fR\&:
Return the match specification for this function, if it has one\&. If the function is locally or globally traced but has no match specification defined, the returned value is \fI[]\fR\&\&.
.TP 2
.B
\fImeta\fR\&:
Return the meta trace tracer process or port for this function, if it has one\&. If the function is not meta traced the returned value is \fIfalse\fR\&, and if the function is meta traced but has once detected that the tracer proc is invalid, the returned value is []\&.
.TP 2
.B
\fImeta_match_spec\fR\&:
Return the meta trace match specification for this function, if it has one\&. If the function is meta traced but has no match specification defined, the returned value is \fI[]\fR\&\&.
.TP 2
.B
\fIcall_count\fR\&:
Return the call count value for this function or \fItrue\fR\& for the pseudo function \fIon_load\fR\& if call count tracing is active\&. Return \fIfalse\fR\& otherwise\&. See also \fBerlang:trace_pattern/3\fR\&\&.
.TP 2
.B
\fIcall_time\fR\&:
Return the call time values for this function or \fItrue\fR\& for the pseudo function \fIon_load\fR\& if call time tracing is active\&. Returns \fIfalse\fR\& otherwise\&. The call time values returned, \fI[{Pid, Count, S, Us}]\fR\&, is a list of each process that has executed the function and its specific counters\&. See also \fBerlang:trace_pattern/3\fR\&\&.
.TP 2
.B
\fIall\fR\&:
Return a list containing the \fI{Item, Value}\fR\& tuples for all other items, or return \fIfalse\fR\& if no tracing is active for this function\&.
.RE
.LP
The actual return value will be \fI{Item, Value}\fR\&, where \fIValue\fR\& is the requested information as described above\&. If a pid for a dead process was given, or the name of a non-existing function, \fIValue\fR\& will be \fIundefined\fR\&\&.
.LP
If \fIPidOrFunc\fR\& is the \fIon_load\fR\&, the information returned refers to the default value for code that will be loaded\&.
.RE
.LP
.nf

.B
erlang:trace_pattern(MFA, MatchSpec) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MFA = \fBtrace_pattern_mfa()\fR\&
.br
MatchSpec = (MatchSpecList :: \fBtrace_match_spec()\fR\&)
.br
          | boolean()
.br
          | restart
.br
          | pause
.br
.nf
\fBtrace_pattern_mfa()\fR\& = {atom(), atom(), arity() | \&'_\&'} | on_load
.fi
.br
.nf
\fBtrace_match_spec()\fR\& = [{[term()] | \&'_\&', [term()], [term()]}]
.fi
.br
.RE
.RE
.RS
.LP
The same as \fBerlang:trace_pattern(MFA, MatchSpec, [])\fR\&, retained for backward compatibility\&.
.RE
.LP
.nf

.B
erlang:trace_pattern(MFA, MatchSpec, FlagList) ->
.B
                        integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
MFA = \fBtrace_pattern_mfa()\fR\&
.br
MatchSpec = (MatchSpecList :: \fBtrace_match_spec()\fR\&)
.br
          | boolean()
.br
          | restart
.br
          | pause
.br
FlagList = [\fBtrace_pattern_flag()\fR\&]
.br
.nf
\fBtrace_pattern_mfa()\fR\& = {atom(), atom(), arity() | \&'_\&'} | on_load
.fi
.br
.nf
\fBtrace_match_spec()\fR\& = [{[term()] | \&'_\&', [term()], [term()]}]
.fi
.br
.nf
\fBtrace_pattern_flag()\fR\& = global
.br
                     | local
.br
                     | meta
.br
                     | {meta, Pid :: pid()}
.br
                     | call_count
.br
                     | call_time
.fi
.br
.RE
.RE
.RS
.LP
This BIF is used to enable or disable call tracing for exported functions\&. It must be combined with \fBerlang:trace/3\fR\& to set the \fIcall\fR\& trace flag for one or more processes\&.
.LP
Conceptually, call tracing works like this: Inside the Erlang virtual machine there is a set of processes to be traced and a set of functions to be traced\&. Tracing will be enabled on the intersection of the set\&. That is, if a process included in the traced process set calls a function included in the traced function set, the trace action will be taken\&. Otherwise, nothing will happen\&.
.LP
Use \fBerlang:trace/3\fR\& to add or remove one or more processes to the set of traced processes\&. Use \fIerlang:trace_pattern/2\fR\& to add or remove exported functions to the set of traced functions\&.
.LP
The \fIerlang:trace_pattern/3\fR\& BIF can also add match specifications to an exported function\&. A match specification comprises a pattern that the arguments to the function must match, a guard expression which must evaluate to \fItrue\fR\& and an action to be performed\&. The default action is to send a trace message\&. If the pattern does not match or the guard fails, the action will not be executed\&.
.LP
The \fIMFA\fR\& argument should be a tuple like \fI{Module, Function, Arity}\fR\& or the atom \fIon_load\fR\& (described below)\&. It can be the module, function, and arity for an exported function (or a BIF in any module)\&. The \fI\&'_\&'\fR\& atom can be used to mean any of that kind\&. Wildcards can be used in any of the following ways:
.RS 2
.TP 2
.B
\fI{Module,Function,\&'_\&'}\fR\&:
All exported functions of any arity named \fIFunction\fR\& in module \fIModule\fR\&\&.
.TP 2
.B
\fI{Module,\&'_\&',\&'_\&'}\fR\&:
All exported functions in module \fIModule\fR\&\&.
.TP 2
.B
\fI{\&'_\&',\&'_\&',\&'_\&'}\fR\&:
All exported functions in all loaded modules\&.
.RE
.LP
Other combinations, such as \fI{Module,\&'_\&',Arity}\fR\&, are not allowed\&. Local functions will match wildcards only if the \fIlocal\fR\& option is in the \fIFlagList\fR\&\&.
.LP
If the \fIMFA\fR\& argument is the atom \fIon_load\fR\&, the match specification and flag list will be used on all modules that are newly loaded\&.
.LP
The \fIMatchSpec\fR\& argument can take any of the following forms:
.RS 2
.TP 2
.B
\fIfalse\fR\&:
Disable tracing for the matching function(s)\&. Any match specification will be removed\&.
.TP 2
.B
\fItrue\fR\&:
Enable tracing for the matching function(s)\&.
.TP 2
.B
\fIMatchSpecList\fR\&:
A list of match specifications\&. An empty list is equivalent to \fItrue\fR\&\&. See the ERTS User\&'s Guide for a description of match specifications\&.
.TP 2
.B
\fIrestart\fR\&:
For the \fIFlagList\fR\& option \fIcall_count\fR\& and \fIcall_time\fR\&: restart the existing counters\&. The behaviour is undefined for other \fIFlagList\fR\& options\&.
.TP 2
.B
\fIpause\fR\&:
For the \fIFlagList\fR\& option \fIcall_count\fR\& and \fIcall_time\fR\&: pause the existing counters\&. The behaviour is undefined for other \fIFlagList\fR\& options\&.
.RE
.LP
The \fIFlagList\fR\& parameter is a list of options\&. The following options are allowed:
.RS 2
.TP 2
.B
\fIglobal\fR\&:
Turn on or off call tracing for global function calls (that is, calls specifying the module explicitly)\&. Only exported functions will match and only global calls will generate trace messages\&. This is the default\&.
.TP 2
.B
\fIlocal\fR\&:
Turn on or off call tracing for all types of function calls\&. Trace messages will be sent whenever any of the specified functions are called, regardless of how they are called\&. If the \fIreturn_to\fR\& flag is set for the process, a \fIreturn_to\fR\& message will also be sent when this function returns to its caller\&.
.TP 2
.B
\fImeta | {meta, Pid}\fR\&:
Turn on or off meta tracing for all types of function calls\&. Trace messages will be sent to the tracer process or port \fIPid\fR\& whenever any of the specified functions are called, regardless of how they are called\&. If no \fIPid\fR\& is specified, \fIself()\fR\& is used as a default tracer process\&.
.RS 2
.LP
Meta tracing traces all processes and does not care about the process trace flags set by \fItrace/3\fR\&, the trace flags are instead fixed to \fI[call, timestamp]\fR\&\&.
.RE
.RS 2
.LP
The match spec function \fI{return_trace}\fR\& works with meta trace and send its trace message to the same tracer process\&.
.RE
.TP 2
.B
\fIcall_count\fR\&:
Starts (\fIMatchSpec == true\fR\&) or stops (\fIMatchSpec == false\fR\&) call count tracing for all types of function calls\&. For every function a counter is incremented when the function is called, in any process\&. No process trace flags need to be activated\&.
.RS 2
.LP
If call count tracing is started while already running, the count is restarted from zero\&. Running counters can be paused with \fIMatchSpec == pause\fR\&\&. Paused and running counters can be restarted from zero with \fIMatchSpec == restart\fR\&\&.
.RE
.RS 2
.LP
The counter value can be read with \fBerlang:trace_info/2\fR\&\&.
.RE
.TP 2
.B
\fIcall_time\fR\&:
Starts (\fIMatchSpec == true\fR\&) or stops (\fIMatchSpec == false\fR\&) call time tracing for all types of function calls\&. For every function a counter is incremented when the function is called\&. Time spent in the function is accumulated in two other counters, seconds and micro-seconds\&. The counters are stored for each call traced process\&.
.RS 2
.LP
If call time tracing is started while already running, the count and time is restarted from zero\&. Running counters can be paused with \fIMatchSpec == pause\fR\&\&. Paused and running counters can be restarted from zero with \fIMatchSpec == restart\fR\&\&.
.RE
.RS 2
.LP
The counter value can be read with \fBerlang:trace_info/2\fR\&\&.
.RE
.RE
.LP
The \fIglobal\fR\& and \fIlocal\fR\& options are mutually exclusive and \fIglobal\fR\& is the default (if no options are specified)\&. The \fIcall_count\fR\& and \fImeta\fR\& options perform a kind of local tracing, and can also not be combined with \fIglobal\fR\&\&. A function can be either globally or locally traced\&. If global tracing is specified for a specified set of functions; local, meta, call time and call count tracing for the matching set of local functions will be disabled, and vice versa\&.
.LP
When disabling trace, the option must match the type of trace that is set on the function, so that local tracing must be disabled with the \fIlocal\fR\& option and global tracing with the \fIglobal\fR\& option (or no option at all), and so forth\&.
.LP
There is no way to directly change part of a match specification list\&. If a function has a match specification, you can replace it with a completely new one\&. If you need to change an existing match specification, use the \fBerlang:trace_info/2\fR\& BIF to retrieve the existing match specification\&.
.LP
Returns the number of exported functions that matched the \fIMFA\fR\& argument\&. This will be zero if none matched at all\&.
.RE
.LP
.nf

.B
trunc(Number) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Number = number()
.br
.RE
.RE
.RS
.LP
Returns an integer by the truncating \fINumber\fR\&\&.
.LP
.nf

> trunc(5\&.5)\&.
5
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
tuple_size(Tuple) -> integer() >= 0
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tuple = tuple()
.br
.RE
.RE
.RS
.LP
Returns an integer which is the number of elements in \fITuple\fR\&\&.
.LP
.nf

> tuple_size({morni, mulle, bwange})\&.
3
.fi
.LP
Allowed in guard tests\&.
.RE
.LP
.nf

.B
tuple_to_list(Tuple) -> [term()]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Tuple = tuple()
.br
.RE
.RE
.RS
.LP
Returns a list which corresponds to \fITuple\fR\&\&. \fITuple\fR\& may contain any Erlang terms\&.
.LP
.nf

> tuple_to_list({share, {\&'Ericsson_B\&', 163}})\&.
[share,{'Ericsson_B',163}]
.fi
.RE
.LP
.nf

.B
erlang:universaltime() -> DateTime
.br
.fi
.br
.RS
.LP
Types:

.RS 3
DateTime = \fBcalendar:datetime()\fR\&
.br
.RE
.RE
.RS
.LP
Returns the current date and time according to Universal Time Coordinated (UTC), also called GMT, in the form \fI{{Year, Month, Day}, {Hour, Minute, Second}}\fR\& if supported by the underlying operating system\&. If not, \fIerlang:universaltime()\fR\& is equivalent to \fIerlang:localtime()\fR\&\&.
.LP
.nf

> erlang:universaltime()\&.
{{1996,11,6},{14,18,43}}
.fi
.RE
.LP
.nf

.B
erlang:universaltime_to_localtime(Universaltime) -> Localtime
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Localtime = Universaltime = \fBcalendar:datetime()\fR\&
.br
.RE
.RE
.RS
.LP
Converts Universal Time Coordinated (UTC) date and time to local date and time, if this is supported by the underlying OS\&. Otherwise, no conversion is done, and \fIUniversaltime\fR\& is returned\&.
.LP
.nf

> erlang:universaltime_to_localtime({{1996,11,6},{14,18,43}})\&.
{{1996,11,7},{15,18,43}}
.fi
.LP
Failure: \fIbadarg\fR\& if \fIUniversaltime\fR\& does not denote a valid date and time\&.
.RE
.LP
.nf

.B
unlink(Id) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Id = pid() | port()
.br
.RE
.RE
.RS
.LP
Removes the link, if there is one, between the calling process and the process or port referred to by \fIId\fR\&\&.
.LP
Returns \fItrue\fR\& and does not fail, even if there is no link to \fIId\fR\&, or if \fIId\fR\& does not exist\&.
.LP
Once \fIunlink(Id)\fR\& has returned it is guaranteed that the link between the caller and the entity referred to by \fIId\fR\& has no effect on the caller in the future (unless the link is setup again)\&. If caller is trapping exits, an \fI{\&'EXIT\&', Id, _}\fR\& message due to the link might have been placed in the caller\&'s message queue prior to the call, though\&. Note, the \fI{\&'EXIT\&', Id, _}\fR\& message can be the result of the link, but can also be the result of \fIId\fR\& calling \fIexit/2\fR\&\&. Therefore, it \fImay\fR\& be appropriate to cleanup the message queue when trapping exits after the call to \fIunlink(Id)\fR\&, as follow:
.LP
.nf


    unlink(Id),
    receive
        {'EXIT', Id, _} ->
            true
    after 0 ->
            true
    end
.fi
.LP

.RS -4
.B
Note:
.RE
Prior to OTP release R11B (erts version 5\&.5) \fIunlink/1\fR\& behaved completely asynchronous, i\&.e\&., the link was active until the "unlink signal" reached the linked entity\&. This had one undesirable effect, though\&. You could never know when you were guaranteed \fInot\fR\& to be effected by the link\&.
.LP
Current behavior can be viewed as two combined operations: asynchronously send an "unlink signal" to the linked entity and ignore any future results of the link\&.

.RE
.LP
.nf

.B
unregister(RegName) -> true
.br
.fi
.br
.RS
.LP
Types:

.RS 3
RegName = atom()
.br
.RE
.RE
.RS
.LP
Removes the registered name \fIRegName\fR\&, associated with a pid or a port identifier\&.
.LP
.nf

> unregister(db)\&.
true
.fi
.LP
Users are advised not to unregister system processes\&.
.LP
Failure: \fIbadarg\fR\& if \fIRegName\fR\& is not a registered name\&.
.RE
.LP
.nf

.B
whereis(RegName) -> pid() | port() | undefined
.br
.fi
.br
.RS
.LP
Types:

.RS 3
RegName = atom()
.br
.RE
.RE
.RS
.LP
Returns the pid or port identifier with the registered name \fIRegName\fR\&\&. Returns \fIundefined\fR\& if the name is not registered\&.
.LP
.nf

> whereis(db)\&.
<0.43.0>
.fi
.RE
.LP
.nf

.B
erlang:yield() -> true
.br
.fi
.br
.RS
.LP
Voluntarily let other processes (if any) get a chance to execute\&. Using \fIerlang:yield()\fR\& is similar to \fIreceive after 1 -> ok end\fR\&, except that \fIyield()\fR\& is faster\&.
.LP

.RS -4
.B
Warning:
.RE
There is seldom or never any need to use this BIF, especially in the SMP-emulator as other processes will have a chance to run in another scheduler thread anyway\&. Using this BIF without a thorough grasp of how the scheduler works may cause performance degradation\&.

.RE