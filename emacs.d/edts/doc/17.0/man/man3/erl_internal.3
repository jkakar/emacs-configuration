.TH erl_internal 3 "stdlib 2.0" "Ericsson AB" "Erlang Module Definition"
.SH NAME
erl_internal \- Internal Erlang Definitions
.SH DESCRIPTION
.LP
This module defines Erlang BIFs, guard tests and operators\&. This module is only of interest to programmers who manipulate Erlang code\&.
.SH EXPORTS
.LP
.nf

.B
bif(Name, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIName/Arity\fR\& is an Erlang BIF which is automatically recognized by the compiler, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
guard_bif(Name, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIName/Arity\fR\& is an Erlang BIF which is allowed in guards, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
type_test(Name, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIName/Arity\fR\& is a valid Erlang type test, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
arith_op(OpName, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOpName/Arity\fR\& is an arithmetic operator, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
bool_op(OpName, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOpName/Arity\fR\& is a Boolean operator, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
comp_op(OpName, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOpName/Arity\fR\& is a comparison operator, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
list_op(OpName, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOpName/Arity\fR\& is a list operator, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
send_op(OpName, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOpName/Arity\fR\& is a send operator, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
op_type(OpName, Arity) -> Type
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
Type = arith | bool | comp | list | send
.br
.RE
.RE
.RS
.LP
Returns the \fIType\fR\& of operator that \fIOpName/Arity\fR\& belongs to, or generates a \fIfunction_clause\fR\& error if it is not an operator at all\&.
.RE