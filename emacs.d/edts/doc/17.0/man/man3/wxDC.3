.TH wxDC 3 "wx 1.2" "" "Erlang Module Definition"
.SH NAME
wxDC \- See external documentation: wxDC.
.SH DESCRIPTION
.LP
See external documentation: wxDC\&.
.SH "DATA TYPES"

.RS 2
.TP 2
.B
\fIwxDC()\fR\&:

.RS 2
.LP
An object reference, The representation is internal and can be changed without notice\&. It can\&'t be used for comparsion stored on disc or distributed for use on other nodes\&.
.RE
.RE
.SH EXPORTS
.LP
.B
blit(This, DestPt, Sz, Source, SrcPt) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
DestPt = {X::integer(), Y::integer()}
.br
Sz = {W::integer(), H::integer()}
.br
Source = wxDC()
.br
SrcPt = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
Equivalent to \fBblit(This, DestPt, Sz, Source, SrcPt, [])\fR\&\&.
.RE
.LP
.B
blit(This, DestPt, Sz, Source, SrcPt, Option::[Option]) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
DestPt = {X::integer(), Y::integer()}
.br
Sz = {W::integer(), H::integer()}
.br
Source = wxDC()
.br
SrcPt = {X::integer(), Y::integer()}
.br
Option = {rop, wx_enum() (see module wx)} | {useMask, boolean()} | {srcPtMask, {X::integer(), Y::integer()}}
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Rop = integer
.RE
.LP
.B
calcBoundingBox(This, X, Y) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = integer()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
clear(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
computeScaleAndOrigin(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
\fIThis function is deprecated: \fR\&deprecated function not available in wxWidgets-2\&.9 and later
.LP
See external documentation\&.
.RE
.LP
.B
crossHair(This, Pt) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
destroyClippingRegion(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
deviceToLogicalX(This, X) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
deviceToLogicalXRel(This, X) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
deviceToLogicalY(This, Y) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
deviceToLogicalYRel(This, Y) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawArc(This, Pt1, Pt2, Centre) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt1 = {X::integer(), Y::integer()}
.br
Pt2 = {X::integer(), Y::integer()}
.br
Centre = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawBitmap(This, Bmp, Pt) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Bmp = wxBitmap() (see module wxBitmap)
.br
Pt = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
Equivalent to \fBdrawBitmap(This, Bmp, Pt, [])\fR\&\&.
.RE
.LP
.B
drawBitmap(This, Bmp, Pt, Option::[Option]) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Bmp = wxBitmap() (see module wxBitmap)
.br
Pt = {X::integer(), Y::integer()}
.br
Option = {useMask, boolean()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawCheckMark(This, Rect) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawCircle(This, Pt, Radius) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
Radius = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawEllipse(This, Rect) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawEllipse(This, Pt, Sz) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
Sz = {W::integer(), H::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawEllipticArc(This, Pt, Sz, Sa, Ea) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
Sz = {W::integer(), H::integer()}
.br
Sa = number()
.br
Ea = number()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawIcon(This, Icon, Pt) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Icon = wxIcon() (see module wxIcon)
.br
Pt = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawLabel(This, Text, Rect) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Text = chardata() (see module unicode)
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
.RE
.RE
.RS
.LP
Equivalent to \fBdrawLabel(This, Text, Rect, [])\fR\&\&.
.RE
.LP
.B
drawLabel(This, Text, Rect, Option::[Option]) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Text = chardata() (see module unicode)
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
Option = {alignment, integer()} | {indexAccel, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawLine(This, Pt1, Pt2) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt1 = {X::integer(), Y::integer()}
.br
Pt2 = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawLines(This, Points) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Points = [{X::integer(), Y::integer()}]
.br
.RE
.RE
.RS
.LP
Equivalent to \fBdrawLines(This, Points, [])\fR\&\&.
.RE
.LP
.B
drawLines(This, Points, Option::[Option]) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Points = [{X::integer(), Y::integer()}]
.br
Option = {xoffset, integer()} | {yoffset, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawPolygon(This, Points) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Points = [{X::integer(), Y::integer()}]
.br
.RE
.RE
.RS
.LP
Equivalent to \fBdrawPolygon(This, Points, [])\fR\&\&.
.RE
.LP
.B
drawPolygon(This, Points, Option::[Option]) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Points = [{X::integer(), Y::integer()}]
.br
Option = {xoffset, integer()} | {yoffset, integer()} | {fillStyle, wx_enum() (see module wx)}
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
FillStyle = integer
.RE
.LP
.B
drawPoint(This, Pt) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawRectangle(This, Rect) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawRectangle(This, Pt, Sz) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
Sz = {W::integer(), H::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawRotatedText(This, Text, Pt, Angle) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Text = chardata() (see module unicode)
.br
Pt = {X::integer(), Y::integer()}
.br
Angle = number()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawRoundedRectangle(This, R, Radius) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
R = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
Radius = number()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawRoundedRectangle(This, Pt, Sz, Radius) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
Sz = {W::integer(), H::integer()}
.br
Radius = number()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
drawText(This, Text, Pt) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Text = chardata() (see module unicode)
.br
Pt = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
endDoc(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
endPage(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
floodFill(This, Pt, Col) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
Col = wx_colour() (see module wx)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBfloodFill(This, Pt, Col, [])\fR\&\&.
.RE
.LP
.B
floodFill(This, Pt, Col, Option::[Option]) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
Col = wx_colour() (see module wx)
.br
Option = {style, wx_enum() (see module wx)}
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Style = integer
.RE
.LP
.B
getBackground(This) -> wxBrush() (see module wxBrush)
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getBackgroundMode(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getBrush(This) -> wxBrush() (see module wxBrush)
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getCharHeight(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getCharWidth(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getClippingBox(This) -> Result
.br
.RS
.LP
Types:

.RS 3
Result = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getFont(This) -> wxFont() (see module wxFont)
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getLayoutDirection(This) -> wx_enum() (see module wx)
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Res = ?wxLayout_Default | ?wxLayout_LeftToRight | ?wxLayout_RightToLeft
.RE
.LP
.B
getLogicalFunction(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getMapMode(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getMultiLineTextExtent(This, String) -> {W::integer(), H::integer()}
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
String = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getMultiLineTextExtent(This, String, Option::[Option]) -> {Width::integer(), Height::integer(), HeightLine::integer()}
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
String = chardata() (see module unicode)
.br
Option = {font, wxFont() (see module wxFont)}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getPartialTextExtents(This, Text) -> Result
.br
.RS
.LP
Types:

.RS 3
Result = {Res::boolean(), Widths::[integer()]}
.br
This = wxDC()
.br
Text = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getPen(This) -> wxPen() (see module wxPen)
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getPixel(This, Pt) -> Result
.br
.RS
.LP
Types:

.RS 3
Result = {Res::boolean(), Col::wx_colour4() (see module wx)}
.br
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getPPI(This) -> {W::integer(), H::integer()}
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getSize(This) -> {W::integer(), H::integer()}
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getSizeMM(This) -> {W::integer(), H::integer()}
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getTextBackground(This) -> wx_colour4() (see module wx)
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getTextExtent(This, String) -> {W::integer(), H::integer()}
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
String = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getTextExtent(This, String, Option::[Option]) -> Result
.br
.RS
.LP
Types:

.RS 3
Result = {X::integer(), Y::integer(), Descent::integer(), ExternalLeading::integer()}
.br
This = wxDC()
.br
String = chardata() (see module unicode)
.br
Option = {theFont, wxFont() (see module wxFont)}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getTextForeground(This) -> wx_colour4() (see module wx)
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getUserScale(This) -> {X::number(), Y::number()}
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
gradientFillConcentric(This, Rect, InitialColour, DestColour) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
InitialColour = wx_colour() (see module wx)
.br
DestColour = wx_colour() (see module wx)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
gradientFillConcentric(This, Rect, InitialColour, DestColour, CircleCenter) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
InitialColour = wx_colour() (see module wx)
.br
DestColour = wx_colour() (see module wx)
.br
CircleCenter = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
gradientFillLinear(This, Rect, InitialColour, DestColour) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
InitialColour = wx_colour() (see module wx)
.br
DestColour = wx_colour() (see module wx)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBgradientFillLinear(This, Rect, InitialColour, DestColour, [])\fR\&\&.
.RE
.LP
.B
gradientFillLinear(This, Rect, InitialColour, DestColour, Option::[Option]) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
InitialColour = wx_colour() (see module wx)
.br
DestColour = wx_colour() (see module wx)
.br
Option = {nDirection, wx_enum() (see module wx)}
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
NDirection = ?wxLEFT | ?wxRIGHT | ?wxUP | ?wxDOWN | ?wxTOP | ?wxBOTTOM | ?wxNORTH | ?wxSOUTH | ?wxWEST | ?wxEAST | ?wxALL
.RE
.LP
.B
logicalToDeviceX(This, X) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
logicalToDeviceXRel(This, X) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
logicalToDeviceY(This, Y) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
logicalToDeviceYRel(This, Y) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
maxX(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
maxY(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
minX(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
minY(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
isOk(This) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
resetBoundingBox(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setAxisOrientation(This, XLeftRight, YBottomUp) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
XLeftRight = boolean()
.br
YBottomUp = boolean()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setBackground(This, Brush) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Brush = wxBrush() (see module wxBrush)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setBackgroundMode(This, Mode) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Mode = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setBrush(This, Brush) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Brush = wxBrush() (see module wxBrush)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setClippingRegion(This, Region) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Region = wxRegion() (see module wxRegion)
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
setClippingRegion(This, Rect) -> ok when
.br
This::wxDC(), Rect::{X::integer(), Y::integer(), W::integer(), H::integer()}\&.
.br

.RE
.LP
.B
setClippingRegion(This, Pt, Sz) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X::integer(), Y::integer()}
.br
Sz = {W::integer(), H::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setDeviceOrigin(This, X, Y) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = integer()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setFont(This, Font) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Font = wxFont() (see module wxFont)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setLayoutDirection(This, Dir) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Dir = wx_enum() (see module wx)
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Dir = ?wxLayout_Default | ?wxLayout_LeftToRight | ?wxLayout_RightToLeft
.RE
.LP
.B
setLogicalFunction(This, Function) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Function = wx_enum() (see module wx)
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Function = integer
.RE
.LP
.B
setMapMode(This, Mode) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Mode = wx_enum() (see module wx)
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Mode = integer
.RE
.LP
.B
setPalette(This, Palette) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Palette = wxPalette() (see module wxPalette)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setPen(This, Pen) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pen = wxPen() (see module wxPen)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setTextBackground(This, Colour) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Colour = wx_colour() (see module wx)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setTextForeground(This, Colour) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Colour = wx_colour() (see module wx)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setUserScale(This, X, Y) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = number()
.br
Y = number()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
startDoc(This, Message) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Message = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
startPage(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.SH AUTHORS
.LP

.I
<>