.TH wxImage 3 "wx 1.2" "" "Erlang Module Definition"
.SH NAME
wxImage \- See external documentation: wxImage.
.SH DESCRIPTION
.LP
See external documentation: wxImage\&.
.LP
All (default) image handlers are initialized\&.
.SH "DATA TYPES"

.RS 2
.TP 2
.B
\fIwxImage()\fR\&:

.RS 2
.LP
An object reference, The representation is internal and can be changed without notice\&. It can\&'t be used for comparsion stored on disc or distributed for use on other nodes\&.
.RE
.RE
.SH EXPORTS
.LP
.B
new() -> wxImage()
.br
.RS
.LP
See external documentation\&.
.RE
.LP
.B
new(Name) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
Name = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBnew(Name, [])\fR\&\&.
.RE
.LP
.B
new(Width, Height) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
Width = integer()
.br
Height = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
new(Name, [Option]) -> wxImage() when
.br
Name::unicode:chardata(),
.br
Option :: {type, integer()}
.br
| {index, integer()}\&.
.br

.RE
.LP
.B
new(Width, Height, Data) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
Width = integer()
.br
Height = integer()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
new(Width, Height, [Option]) -> wxImage() when
.br
Width::integer(), Height::integer(),
.br
Option :: {clear, boolean()};
.br
(Name, Mimetype, [Option]) -> wxImage() when
.br
Name::unicode:chardata(), Mimetype::unicode:chardata(),
.br
Option :: {index, integer()}\&.
.br

.RE
.LP
.B
new(Width, Height, Data, Alpha) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
Width = integer()
.br
Height = integer()
.br
Data = binary()
.br
Alpha = binary()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
new(Width, Height, Data, [Option]) -> wxImage() when
.br
Width::integer(), Height::integer(), Data::binary(),
.br
Option :: {static_data, boolean()}\&.
.br

.RE
.LP
.B
new(Width, Height, Data, Alpha, Option::[Option]) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
Width = integer()
.br
Height = integer()
.br
Data = binary()
.br
Alpha = binary()
.br
Option = {static_data, boolean()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
blur(This, Radius) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Radius = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
blurHorizontal(This, Radius) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Radius = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
blurVertical(This, Radius) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Radius = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
convertAlphaToMask(This) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBconvertAlphaToMask(This, [])\fR\&\&.
.RE
.LP
.B
convertAlphaToMask(This, Option::[Option]) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Option = {threshold, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
convertToGreyscale(This) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBconvertToGreyscale(This, [])\fR\&\&.
.RE
.LP
.B
convertToGreyscale(This, Option::[Option]) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Option = {lr, number()} | {lg, number()} | {lb, number()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
convertToMono(This, R, G, B) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
R = integer()
.br
G = integer()
.br
B = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
copy(This) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
create(This, Width, Height) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Width = integer()
.br
Height = integer()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBcreate(This, Width, Height, [])\fR\&\&.
.RE
.LP
.B
create(This, Width, Height, Data) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Width = integer()
.br
Height = integer()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
create(This, Width, Height, [Option]) -> boolean() when
.br
This::wxImage(), Width::integer(), Height::integer(),
.br
Option :: {clear, boolean()}\&.
.br

.RE
.LP
.B
create(This, Width, Height, Data, Alpha) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Width = integer()
.br
Height = integer()
.br
Data = binary()
.br
Alpha = binary()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
create(This, Width, Height, Data, [Option]) -> boolean() when
.br
This::wxImage(), Width::integer(), Height::integer(), Data::binary(),
.br
Option :: {static_data, boolean()}\&.
.br

.RE
.LP
.B
create(This, Width, Height, Data, Alpha, Option::[Option]) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Width = integer()
.br
Height = integer()
.br
Data = binary()
.br
Alpha = binary()
.br
Option = {static_data, boolean()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
Destroy(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
findFirstUnusedColour(This) -> Result
.br
.RS
.LP
Types:

.RS 3
Result = {Res::boolean(), R::integer(), G::integer(), B::integer()}
.br
This = wxImage()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBfindFirstUnusedColour(This, [])\fR\&\&.
.RE
.LP
.B
findFirstUnusedColour(This, Option::[Option]) -> Result
.br
.RS
.LP
Types:

.RS 3
Result = {Res::boolean(), R::integer(), G::integer(), B::integer()}
.br
This = wxImage()
.br
Option = {startR, integer()} | {startG, integer()} | {startB, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getImageExtWildcard() -> charlist() (see module unicode)
.br
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getAlpha(This) -> binary()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getAlpha(This, X, Y) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
X = integer()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getBlue(This, X, Y) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
X = integer()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getData(This) -> binary()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getGreen(This, X, Y) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
X = integer()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getImageCount(Name) -> integer()
.br
.RS
.LP
Types:

.RS 3
Name = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBgetImageCount(Name, [])\fR\&\&.
.RE
.LP
.B
getImageCount(Name, Option::[Option]) -> integer()
.br
.RS
.LP
Types:

.RS 3
Name = chardata() (see module unicode)
.br
Option = {type, wx_enum() (see module wx)}
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Type = ?wxBITMAP_TYPE_INVALID | ?wxBITMAP_TYPE_BMP | ?wxBITMAP_TYPE_BMP_RESOURCE | ?wxBITMAP_TYPE_RESOURCE | ?wxBITMAP_TYPE_ICO | ?wxBITMAP_TYPE_ICO_RESOURCE | ?wxBITMAP_TYPE_CUR | ?wxBITMAP_TYPE_CUR_RESOURCE | ?wxBITMAP_TYPE_XBM | ?wxBITMAP_TYPE_XBM_DATA | ?wxBITMAP_TYPE_XPM | ?wxBITMAP_TYPE_XPM_DATA | ?wxBITMAP_TYPE_TIF | ?wxBITMAP_TYPE_TIF_RESOURCE | ?wxBITMAP_TYPE_GIF | ?wxBITMAP_TYPE_GIF_RESOURCE | ?wxBITMAP_TYPE_PNG | ?wxBITMAP_TYPE_PNG_RESOURCE | ?wxBITMAP_TYPE_JPEG | ?wxBITMAP_TYPE_JPEG_RESOURCE | ?wxBITMAP_TYPE_PNM | ?wxBITMAP_TYPE_PNM_RESOURCE | ?wxBITMAP_TYPE_PCX | ?wxBITMAP_TYPE_PCX_RESOURCE | ?wxBITMAP_TYPE_PICT | ?wxBITMAP_TYPE_PICT_RESOURCE | ?wxBITMAP_TYPE_ICON | ?wxBITMAP_TYPE_ICON_RESOURCE | ?wxBITMAP_TYPE_ANI | ?wxBITMAP_TYPE_IFF | ?wxBITMAP_TYPE_TGA | ?wxBITMAP_TYPE_MACCURSOR | ?wxBITMAP_TYPE_MACCURSOR_RESOURCE | ?wxBITMAP_TYPE_ANY
.RE
.LP
.B
getHeight(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getMaskBlue(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getMaskGreen(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getMaskRed(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getOrFindMaskColour(This) -> Result
.br
.RS
.LP
Types:

.RS 3
Result = {Res::boolean(), R::integer(), G::integer(), B::integer()}
.br
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getPalette(This) -> wxPalette() (see module wxPalette)
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getRed(This, X, Y) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
X = integer()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getSubImage(This, Rect) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getWidth(This) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
hasAlpha(This) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
hasMask(This) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getOption(This, Name) -> charlist() (see module unicode)
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Name = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
getOptionInt(This, Name) -> integer()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Name = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
hasOption(This, Name) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Name = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
initAlpha(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
initStandardHandlers() -> ok
.br
.RS
.LP
See external documentation\&.
.RE
.LP
.B
isTransparent(This, X, Y) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
X = integer()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBisTransparent(This, X, Y, [])\fR\&\&.
.RE
.LP
.B
isTransparent(This, X, Y, Option::[Option]) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
X = integer()
.br
Y = integer()
.br
Option = {threshold, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
loadFile(This, Name) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Name = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
Equivalent to \fBloadFile(This, Name, [])\fR\&\&.
.RE
.LP
.B
loadFile(This, Name, Option::[Option]) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Name = chardata() (see module unicode)
.br
Option = {type, integer()} | {index, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
loadFile(This, Name, Mimetype, Option::[Option]) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Name = chardata() (see module unicode)
.br
Mimetype = chardata() (see module unicode)
.br
Option = {index, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
ok(This) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
removeHandler(Name) -> boolean()
.br
.RS
.LP
Types:

.RS 3
Name = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
mirror(This) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBmirror(This, [])\fR\&\&.
.RE
.LP
.B
mirror(This, Option::[Option]) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Option = {horizontally, boolean()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
replace(This, R1, G1, B1, R2, G2, B2) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
R1 = integer()
.br
G1 = integer()
.br
B1 = integer()
.br
R2 = integer()
.br
G2 = integer()
.br
B2 = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
rescale(This, Width, Height) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Width = integer()
.br
Height = integer()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBrescale(This, Width, Height, [])\fR\&\&.
.RE
.LP
.B
rescale(This, Width, Height, Option::[Option]) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Width = integer()
.br
Height = integer()
.br
Option = {quality, wx_enum() (see module wx)}
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Quality = integer
.RE
.LP
.B
resize(This, Size, Pos) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Size = {W::integer(), H::integer()}
.br
Pos = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
Equivalent to \fBresize(This, Size, Pos, [])\fR\&\&.
.RE
.LP
.B
resize(This, Size, Pos, Option::[Option]) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Size = {W::integer(), H::integer()}
.br
Pos = {X::integer(), Y::integer()}
.br
Option = {r, integer()} | {g, integer()} | {b, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
rotate(This, Angle, Centre_of_rotation) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Angle = number()
.br
Centre_of_rotation = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
Equivalent to \fBrotate(This, Angle, Centre_of_rotation, [])\fR\&\&.
.RE
.LP
.B
rotate(This, Angle, Centre_of_rotation, Option::[Option]) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Angle = number()
.br
Centre_of_rotation = {X::integer(), Y::integer()}
.br
Option = {interpolating, boolean()} | {offset_after_rotation, {X::integer(), Y::integer()}}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
rotateHue(This, Angle) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Angle = number()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
rotate90(This) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBrotate90(This, [])\fR\&\&.
.RE
.LP
.B
rotate90(This, Option::[Option]) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Option = {clockwise, boolean()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
saveFile(This, Name) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Name = chardata() (see module unicode)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
saveFile(This, Name, Type) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Name = chardata() (see module unicode)
.br
Type = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
saveFile(This, Name, Mimetype) -> boolean() when
.br
This::wxImage(), Name::unicode:chardata(), Mimetype::unicode:chardata()\&.
.br

.RE
.LP
.B
scale(This, Width, Height) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Width = integer()
.br
Height = integer()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBscale(This, Width, Height, [])\fR\&\&.
.RE
.LP
.B
scale(This, Width, Height, Option::[Option]) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Width = integer()
.br
Height = integer()
.br
Option = {quality, wx_enum() (see module wx)}
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Quality = integer
.RE
.LP
.B
size(This, Size, Pos) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Size = {W::integer(), H::integer()}
.br
Pos = {X::integer(), Y::integer()}
.br
.RE
.RE
.RS
.LP
Equivalent to \fBsize(This, Size, Pos, [])\fR\&\&.
.RE
.LP
.B
size(This, Size, Pos, Option::[Option]) -> wxImage()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Size = {W::integer(), H::integer()}
.br
Pos = {X::integer(), Y::integer()}
.br
Option = {r, integer()} | {g, integer()} | {b, integer()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setAlpha(This, Alpha) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Alpha = binary()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBsetAlpha(This, Alpha, [])\fR\&\&.
.RE
.LP
.B
setAlpha(This, Alpha, Option::[Option]) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Alpha = binary()
.br
Option = {static_data, boolean()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setAlpha(This, X, Y, Alpha) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
X = integer()
.br
Y = integer()
.br
Alpha = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setData(This, Data) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBsetData(This, Data, [])\fR\&\&.
.RE
.LP
.B
setData(This, Data, Option::[Option]) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Data = binary()
.br
Option = {static_data, boolean()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setData(This, Data, New_width, New_height) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Data = binary()
.br
New_width = integer()
.br
New_height = integer()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBsetData(This, Data, New_width, New_height, [])\fR\&\&.
.RE
.LP
.B
setData(This, Data, New_width, New_height, Option::[Option]) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Data = binary()
.br
New_width = integer()
.br
New_height = integer()
.br
Option = {static_data, boolean()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setMask(This) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
.RE
.RE
.RS
.LP
Equivalent to \fBsetMask(This, [])\fR\&\&.
.RE
.LP
.B
setMask(This, Option::[Option]) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Option = {mask, boolean()}
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setMaskColour(This, R, G, B) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
R = integer()
.br
G = integer()
.br
B = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setMaskFromImage(This, Mask, Mr, Mg, Mb) -> boolean()
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Mask = wxImage()
.br
Mr = integer()
.br
Mg = integer()
.br
Mb = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setOption(This, Name, Value) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Name = chardata() (see module unicode)
.br
Value = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&. 
.br
Also:
.br
setOption(This, Name, Value) -> ok when
.br
This::wxImage(), Name::unicode:chardata(), Value::unicode:chardata()\&.
.br

.RE
.LP
.B
setPalette(This, Palette) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Palette = wxPalette() (see module wxPalette)
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setRGB(This, Rect, R, G, B) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
Rect = {X::integer(), Y::integer(), W::integer(), H::integer()}
.br
R = integer()
.br
G = integer()
.br
B = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
setRGB(This, X, Y, R, G, B) -> ok
.br
.RS
.LP
Types:

.RS 3
This = wxImage()
.br
X = integer()
.br
Y = integer()
.br
R = integer()
.br
G = integer()
.br
B = integer()
.br
.RE
.RE
.RS
.LP
See external documentation\&.
.RE
.LP
.B
destroy(This::wxImage()) -> ok
.br
.RS
.LP
Destroys this object, do not use object again
.RE
.SH AUTHORS
.LP

.I
<>