{"stream":true,"model":"gpt-4o","messages":[{"role":"system","content":"You use markdown liberally to structure responses. Always show code snippets in markdown blocks with language labels."},{"role":"user","content":"Welcome to ChatGPT shell\n\n  Type help and press RET for details.\n\n  Like this package? Consider ✨sponsoring✨\n\n\n\nChatGPT> explain this code\n\n``` typescript-ts\nexport interface Workflow {\n  id: string;\n  type: string;\n  state: string; // TODO Ideally this would be a value of WorkflowState type\n  refType: string;\n  refId: string;\n  activityTypes: string[];\n  attempts: number;\n  executeAt: Date | null;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n```"},{"role":"assistant","content":"This TypeScript code defines an `interface` named `Workflow`. Interfaces in TypeScript are used to define the shape of an object, specifying what properties and types the object should have. Let's break down each property in the `Workflow` interface:\n\n- `id: string;`\n  - **Type:** `string`\n  - **Description:** A unique identifier for the workflow instance.\n\n- `type: string;`\n  - **Type:** `string`\n  - **Description:** The type/category of the workflow.\n\n- `state: string;`\n  - **Type:** `string`\n  - **Description:** The current state of the workflow. There is a TODO comment suggesting that this should ideally be a value of `WorkflowState` type, which implies a more specific type should be used here.\n\n- `refType: string;`\n  - **Type:** `string`\n  - **Description:** The type/category of the reference object related to this workflow.\n\n- `refId: string;`\n  - **Type:** `string`\n  - **Description:** A unique identifier for the reference object.\n\n- `activityTypes: string[];`\n  - **Type:** `string[]` (an array of strings)\n  - **Description:** A list of activity types associated with the workflow.\n\n- `attempts: number;`\n  - **Type:** `number`\n  - **Description:** The number of attempts made to complete the workflow.\n\n- `executeAt: Date | null;`\n  - **Type:** `Date | null`\n  - **Description:** The date and time when the workflow is scheduled to be executed. It can be `null` if not applicable.\n\n- `createdAt: Date;`\n  - **Type:** `Date`\n  - **Description:** The date and time when the workflow was created.\n\n- `updatedAt: Date;`\n  - **Type:** `Date`\n  - **Description:** The date and time when the workflow was last updated.\n\n### Example Usage\n\nHere is an example of an object adhering to this interface:\n\n```typescript\nconst sampleWorkflow: Workflow = {\n  id: \"workflow123\",\n  type: \"dataProcessing\",\n  state: \"pending\",\n  refType: \"job\",\n  refId: \"job456\",\n  activityTypes: [\"validation\", \"transformation\"],\n  attempts: 2,\n  executeAt: new Date(\"2023-12-01T10:00:00Z\"),\n  createdAt: new Date(\"2023-10-01T08:00:00Z\"),\n  updatedAt: new Date(\"2023-10-02T09:00:00Z\")\n};\n```\n\nIn this example, `sampleWorkflow` is an object that follows the `Workflow` interface structure."},{"role":"user","content":"Tell me more about the type field"},{"role":"assistant","content":"Sure! The `type` field in the `Workflow` interface is defined as a string:\n\n```typescript\ntype: string;\n```\n\n### Purpose\nThe `type` field is intended to categorize or specify the type of workflow. This could be useful for various reasons, such as:\n\n1. **Classification:** Different workflows might represent different sets of tasks or processes. For example, a `type` could be `\"dataProcessing\"`, `\"reportGeneration\"`, or `\"emailNotification\"`.\n2. **Behavior Control:** The `type` field might dictate how the workflow is processed within your application. Different types might have different logic or handling routines associated with them.\n3. **Filtering and Organization:** The `type` field can be used for filtering and organizing workflows within the system. For instance, you might want to query or list workflows of a specific type.\n\n### Example Usage\n\nHere's an example where the `type` field is used to distinguish between different kinds of workflows:\n\n```typescript\nconst dataProcessingWorkflow: Workflow = {\n  id: \"workflow123\",\n  type: \"dataProcessing\",\n  state: \"pending\",\n  refType: \"job\",\n  refId: \"job456\",\n  activityTypes: [\"validation\", \"transformation\"],\n  attempts: 2,\n  executeAt: new Date(\"2023-12-01T10:00:00Z\"),\n  createdAt: new Date(\"2023-10-01T08:00:00Z\"),\n  updatedAt: new Date(\"2023-10-02T09:00:00Z\")\n};\n\nconst emailNotificationWorkflow: Workflow = {\n  id: \"workflow124\",\n  type: \"emailNotification\",\n  state: \"pending\",\n  refType: \"job\",\n  refId: \"job789\",\n  activityTypes: [\"composeEmail\", \"sendEmail\"],\n  attempts: 1,\n  executeAt: new Date(\"2023-12-02T10:00:00Z\"),\n  createdAt: new Date(\"2023-10-01T08:00:00Z\"),\n  updatedAt: new Date(\"2023-10-02T09:00:00Z\")\n};\n```\n\n### Enhancing Type Safety\n\nTo enhance type safety, you could use a TypeScript `enum` or a union of string literals to represent the possible values for `type`. This approach reduces the risk of typos and helps with auto-completion and refactoring.\n\n#### Using `enum`:\n\n```typescript\nenum WorkflowType {\n  DataProcessing = \"dataProcessing\",\n  ReportGeneration = \"reportGeneration\",\n  EmailNotification = \"emailNotification\"\n}\n\nexport interface Workflow {\n  id: string;\n  type: WorkflowType;\n  state: string; // Ideally, this would be a value of WorkflowState type\n  refType: string;\n  refId: string;\n  activityTypes: string[];\n  attempts: number;\n  executeAt: Date | null;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nconst newWorkflow: Workflow = {\n  id: \"workflow125\",\n  type: WorkflowType.DataProcessing,\n  state: \"pending\",\n  refType: \"job\",\n  refId: \"job123\",\n  activityTypes: [\"validation\", \"transformation\"],\n  attempts: 3,\n  executeAt: new Date(\"2023-12-03T10:00:00Z\"),\n  createdAt: new Date(\"2023-10-01T08:00:00Z\"),\n  updatedAt: new Date(\"2023-10-02T09:00:00Z\")\n};\n```\n\n#### Using string literals:\n\n```typescript\ntype WorkflowType = \"dataProcessing\" | \"reportGeneration\" | \"emailNotification\";\n\nexport interface Workflow {\n  id: string;\n  type: WorkflowType;\n  state: string; // Ideally, this would be a value of WorkflowState type\n  refType: string;\n  refId: string;\n  activityTypes: string[];\n  attempts: number;\n  executeAt: Date | null;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nconst anotherWorkflow: Workflow = {\n  id: \"workflow126\",\n  type: \"reportGeneration\",\n  state: \"completed\",\n  refType: \"job\",\n  refId: \"job111\",\n  activityTypes: [\"dataCollection\", \"formatReport\"],\n  attempts: 1,\n  executeAt: new Date(\"2023-12-04T10:00:00Z\"),\n  createdAt: new Date(\"2023-10-01T08:00:00Z\"),\n  updatedAt: new Date(\"2023-10-02T09:00:00Z\")\n};\n```\n\nIn both cases, the use of `enum` or string literals helps to ensure that only predefined values can be assigned to the `type` field."},{"role":"user","content":"what are the top three things you'd change in this code to make it easier to read and maintain?\n\n``` typescript-ts\nimport { v5 as uuidv5 } from \"uuid\";\n\nexport interface WorkflowInput {\n  id: string;\n  type: string;\n  refType: string;\n  refId: string;\n  executeAt?: Date;\n}\n\nexport enum WorkflowState {\n  Queued = \"queued\",\n  Pending = \"pending\",\n  Running = \"running\",\n  RunningRetry = \"running_retry\",\n  RunningRollback = \"running_rollback\",\n  Failed = \"failed\",\n  FailedRollback = \"failed_rollback\",\n  Succeeded = \"succeeded\",\n}\n\nexport interface Workflow {\n  id: string;\n  type: string;\n  state: string; // TODO Ideally this would be a value of WorkflowState type\n  refType: string;\n  refId: string;\n  activityTypes: string[];\n  attempts: number;\n  executeAt: Date | null;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport enum ActivityState {\n  Pending = \"pending\",\n  Running = \"running\",\n  FailedPermanent = \"failed_permanent\",\n  FailedTemporary = \"failed_temporary\",\n  Succeeded = \"succeeded\",\n}\n\nexport interface Activity {\n  id: string;\n  type: string;\n  state: string; // TODO Ideally this would be a value of ActivityState type\n  workflowId: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Store {\n  getExecutableWorkflows(cutoff: Date, limit: number): Promise<Workflow[]>;\n  getLostWorkflows(limit: number): Promise<Workflow[]>;\n  createWorkflow(input: WorkflowInput): Promise<Workflow>;\n  setWorkflowState(workflow: Workflow, state: WorkflowState): Promise<void>;\n  updateWorkflow(workflow: Workflow): Promise<void>;\n  tryLockWorkflow(workflow: Workflow): Promise<boolean>;\n  lockWorkflow(workflow: Workflow): Promise<void>;\n  unlockWorkflow(workflow: Workflow): Promise<void>;\n  getActivityByType(\n    workflow: Workflow,\n    activityType: string,\n  ): Promise<Activity | undefined>;\n  createActivity(\n    workflow: Workflow,\n    id: string,\n    activityType: string,\n  ): Promise<Activity>;\n  updateActivity(activity: Activity): Promise<void>;\n}\n\nexport interface ExecutorPlugin {\n  type: string;\n}\n\nexport class PluginRegistry<T extends ExecutorPlugin> {\n  private plugins = new Map<string, T>();\n\n  register(plugin: T): void {\n    this.plugins.set(plugin.type, plugin);\n  }\n\n  lookup(type: string): T | undefined {\n    return this.plugins.get(type);\n  }\n}\n\nexport interface WorkflowPlugin {\n  type: string;\n  plan(workflow: Workflow): Promise<string[]>;\n}\n\nexport interface ActivityPlugin {\n  type: string;\n  execute(workflow: Workflow, activity: Activity): Promise<void>;\n  rollback(workflow: Workflow, activity: Activity): Promise<void>;\n}\n\nexport type ActivityCallback = (\n  workflow: Workflow,\n  activity: Activity,\n) => Promise<void>;\n\nfunction generateActivityId(workflowId: string, activityType: string): string {\n  // The hard-coded namespace UUID here must never be changed.\n  //\n  // Activity IDs are a v5 UUID based on the workflow ID, the activity type, and\n  // this namespace. This behavior ensures that generated activity IDs are\n  // stable, which in turn ensures that activity creation is idempotent.\n  return uuidv5(\n    `${workflowId}:${activityType}`,\n    \"5df6a4fe-1fe4-47b8-bf32-3bf599650a9f\",\n  );\n}\n\nclass ActivityExecutor {\n  constructor(\n    private store: Store,\n    private activities: PluginRegistry<ActivityPlugin>,\n  ) {\n    this.store = store;\n    this.activities = activities;\n  }\n\n  async create(workflow: Workflow, activityType: string): Promise<Activity> {\n    const activity = await this.store.getActivityByType(workflow, activityType);\n    if (!activity) {\n      const id = generateActivityId(workflow.id, activityType);\n      return await this.store.createActivity(workflow, id, activityType);\n    }\n    return activity;\n  }\n\n  async execute(workflow: Workflow, activity: Activity): Promise<void> {\n    await this.invoke(\"execute\", workflow, activity);\n  }\n\n  async rollback(workflow: Workflow, activity: Activity): Promise<void> {\n    await this.invoke(\"rollback\", workflow, activity);\n  }\n\n  private async invoke(\n    operation: \"execute\" | \"rollback\",\n    workflow: Workflow,\n    activity: Activity,\n  ): Promise<void> {\n    const plugin = this.activities.lookup(\n      activity.type.replace(\"rollback:\", \"\"),\n    );\n\n    if (!plugin) {\n      throw `unknown activity plugin: ${activity.type}`;\n    }\n\n    if (!this.isActivityTerminal(activity)) {\n      activity.state = ActivityState.Pending;\n      await this.store.updateActivity(activity);\n    }\n\n    const callback =\n      operation === \"execute\"\n        ? plugin.execute.bind(plugin)\n        : plugin.rollback.bind(plugin);\n    await this.converge(workflow, activity, callback);\n  }\n\n  private async converge(\n    workflow: Workflow,\n    activity: Activity,\n    callback: ActivityCallback,\n  ): Promise<void> {\n    switch (activity.state) {\n      case ActivityState.Pending:\n        await this.handlePending(workflow, activity);\n        await this.converge(workflow, activity, callback);\n        return;\n      case ActivityState.Running:\n        await this.handleRunning(workflow, activity, callback);\n        await this.converge(workflow, activity, callback);\n        return;\n    }\n  }\n\n  private async handlePending(_: Workflow, activity: Activity): Promise<void> {\n    activity.state = ActivityState.Running;\n    await this.store.updateActivity(activity);\n  }\n\n  private async handleRunning(\n    workflow: Workflow,\n    activity: Activity,\n    callback: ActivityCallback,\n  ): Promise<void> {\n    try {\n      await callback(workflow, activity);\n    } catch (error) {\n      activity.state = ActivityState.FailedTemporary;\n      if (error === ActivityState.FailedPermanent) {\n        activity.state = ActivityState.FailedPermanent;\n      }\n      await this.store.updateActivity(activity);\n      return;\n    }\n    activity.state = ActivityState.Succeeded;\n    await this.store.updateActivity(activity);\n  }\n\n  private isActivityTerminal(activity: Activity): boolean {\n    return (\n      activity.state === ActivityState.FailedPermanent ||\n      activity.state === ActivityState.Succeeded\n    );\n  }\n}\n\nexport class WorkflowExecutor {\n  private executor: ActivityExecutor;\n\n  constructor(\n    private store: Store,\n    private workflows: PluginRegistry<WorkflowPlugin>,\n    private activities: PluginRegistry<ActivityPlugin>,\n    private retryBackoffMilliseconds: number = 10 * 1000, // 10 seconds\n  ) {\n    this.activities = activities;\n    this.executor = new ActivityExecutor(store, activities);\n    this.workflows = workflows;\n    this.retryBackoffMilliseconds = retryBackoffMilliseconds;\n  }\n\n  async create(input: WorkflowInput): Promise<Workflow> {\n    return this.store.createWorkflow(input);\n  }\n\n  async execute(workflow: Workflow): Promise<void> {\n    await this.store.lockWorkflow(workflow);\n    try {\n      await this.converge(workflow);\n    } finally {\n      await this.store.unlockWorkflow(workflow);\n    }\n  }\n\n  private async converge(workflow: Workflow): Promise<void> {\n    switch (workflow.state) {\n      case WorkflowState.Queued:\n        throw \"unexpected workflow state\";\n      case WorkflowState.Pending:\n        await this.handlePending(workflow);\n        await this.converge(workflow);\n        return;\n      case WorkflowState.Running:\n        await this.handleRunning(workflow);\n        await this.converge(workflow);\n        return;\n      case WorkflowState.RunningRetry:\n        await this.handleRunningRetry(workflow);\n        return;\n      case WorkflowState.RunningRollback:\n        await this.handleRunningRollback(workflow);\n        await this.converge(workflow);\n        return;\n    }\n  }\n\n  private async handlePending(workflow: Workflow): Promise<void> {\n    if (workflow.activityTypes.length === 0) {\n      const plugin = this.workflows.lookup(workflow.type);\n      if (!plugin) {\n        throw `unknown workflow plugin: ${workflow.type}`;\n      }\n      const activityTypes = await plugin.plan(workflow);\n      if (activityTypes.length === 0) {\n        await this.store.setWorkflowState(workflow, WorkflowState.Failed);\n        return;\n      }\n      workflow.activityTypes = activityTypes;\n      await this.store.updateWorkflow(workflow);\n    }\n    await this.store.setWorkflowState(workflow, WorkflowState.Running);\n  }\n\n  private async handleRunning(workflow: Workflow): Promise<void> {\n    for (const activityType of workflow.activityTypes) {\n      const activity = await this.executor.create(workflow, activityType);\n      await this.executor.execute(workflow, activity);\n      switch (activity.state) {\n        case ActivityState.FailedPermanent:\n          await this.store.setWorkflowState(\n            workflow,\n            WorkflowState.RunningRollback,\n          );\n          return;\n        case ActivityState.FailedTemporary:\n          await this.store.setWorkflowState(\n            workflow,\n            WorkflowState.RunningRetry,\n          );\n          return;\n      }\n    }\n    await this.store.setWorkflowState(workflow, WorkflowState.Succeeded);\n  }\n\n  private async handleRunningRetry(workflow: Workflow): Promise<void> {\n    workflow.executeAt = new Date(\n      new Date().getTime() + this.retryBackoffMilliseconds,\n    );\n    await this.store.setWorkflowState(workflow, WorkflowState.Queued);\n    await this.store.updateWorkflow(workflow);\n  }\n\n  private async handleRunningRollback(workflow: Workflow): Promise<void> {\n    const reversedActivityTypes = [...workflow.activityTypes].reverse();\n    for (const activityType of reversedActivityTypes) {\n      const activity = await this.store.getActivityByType(\n        workflow,\n        activityType,\n      );\n      if (!activity) {\n        throw `missing activity ${activityType} for workflow ${workflow.type} (${workflow.id})`;\n      }\n      if (activity.state !== ActivityState.Succeeded) {\n        continue;\n      }\n\n      const rollbackActivityType = `rollback:${activityType}`;\n      const rollbackActivity = await this.executor.create(\n        workflow,\n        rollbackActivityType,\n      );\n      await this.executor.rollback(workflow, rollbackActivity);\n      switch (rollbackActivity.state) {\n        case ActivityState.FailedPermanent:\n          await this.store.setWorkflowState(\n            workflow,\n            WorkflowState.FailedRollback,\n          );\n          return;\n        case ActivityState.FailedTemporary:\n          await this.store.setWorkflowState(\n            workflow,\n            WorkflowState.RunningRetry,\n          );\n          return;\n      }\n    }\n    await this.store.setWorkflowState(workflow, WorkflowState.Failed);\n  }\n}\n\n```"}]}