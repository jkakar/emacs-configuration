* Bootstrapping and package management

** TODO

- Switch to railwaycats emacs to see if the vfork patch helps performance on macOS
- Learn more about ivy-occur
- Install wgrep and figure out how to use it with ivy-occur
- Checkout https://github.com/joaotavora/eglot

** Tangling

   There are [[https://www.reddit.com/r/emacs/comments/372nxd/][two main approaches]] to writing your emacs configuration in org. I'm
   choosing to run ~org-babel-load-file~ manually after editing this file. It's
   a bit tedious, but preferable to imposing startup delays.

** Customize

   I'd ideally like to never do anything that invokes Customize options, but
   this setup isn't there yet. I want to be able to clone this repository to
   =~/.emacs.d= and run ~org-babel-load-file~ to generate an ~init.el~ in place
   that is used to boot emacs from then on. At present, doing this generates
   custom options that are written to =~/.emacs=. The presence of that file then
   blocks emacs from using =~/.emacs.d/init.el= during startup.

   Declaring a file, just for Customize options, works around this.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (load custom-file)
   #+END_SRC

** Package management

   [[https://github.com/raxod502/straight.el][straight]] looks pretty nice, but I don't want to deviate too far from the
   mainstream when it comes to package management. I want to rely on [[http://melpa.milkbox.net][melpa]] and
   [[https://github.com/jwiegley/use-package][use-package]] as much as I can.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'package)
     (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
     (package-initialize)
     (setq package-enable-at-startup nil)

     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-when-compile
       (require 'use-package))

     (setq use-package-always-ensure t)
   #+END_SRC

** Persistent editing

   Run emacs as a server.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (server-start)
   #+END_SRC

   I put an executable script in =~/bin= to invoke emacs from a shell and have
   the single instance receive calls to it. I use [[https://emacsformacosx.com/][emacsformacosx]] so the script
   uses the ~emacsclient~ that comes with it.

   #+BEGIN_SRC bash
     #!/bin/sh

     /Applications/Emacs.app/Contents/MacOS/bin/emacsclient -n $@
   #+END_SRC

* Core UI

** Chrome

   I don't want distractions like the startup screen, the toolbar or scrollbars.
   I want the modeline to show line and column numbers. Don't waste my time
   asking me to type ~yes~ and ~no~ when ~y~ or ~n~ will suffice.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq inhibit-startup-screen t)
     (setq initial-scratch-message nil)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (setq line-number-mode 1)
     (setq column-number-mode 1)
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   I don't want a spurious Cmd-q to kill emacs on macOS.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq confirm-kill-emacs 'yes-or-no-p)
   #+END_SRC

   I never want to hear a single peep out of my editor.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq ring-bell-function #'ignore)
   #+END_SRC

** Theme

   I've tried several themes, mostly within the base16 family, and seem to keep
   coming back to ~base16-twilight~.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package base16-theme
       :init
       (load-theme 'base16-irblack t))
     (defun get-base16-color (id)
       (plist-get base16-irblack-colors id))
   #+END_SRC

** Fonts and faces

   I use ~set-face-attribute~ for global faces instead of ~custom-set-faces~
   because I want to avoid using the Customize interface, which would mutate my
   init file. It lets me twiddle any individual part of any face (see the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Face-Attributes.html][full
   list of attributes]]) without going through Customize. For package-specific
   faces, ~use-package~ offers the ~:custom-face~ keyword, which goes through
   Customize while avoiding its major downside.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (cond ((eq system-type 'gnu/linux)
            (set-face-attribute 'default nil :family "Input"
                                             :height 100))
           ((eq system-type 'darwin)
            (set-face-attribute 'default nil :family "Monaco"
                                             :height 160)))
     (set-face-attribute 'fixed-pitch nil :family 'unspecified
                                          :inherit 'default)
   #+END_SRC

** Environment

   [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] ensures that Emacs.app on macOS uses the same paths as
   my user environment.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package exec-path-from-shell
       :if (eq system-type 'darwin)
       :custom
       (exec-path-from-shell-check-startup-files nil)
       (exec-path-from-shell-variables '("PATH"
                                         "MANPATH"
                                         "GOPATH"))
       :config
       (exec-path-from-shell-initialize))
   #+END_SRC

** Files and buffers

   I never run more than one copy of emacs, nor do I ever make use of backup
   files. Don't keep junk lying around if it'll never be used.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq auto-save-default nil)
     (setq auto-save-list-file-prefix nil)
     (setq create-lockfiles nil)
     (setq make-backup-files nil)
   #+END_SRC

   Uniquify buffer names using a style that matches file paths as much as
   possible.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq uniquify-buffer-name-style 'forward)
   #+END_SRC

   I prefer ~ibuffer~ to the builtin buffer menu functionality.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (global-set-key (kbd "C-x C-b") 'ibuffer)
   #+END_SRC

   I like closing all buffers to reset emacs to a clean slate when I switch from
   one task to another. Using ~C-x C-b % n <ENTER> D~ is pretty tedious. ~M-x
   close-all-buffers~ is a touch easier.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun close-all-buffers ()
       (interactive)
       (mapc 'kill-buffer (buffer-list)))
   #+END_SRC

** Scrolling

   Scroll one line at a time. The default behaviour is jarring.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq scroll-conservatively 1)
   #+END_SRC

** Long lines and whitespace

   I prefer spaces to tabs and use a single space after a period. I also want
   code and text to fit within 80 characters whenever reasonable.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq sentence-end-double-space nil)
     (setq-default indent-tabs-mode nil)
     (setq-default fill-column 80)
     (setq default-tab-width 4)

   #+END_SRC

   Ideally, formatting would be taken care of by tooling that limits length
   whenever reasonable. [[https://nschum.de/src/emacs/highlight-80+/][highlight-80+-mode]] highlights lines that exceed 80
   characters. This provides a useful signal to think about whether the line
   should be broken up or not.

   The builtin [[http://git.savannah.gnu.org/cgit/emacs.git/tree/lisp/whitespace.el][whitespace-mode]] can do this now. It'd be good to switchover to it
   and drop this unmaintained package.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (load-library (expand-file-name "highlight-80+.el" user-emacs-directory))
     (setq highlight-80+-columns 81)
     (set-face-attribute 'highlight-80+ nil :foreground 'unspecified
                                            :background (get-base16-color ':base01))
   #+END_SRC

   I don't want to leave trailing whitespace in files. [[https://github.com/lewang/ws-butler][ws-butler only]] deletes
   tailing whitespace from edited lines, which helps keeps diffs clean.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default show-trailing-whitespace t)
     (use-package ws-butler
       :demand t
       :config
       (setq ws-butler-keep-whitespace-before-point nil)
       (ws-butler-global-mode 1))
   #+END_SRC

** Line movement

   The builtin ~move-beginning-of-line~ function jumps to the beginning of the
   line, but most of the time I want to move to the first non-whitespace
   character. ~crux-move-beginning-of-line~ moves to the first non-whitespace
   character on the line, or if the point is already there, to the beginning of
   the line. Invoking it repeatedly toggles between these positions.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package crux
      :ensure t
      :bind (("C-a" . crux-move-beginning-of-line)))
   #+END_SRC

** Joining lines

   Using ~C-u M-^~ to join one line to another is really tedious. Let's make
   this easier.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun join-next-line ()
       (interactive)
       (join-line t))
     (global-set-key (kbd "C-j") 'join-next-line)
   #+END_SRC

** Matching parentheses

   Highlight all the text between matching parentheses without any delay.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (set-face-attribute 'show-paren-match nil :foreground 'unspecified
                                               :background (get-base16-color ':base01))
     (setq show-paren-delay 0)
     (setq show-paren-style (quote expression))
     (show-paren-mode 1)
   #+END_SRC

** Navigation

   Ivy, counsel and swiper provide a simple and unified way to quickly navigate
   buffers, find files, etc.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package swiper
       :ensure t
       :config
       (global-set-key (kbd "C-s") 'swiper))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel
       :ensure t
       :config
       (global-set-key (kbd "M-x") 'counsel-M-x)
       (global-set-key (kbd "C-x C-f") 'counsel-find-file)
       (global-set-key (kbd "C-c k") 'counsel-rg)
       (define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history))
       (setq counsel-git-cmd "rg --files")
       (setq counsel-rg-base-command "rg -i -M 120 --no-heading --line-number --color never %s .")
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ivy
       :ensure t
       :init (setq ivy-use-virtual-buffers t
                   ivy-count-format "(%d/%d) ")
       :bind (("C-c C-r" . ivy-resume)
              :map ivy-minibuffer-map ("RET" . ivy-alt-done))
       :config
       (global-set-key (kbd "C-c C-r") 'ivy-resume))
       (setq ivy-height 15)
       (ivy-mode 1)
   #+END_SRC

   I want ~counsel-M-x~ to show me the most recently used commands. Installing
   [[https://github.com/nonsequitur/smex][smex]] makes this the default behaviour.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package smex)
   #+END_SRC

   I mainly use projectile for fuzzy searching an entire project’s files and
   buffers. It’s quite refreshing to never think about which files are “open”
   and which ones aren’t. The concept of a “root” directory is also important
   for things like rg searching.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package projectile
       :custom
       (projectile-globally-ignored-file-suffixes '(".pdf"))
       (projectile-globally-unignored-files '(".projectile" ".dir-locals.el"))
       :demand t
       :config
       (setq projectile-enable-caching t)
       (setq projectile-indexing-method 'alien)
       (projectile-mode 1))
   #+END_SRC

   I want to be able to jump to any file quickly without having to navigate
   through directories by hand. [[https://github.com/ericdanan/counsel-projectile][counsel-projectile]] provides a nice way to do
   this.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel-projectile
      :demand t
      :config
      (counsel-projectile-mode 1))
   #+END_SRC

** Git

   [[https://magit.vc/][Magit]] provides a great interface for working with git.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package magit
       :config
       (setq magit-completing-read-function 'ivy-completing-read)
       (global-set-key (kbd "C-x g") 'magit-status))
   #+END_SRC

   I frequently want to share a GitHub link to code I'm working with in emacs.
   Navigating to files and selecting lines in the browser is rather tedious.
   [[https://github.com/sshaw/git-link][git-link]] provides a way to quickly generate GitHub (and other code hosting
   service) URLs.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package git-link
       :config
       (global-set-key (kbd "C-c g l") 'git-link)
       (add-to-list 'git-link-remote-alist
                    '("git\\.corp\\.stripe\\.com" git-link-github))
       (add-to-list 'git-link-commit-remote-alist
                    '("git\\.corp\\.stripe\\.com" git-link-commit-github)))
   #+END_SRC

** Jump to definition

   [[https://github.com/jacktasia/dumb-jump][dump-jump]] uses brute force very effectively. It provides decent jump to
   definition behaviour while avoiding the tedium that comes with managing TAGS
   files and such. I've found ~rg~ provides the best results.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package dumb-jump
       :bind (("M-g o" . dumb-jump-go-other-window)
              ("M-g j" . dumb-jump-go)
              ("M-g i" . dumb-jump-go-prompt)
              ("M-g x" . dumb-jump-go-prefer-external)
              ("M-g z" . dumb-jump-go-prefer-external-other-window))
       :config (setq dumb-jump-force-searcher 'rg)
               (setq dumb-jump-max-find-time 5)
               (setq dumb-jump-selector 'ivy)
       :ensure)
   #+END_SRC

** Multi-line editing

   [[https://melpa.org/#/wgrep][wgrep]] integrates with ivy-occur to provide multi-line editing capabilities.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package wgrep)
  #+END_SRC

  Search for text you want to edit, hit C-o C-o (ivy-occur) to open the matches
  in a buffer. Use C-x C-q (ivy-wgrep-change-to-wgrep-mode) in the buffer to
  switch into editing mode. Finally, use C-c C-c (wgrep-finish-edit) to apply
  the changes.

** TODO Spellcheck

* Stripe

** Running tests

   Run tests right from a buffer.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-git-relative-path ()
       (concat (magit-rev-parse "--show-prefix") "/"
         (file-name-nondirectory (buffer-file-name (current-buffer)))))

     (defun pay-test-this-file ()
       (interactive)
       (compile (concat "pay test " (my-git-relative-path))))

     (defun pay-test-at-point ()
       (interactive)
       (compile (concat "pay test " (my-git-relative-path)
                        " -l " (int-to-string (line-number-at-pos)))))
   #+END_SRC

* Major modes and filetypes

** Elixir

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package elixir-mode
       :commands elixir-mode
       :config
       (add-hook 'elixir-mode-hook 'highlight-80+-mode))
   #+END_SRC

** Erlang

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package erlang
       :init
       (add-to-list 'auto-mode-alist '("\\.P\\'" . erlang-mode))
       (add-to-list 'auto-mode-alist '("\\.E\\'" . erlang-mode))
       (add-to-list 'auto-mode-alist '("\\.S\\'" . erlang-mode))
       :config
       (add-hook 'erlang-mode-hook 'highlight-80+-mode)
       (add-hook 'erlang-mode-hook
         (lambda ()
           (setq mode-name "erl"
                 erlang-compile-extra-opts '((i . "../include"))
                 erlang-root-dir "/usr/local/lib/erlang"))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package edts
       :init
       (setq edts-inhibit-package-check t
             edts-man-root "~/.emacs.d/edts/doc/18.2.1"))
   #+END_SRC

** Flycheck

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package flycheck
       :init
       (setq flycheck-ruby-rubocop-executable (expand-file-name "~/stripe/pay-server/scripts/bin/rubocop"))
       (setq flycheck-ruby-executable (expand-file-name "~/.rbenv/shims/ruby"))
       (setq flycheck-erlang-include-path '("../include"))
       (setq flycheck-erlang-library-path '())
       :config
       (setq-default flycheck-disabled-checkers
                     (append flycheck-disabled-checkers
                             '(javascript-jshint)
                             '(ruby-rubylint)
                             '(json-jsonlist)))
       (global-flycheck-mode))
   #+END_SRC

** [[https://github.com/dominikh/go-mode.el][Go]]

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package go-mode
       :config
       (setq gofmt-command "goimports")
       :custom
       (gofmt-show-errors nil)
       :hook
       (go-mode . (lambda () (add-hook 'before-save-hook 'gofmt-before-save nil t)))
       :init
       (add-hook 'go-mode-hook 'highlight-80+-mode)
       :defer t)
   #+END_SRC

   We don't want to add ~gofmt-before-save~ to the global ~before-save-hook~,
   because that would cause ~go-mode~ to be loaded in every buffer, whether it
   was a Go buffer or not. Instead we add to the local ~before-save-hook~. We
   then have to explicitly request deferred loading. Normally ~:hook~ implies
   ~:defer t~, but [[https://github.com/jwiegley/use-package/commit/b0e53b4][only]] if the target of the hook is a function symbol. If it's
   a lambda, then ~use-package~ will resort to its default behavior of demanding
   the package, to ensure that the package is loaded when the lambda runs. In
   our case, we know the lambda doesn't need that, so we can safely ask for
   deferral.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package go-eldoc
       :hook (go-mode . go-eldoc-setup))
   #+END_SRC

** Graphviz

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package graphviz-dot-mode)
   #+END_SRC

** JSON

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package json-mode)
   #+END_SRC

** [[https://jblevins.org/projects/markdown-mode/][Markdown]]

   ~C-c C-l~ is the keyboard shortcut for ~markdown-insert-link~ which is needed
   to edit URLs because ~markdown-hide-urls~ is enabled.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package markdown-mode
       :custom
       (markdown-hide-urls t)
       :init
       (add-hook 'markdown-mode-hook 'highlight-80+-mode))
   #+END_SRC

** Prettier Javascript

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package prettier-js
       :init
       (add-hook 'web-mode-hook #'(lambda () (enable-minor-mode '("\\.jsx?\\'" . prettier-js-mode)))))
   #+END_SRC

** Protocol buffers

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package protobuf-mode
       :init
       (defconst my-protobuf-style '((c-basic-offset . 2) (indent-tabs-mode . nil)))
       (add-hook 'protobuf-mode-hook (lambda () (c-add-style "my-style" my-protobuf-style t))))
   #+END_SRC

** Python

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package python-mode
       :init
       (add-hook 'python-mode-hook 'highlight-80+-mode))
   #+END_SRC

** Ruby

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ruby-mode
       :init
       (add-to-list 'auto-mode-alist '("\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|rbi\\|ru\\|thor\\)\\'" . ruby-mode))
       (add-hook 'ruby-mode-hook 'highlight-80+-mode)
       :config
       (setq ruby-insert-encoding-magic-comment nil))
   #+END_SRC

** [[https://github.com/rust-lang/rust-mode][Rust]]

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package rust-mode
       :custom
       (rust-format-on-save t)
       :defer t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package flycheck-rust
       :hook (rust-mode . flycheck-rust-setup))
   #+END_SRC

** Thrift

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package thrift)
   #+END_SRC

** Web

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package web-mode
       :config
       (setq web-mode-markup-indent-offset 2)
       (setq web-mode-attr-indent-offset 2)
       (setq web-mode-css-indent-offset 2)
       (setq web-mode-code-indent-offset 2)
       (setq web-mode-enable-auto-pairing t)
       (setq web-mode-enable-css-colorization t)
       (add-hook 'before-save-hook 'delete-trailing-whitespace nil 'local)
       :mode ("\\.html?\\'" "\\.erb\\'" "\\.hbs\\'"
              "\\.jsx?\\'" "\\.json\\'" "\\.s?css\\'"
              "\\.less\\'" "\\.sass\\'"))
   #+END_SRC

** YAML

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package yaml-mode
       :config
       (add-hook 'yaml-mode-hook 'highlight-80+-mode))
   #+END_SRC
