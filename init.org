* Bootstrapping and package management

** TODO

- Checkout https://github.com/gregsexton/origami.el
- Checkout https://github.com/alphapapa/bufler.el
- Checkout https://www.reddit.com/r/emacs/comments/bb3nw7/connecting_workflows_with_aws_redshift/
- Checkout https://xenodium.com/a-chatgpt-emacs-shell/
- Spellchecking

** Tangling

   There are [[https://www.reddit.com/r/emacs/comments/372nxd/][two main approaches]] to writing your emacs configuration in org. I'm
   choosing to run ~org-babel-load-file~ manually after editing this file. It's
   a bit tedious, but preferable to imposing startup delays.

** Customize

   I'd ideally like to never do anything that invokes Customize options, but
   this setup isn't there yet. I want to be able to clone this repository to
   =~/.emacs.d= and run ~org-babel-load-file~ to generate an ~init.el~ in place
   that is used to boot emacs from then on. At present, doing this generates
   custom options that are written to =~/.emacs=. The presence of that file then
   blocks emacs from using =~/.emacs.d/init.el= during startup.

   Declaring a file, just for Customize options, works around this.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (load custom-file)
   #+END_SRC

** Package management

   I use [[https://github.com/raxod502/straight.el][straight]] and [[https://github.com/jwiegley/use-package][use-package]] to manage packages.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq load-prefer-newer t)
     (setq straight-repository-branch "master")
     (setq straight-check-for-modifications '(find-when-checking))
     (setq straight-use-package-by-default t)
     (setq straight-cache-autoloads t)
     (setq use-package-inject-hooks t)

     (let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
       (bootstrap-version 5))
     (unless (file-exists-p bootstrap-file)
       (with-current-buffer
           (url-retrieve-synchronously
            "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
            'silent 'inhibit-cookies)
         (goto-char (point-max))
         (eval-print-last-sexp)))
     (load bootstrap-file nil 'nomessage))

     (straight-use-package 'use-package)
   #+END_SRC

** Performance

   Increase GC threshold and process output buffer size for better runtime
   performance, especially with LSP.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq gc-cons-threshold (* 100 1024 1024))
     (setq read-process-output-max (* 4 1024 1024))
   #+END_SRC

   Run ~M-x straight-pull-all~ to update all packages, and then run ~M-x
   straight-freeze-versions~ to save the currently checked out revisions of all
   packages. The ~~/.emacs.d/straight/versions/default.el~ file, together with
   this file, define the package configuration.

** Persistent editing

   Run emacs as a server.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (server-start)
   #+END_SRC

   I put an executable script in =~/bin= to invoke emacs from a shell and have
   the single instance receive calls to it. I use the [[d12frosted/emacs-plus][d12frosted/emacs-plus]] and
   ~emacsclient~ packages.

   #+BEGIN_SRC bash
     #!/bin/sh

     /opt/homebrew/bin/emacsclient -n $@
   #+END_SRC

** Code formatting

   Reformatter runs command-line formatters to automatically format code in a
   buffer.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (straight-use-package 'reformatter)
   #+END_SRC

* Core UI

** Chrome

   I don't want distractions like the startup screen, the toolbar or scrollbars.
   I want the modeline to show line and column numbers. Don't waste my time
   asking me to type ~yes~ and ~no~ when ~y~ or ~n~ will suffice.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq inhibit-startup-screen t)
     (setq initial-scratch-message nil)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (setq line-number-mode 1)
     (setq column-number-mode 1)
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   I don't want a spurious Cmd-q to kill emacs on macOS.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq confirm-kill-emacs 'yes-or-no-p)
   #+END_SRC

   I never want to hear a single peep out of my editor.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq ring-bell-function #'ignore)
   #+END_SRC

** Theme

   Modus Vivendi is a dark theme with excellent contrast and readability,
   built into Emacs 28+.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package modus-themes
       :straight (:type built-in)
       :init
       (load-theme 'modus-vivendi t))
     (defun get-modus-color (name)
       "Get a color from modus-vivendi theme."
       (modus-themes-get-color-value name))
   #+END_SRC

** Fonts and faces

   I use ~set-face-attribute~ for global faces instead of ~custom-set-faces~
   because I want to avoid using the Customize interface, which would mutate my
   init file. It lets me twiddle any individual part of any face (see the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Face-Attributes.html][full
   list of attributes]]) without going through Customize. For package-specific
   faces, ~use-package~ offers the ~:custom-face~ keyword, which goes through
   Customize while avoiding its major downside.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (cond ((eq system-type 'gnu/linux)
            (set-face-attribute 'default nil :family "Input"
                                             :height 100))
           ;; ((eq system-type 'darwin)
           ;;  (set-face-attribute 'default nil :family "Monaco"
           ;;                                   :height 160)))
           ((eq system-type 'darwin)
            (set-face-attribute 'default nil :family "Source Code Pro"
                                             :height 180)))
     (set-face-attribute 'fixed-pitch nil :family 'unspecified
                                          :inherit 'default)
   #+END_SRC

** Environment

   [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] ensures that Emacs.app on macOS uses the same paths as
   my shell environment.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package exec-path-from-shell
       :if (eq system-type 'darwin)
       :custom
       (exec-path-from-shell-check-startup-files nil)
       (exec-path-from-shell-variables '("PATH"
                                         "MANPATH"
                                         "GOPATH"
                                         "GOPRIVATE"
                                         "OPENAI_API_KEY"
                                         "ANTHROPIC_API_KEY"))
       :config
       (exec-path-from-shell-initialize))
   #+END_SRC

** Clipboard

   I want emacs to fit in naturally with the rest of my environment and give me
   access to functionality I don't otherwise have. Saving clipboard contents to
   the kill ring provides access to data that is otherwise easily lost.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq save-interprogram-paste-before-kill t)
   #+END_SRC

** Files and buffers

   I never run more than one copy of emacs, nor do I ever make use of backup
   files. Don't keep junk lying around if it'll never be used.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq auto-save-default nil)
     (setq auto-save-list-file-prefix nil)
     (setq create-lockfiles nil)
     (setq make-backup-files nil)
   #+END_SRC

   Uniquify buffer names using a style that matches file paths as much as
   possible.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq uniquify-buffer-name-style 'forward)
   #+END_SRC

   I prefer ~ibuffer~ to the builtin buffer menu functionality.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (global-set-key (kbd "C-x C-b") 'ibuffer)
   #+END_SRC

   I like closing all buffers to reset emacs to a clean slate when I switch from
   one task to another. Using ~C-x C-b % n <ENTER> D~ is pretty tedious. ~M-x
   close-all-buffers~ is a touch easier.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun close-all-buffers ()
       (interactive)
       (dolist (buffer (buffer-list))
         (unless (member (buffer-name buffer) '("*scratch*" "*Messages*" " *Minibuf-0*" " *Minibuf-1*"))
           (kill-buffer buffer))))
   #+END_SRC

   Show the full path to the file in the current buffer in the window title.

   #+BEGIN_SRC emacs-lisp :tangle yes
    (setq frame-title-format
      (list '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))
   #+END_SRC

   Automatically revert buffers when the underlying file changes on disk.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (global-auto-revert-mode t)
     (setq auto-revert-use-notify t)
   #+END_SRC

** Scrolling

   Scroll one line at a time. The default behaviour is jarring.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq scroll-conservatively 1)
   #+END_SRC

** Line numbers

   Show line numbers to make it easier to pair with others.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (global-display-line-numbers-mode t)
     (setq display-line-numbers-width 3)
   #+END_SRC

** Long lines and whitespace

   I prefer spaces to tabs and use a single space after a period. I also want
   code and text to fit within 80 characters whenever reasonable.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq sentence-end-double-space nil)
     (setq-default indent-tabs-mode nil)
     (setq-default fill-column 80)
     (setq default-tab-width 4)
     (setq tab-width 4)
   #+END_SRC

   Ideally, formatting would be taken care of by tooling that limits length
   whenever reasonable. [[https://nschum.de/src/emacs/highlight-80+/][highlight-80+-mode]] highlights lines that exceed 80
   characters. This provides a useful signal to think about whether the line
   should be broken up or not.

   The builtin [[http://git.savannah.gnu.org/cgit/emacs.git/tree/lisp/whitespace.el][whitespace-mode]] can do this now. It'd be good to switchover to it
   and drop this unmaintained package.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package highlight-80+
       :straight (highlight-80+ :type git :host github :repo "jkakar/highlight-80-mode")
       :hook ((prog-mode . highlight-80+-mode)
              (markdown-mode . highlight-80+-mode)
              (yaml-mode . highlight-80+-mode))
       :config
       (setq highlight-80+-columns 81)
       (set-face-attribute 'highlight-80+ nil :foreground 'unspecified
                                              :background (get-modus-color 'bg-dim)))
   #+END_SRC

   I don't want to leave trailing whitespace in files. [[https://github.com/lewang/ws-butler][ws-butler only]] deletes
   tailing whitespace from edited lines, which helps keeps diffs clean.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default show-trailing-whitespace t)
     (add-hook 'minibuffer-setup-hook
               (lambda () (setq-local show-trailing-whitespace nil)))
     (use-package ws-butler
       :demand t
       :config
       (setq ws-butler-keep-whitespace-before-point nil)
       (ws-butler-global-mode 1))
   #+END_SRC

** Line movement

   The builtin ~move-beginning-of-line~ function jumps to the beginning of the
   line, but most of the time I want to move to the first non-whitespace
   character. ~crux-move-beginning-of-line~ moves to the first non-whitespace
   character on the line, or if the point is already there, to the beginning of
   the line. Invoking it repeatedly toggles between these positions.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package crux
      :bind (("C-a" . crux-move-beginning-of-line)))
   #+END_SRC

** Joining lines

   Using ~C-u M-^~ to join one line to another is really tedious. Let's make
   this easier.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun join-next-line ()
       (interactive)
       (join-line t))
     (global-set-key (kbd "C-j") 'join-next-line)
   #+END_SRC

** Matching parentheses

   Highlight all the text between matching parentheses without any delay.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (set-face-attribute 'show-paren-match nil :foreground 'unspecified
                                               :background (get-modus-color 'bg-paren-match))
     (setq show-paren-delay 0)
     (setq show-paren-style (quote expression))
     (show-paren-mode 1)
   #+END_SRC

** Navigation

   The Vertico stack provides a modern, modular completion system that uses
   native Emacs completion APIs.

   [[https://github.com/minad/vertico][Vertico]] provides a vertical completion UI.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package vertico
       :init
       (vertico-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package vertico-directory
       :after vertico
       :straight (:type built-in)
       :bind (:map vertico-map
              ("RET" . vertico-directory-enter)
              ("DEL" . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
       :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
   #+END_SRC

   [[https://github.com/emacs-straight/savehist][Savehist]] persists minibuffer history across sessions, so frequently used
   commands appear first in M-x.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package savehist
       :straight (:type built-in)
       :init
       (savehist-mode))
   #+END_SRC

   [[https://github.com/oantolin/orderless][Orderless]] provides flexible completion matching with space-separated patterns.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package orderless
       :custom
       (completion-styles '(orderless basic))
       (completion-category-overrides '((file (styles partial-completion)))))
   #+END_SRC

   [[https://github.com/minad/marginalia][Marginalia]] adds rich annotations to minibuffer completions.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package marginalia
       :init
       (marginalia-mode))
   #+END_SRC

   [[https://github.com/minad/consult][Consult]] provides enhanced search and navigation commands.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package consult
       :bind (("C-s" . consult-line)
              ("C-c f" . consult-find)
              ("C-c k" . consult-ripgrep)
              ("C-x b" . consult-buffer))
       :config
       (setq consult-ripgrep-args
             "rg --null --line-buffered --color=never --max-columns=1000 --path-separator / --smart-case --no-heading --with-filename --line-number --search-zip"))
   #+END_SRC

   [[https://github.com/oantolin/embark][Embark]] provides context actions on minibuffer candidates and other targets.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package embark
       :bind (("C-." . embark-act)
              ("C-;" . embark-dwim))
       :init
       (setq prefix-help-command #'embark-prefix-help-command))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package embark-consult
       :after (embark consult)
       :hook (embark-collect-mode . consult-preview-at-point-mode))
   #+END_SRC

   I mainly use projectile for fuzzy searching an entire project's files and
   buffers. It's quite refreshing to never think about which files are open and
   which ones aren't. The concept of a root directory is also important for
   things like ~rg~ searching.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package projectile
       :custom
       (projectile-globally-ignored-file-suffixes '(".pdf"))
       (projectile-globally-unignored-files '(".projectile" ".dir-locals.el"))
       :demand t
       :config
       (setq projectile-enable-caching t)
       (setq projectile-indexing-method 'alien)
       (projectile-mode 1))
   #+END_SRC

** Git

   I frequently want to share a GitHub link to code I'm working with in emacs.
   Navigating to files and selecting lines in the browser is rather tedious.
   [[https://github.com/sshaw/git-link][git-link]] provides a way to quickly generate GitHub (and other code hosting
   service) URLs.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package git-link
       :config
       (global-set-key (kbd "C-c g l") 'git-link))
   #+END_SRC

** Jump to definition

   [[https://github.com/jacktasia/dumb-jump][dump-jump]] uses brute force very effectively. It provides decent jump to
   definition behaviour while avoiding the tedium that comes with managing TAGS
   files and such. I've found ~rg~ provides the best results.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package dumb-jump
       :bind (("M-g o" . dumb-jump-go-other-window)
              ("M-g j" . dumb-jump-go)
              ("M-g i" . dumb-jump-go-prompt)
              ("M-g x" . dumb-jump-go-prefer-external)
              ("M-g z" . dumb-jump-go-prefer-external-other-window))
       :config (setq dumb-jump-force-searcher 'rg)
               (setq dumb-jump-max-find-time 10))
   #+END_SRC

** Multi-line editing

   [[https://melpa.org/#/wgrep][wgrep]] provides multi-line editing capabilities for grep-style buffers.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package wgrep)
  #+END_SRC

  Search for text with ~C-c k~ (consult-ripgrep), then use ~C-.~ (embark-act)
  followed by ~E~ (embark-export) to open matches in a grep buffer. Use ~C-c
  C-p~ (wgrep-change-to-wgrep-mode) to switch into editing mode. Finally, use
  ~C-c C-c~ (wgrep-finish-edit) to apply the changes.

** Compilation buffers

   Enable ANSI colors in compilation buffers.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun colorize-compilation-buffer ()
       (let ((inhibit-read-only t))
         (ansi-color-apply-on-region compilation-filter-start (point))))

     (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
   #+END_SRC

** Eglot

   Eglot is a lightweight LSP client built into Emacs 29+. It uses native Emacs
   facilities like flymake for diagnostics and eldoc for documentation.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package eglot
       :straight (:type built-in)
       :config
       (setq eglot-autoshutdown t)
       (setq eglot-events-buffer-size 0)
       :bind (:map eglot-mode-map
              ("C-c h" . eldoc)
              ("C-c r" . eglot-rename)
              ("C-c a" . eglot-code-actions)))
   #+END_SRC

** Corfu

   Corfu provides in-buffer completion popups. It's lightweight and integrates
   well with eglot and native Emacs completion.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package corfu
       :custom
       (corfu-auto t)
       (corfu-auto-delay 0.2)
       (corfu-auto-prefix 2)
       (corfu-cycle t)
       :init
       (global-corfu-mode))
   #+END_SRC

** GPTel

   The GPTel package provides commands for interacting with LLMs to respond to
   prompts, explain snippets, generate tests, and more.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package gptel)
     (global-set-key (kbd "C-c RET") 'gptel-send)
   #+END_SRC

* Major modes and filetypes

** Dockerfile

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package dockerfile-mode)
   #+END_SRC

** Elixir

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package elixir-mode
       :commands elixir-mode)
   #+END_SRC

** Erlang

   #+BEGIN_SRC emacs-lisp :tangle yes
     (reformatter-define erlfmt
       :program "/Users/jkakar/bin/erlfmt"
       :args '("-"))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package erlang
       :init
       (add-to-list 'auto-mode-alist '("\\.P\\'" . erlang-mode))
       (add-to-list 'auto-mode-alist '("\\.E\\'" . erlang-mode))
       (add-to-list 'auto-mode-alist '("\\.S\\'" . erlang-mode))
       :config
       (add-hook 'erlang-mode-hook
         (lambda ()
           (setq mode-name "erl"
                 erlang-compile-extra-opts '((i . "../include"))
                 erlang-root-dir "/usr/local/lib/erlang")))
       (add-hook 'erlang-mode-hook #'eglot-ensure)
       ;; TODO Figure out how to turn this off for *.yrl files.
       (add-hook 'erlang-mode-hook 'erlfmt-on-save-mode))
   #+END_SRC

** [[https://github.com/dominikh/go-mode.el][Go]]

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package go-mode
       :defer t)
     (use-package go-ts-mode
       :custom
       (gofmt-show-errors nil)
       :hook
       (go-ts-mode . (lambda ()
                       (setq tab-width 4)
                       (setq go-ts-mode-indent-offset tab-width)
                       (setq indent-tabs-mode t)
                       (add-hook 'before-save-hook 'gofmt-before-save nil t)))
       (go-ts-mode . eglot-ensure)
       :config
       (setq gofmt-command "goimports")
       :defer t)
   #+END_SRC

   We install ~go-mode~ because it defines the ~gofmt-before-save~ hook. We
   don't want to add ~gofmt-before-save~ to the global ~before-save-hook~,
   because that would cause ~go-mode~ to be loaded in every buffer, whether it
   was a Go buffer or not. Instead we add to the local ~before-save-hook~. We
   then have to explicitly request deferred loading. Normally ~:hook~ implies
   ~:defer t~, but [[https://github.com/jwiegley/use-package/commit/b0e53b4][only]] if the target of the hook is a function symbol. If it's
   a lambda, then ~use-package~ will resort to its default behavior of demanding
   the package, to ensure that the package is loaded when the lambda runs. In
   our case, we know the lambda doesn't need that, so we can safely ask for
   deferral.

** Graphviz

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package graphviz-dot-mode
       :init
       (add-hook 'graphviz-dot-mode-hook (lambda () (setq tab-width 4))))
   #+END_SRC

** Javascript and Typescript

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun biome-format-and-save ()
       "Format the current file with Biome and refresh the buffer."
       (interactive)
       (let ((current-file (buffer-file-name)))
         (when current-file
           (let ((exit-code (call-process "/opt/homebrew/bin/biome" nil nil nil "check" "--write" current-file)))
             (if (eq exit-code 0)
                 (progn
                   (message "Formatting successful, reverting buffer.")
                   (revert-buffer t t t))
               (message "Error formatting file with Biome."))))))

     (defun setup-js-ts-modes ()
       (add-hook 'after-save-hook 'biome-format-and-save nil t))

     ;; Apply this setup for js, ts, jsx, and tsx files
     (add-hook 'js-ts-mode-hook 'setup-js-ts-modes)
     (add-hook 'tsx-ts-mode-hook 'setup-js-ts-modes)
     (add-hook 'typescript-ts-mode-hook 'setup-js-ts-modes)
     (add-hook 'js-mode-hook 'setup-js-ts-modes)  ;; Assuming js-mode for JavaScript
     (add-hook 'js-ts-mode-hook (lambda () (setq js-indent-level 2)))
     (add-hook 'js-ts-mode-hook #'eglot-ensure)
     (add-hook 'tsx-ts-mode-hook (lambda ()
                                   (setq typescript-ts-mode-indent-offset 2)
                                   (setq indent-tabs-mode nil)))
     (add-hook 'tsx-ts-mode-hook #'eglot-ensure)
     (add-hook 'typescript-ts-mode-hook (lambda ()
                                          (setq typescript-ts-mode-indent-offset 2)
                                          (setq indent-tabs-mode nil)))
     (add-hook 'typescript-ts-mode-hook #'eglot-ensure)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package treesit-auto
       :custom
       (treesit-auto-install 'prompt)
       :config
       (treesit-auto-add-to-auto-mode-alist 'all)
       (global-treesit-auto-mode))

     ;; this fixes a problem where v0.20.4 of this grammar blows up with emacs
     (defvar jkakar/tsx-treesit-auto-recipe
       (make-treesit-auto-recipe
        :lang 'tsx
        :ts-mode 'tsx-ts-mode
        :remap '(typescript-tsx-mode)
        :requires 'typescript
        :url "https://github.com/tree-sitter/tree-sitter-typescript"
        :revision "v0.20.3"
        :source-dir "tsx/src"
        :ext "\\.tsx\\'")
       "Recipe for libtree-sitter-tsx.dylib")
     (add-to-list 'treesit-auto-recipe-list jkakar/tsx-treesit-auto-recipe)

     (defvar jkakar/typescript-treesit-auto-recipe
       (make-treesit-auto-recipe
        :lang 'typescript
        :ts-mode 'typescript-ts-mode
        :remap 'typescript-mode
        :requires 'tsx
        :url "https://github.com/tree-sitter/tree-sitter-typescript"
        :revision "v0.20.3"
        :source-dir "typescript/src"
        :ext "\\.ts\\'")
       "Recipe for libtree-sitter-typescript.dylib")
     (add-to-list 'treesit-auto-recipe-list jkakar/typescript-treesit-auto-recipe)

     (use-package typescript-ts-mode
       :mode
       (("\\.ts\\'" . typescript-ts-mode)
        ("\\.mts\\'" . typescript-ts-mode)
         ("\\.tsx\\'" . tsx-ts-mode)))
  #+END_SRC

** [[https://jblevins.org/projects/markdown-mode/][Markdown]]

   ~C-c C-l~ is the keyboard shortcut for ~markdown-insert-link~ which is needed
   to edit URLs because ~markdown-hide-urls~ is enabled.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package markdown-mode
       :custom
       (markdown-hide-urls t))
   #+END_SRC

** Protocol buffers

   #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package protobuf-mode
        :init
        (defconst my-protobuf-style '((c-basic-offset . 2) (indent-tabs-mode . nil)))
        (add-hook 'protobuf-mode-hook (lambda () (c-add-style "my-style" my-protobuf-style t))))
   #+END_SRC

** Ruby

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ruby-mode
       :init
       (add-to-list 'auto-mode-alist '("\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|rbi\\|ru\\|thor\\)\\'" . ruby-mode))
       :config
       (setq ruby-insert-encoding-magic-comment nil))
   #+END_SRC

** [[https://github.com/rust-lang/rust-mode][Rust]]

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package rust-mode
       :custom
       (rust-format-on-save t)
       :defer t)
   #+END_SRC

** Scala

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package scala-mode
       :interpreter ("scala" . scala-mode))
   #+END_SRC

** Terraform

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package terraform-mode)
   #+END_SRC

** Thrift

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package thrift)
   #+END_SRC

** Web

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package web-mode
       :config
       (setq web-mode-markup-indent-offset 2)
       (setq web-mode-attr-indent-offset 2)
       (setq web-mode-css-indent-offset 2)
       (setq web-mode-code-indent-offset 2)
       (setq web-mode-enable-auto-pairing t)
       (setq web-mode-enable-css-colorization t)
       (add-hook 'before-save-hook 'delete-trailing-whitespace nil 'local)
       :mode ("\\.html?\\'" "\\.erb\\'" "\\.hbs\\'"
              "\\.s?css\\'" "\\.less\\'" "\\.sass\\'"))
   #+END_SRC

** YAML

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package yaml-mode)
   #+END_SRC

** Zig

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package zig-mode
       :hook (zig-mode . eglot-ensure))
   #+END_SRC
